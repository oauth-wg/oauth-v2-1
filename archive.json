{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-06-22T00:15:56.137185+00:00",
  "repo": "oauth-wg/oauth-v2-1",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "draft-00-feedback",
      "description": "Feedback from reviews of draft -00",
      "color": "DB61A2"
    },
    {
      "name": "interim",
      "description": "Items to discuss in the next WG interim meeting",
      "color": "bfd4f2"
    },
    {
      "name": "editors discussion",
      "description": "Items to discuss in the next editors' call",
      "color": "0e8a16"
    },
    {
      "name": "ietf-113",
      "description": "",
      "color": "006b75"
    },
    {
      "name": "editorial",
      "description": "This issue does not affect existing implementations",
      "color": "C1F041"
    },
    {
      "name": "dickhardt",
      "description": "",
      "color": "bfd4f2"
    },
    {
      "name": "torsten",
      "description": "",
      "color": "980A42"
    },
    {
      "name": "ietf-process",
      "description": "Questions about IETF process needing input from outside the WG",
      "color": "c2e0c6"
    },
    {
      "name": "client-definition-consolidation",
      "description": "",
      "color": "2250B1"
    },
    {
      "name": "ietf-114",
      "description": "",
      "color": "c5def5"
    },
    {
      "name": "ietf-115",
      "description": "",
      "color": "fef2c0"
    },
    {
      "name": "ietf-116",
      "description": "",
      "color": "c2e0c6"
    },
    {
      "name": "ietf-117",
      "description": "",
      "color": "bfdadc"
    },
    {
      "name": "ietf-122",
      "description": "",
      "color": "D9DECE"
    }
  ],
  "issues": [
    {
      "number": 9,
      "id": "MDU6SXNzdWU2MDY2MzgxMTI=",
      "title": "Clarify redirect URI comparison",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/9",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "From Brian Campbell:\r\n\r\n> https://tools.ietf.org/html/draft-parecki-oauth-v2-1-01#section-3.1.2\"\u00a0\u00a0 The authorization server MUST compare the two URIs using simple\r\n> \u00a0 \u00a0string comparison as defined in [RFC3986], Section 6.2.1.\"There's absolutely no context here for understanding what two URIs are being compared.\u00a0Mandating full redirect_uri comparison is maybe more appropriate in 4.1.1 with the redirect_uri parameter somewhere. And 3.1.2.3. and 3.1.2.2 needs some attention with respect to this too. \r\n> But also an exception (for the port part) to full redirect_uri comparison is needed for loopback redirect_uris on native clients as in https://tools.ietf.org/html/draft-parecki-oauth-v2-1-01#section-9.6.1 and https://tools.ietf.org/html/draft-parecki-oauth-v2-1-01#section-9.2 and https://tools.ietf.org/html/draft-parecki-oauth-v2-1-01#section-10.3.3 \r\n\r\nhttps://mailarchive.ietf.org/arch/msg/oauth/5hCWu0tIRk11jnW6_M87Rx7S560/\r\n\r\n\r\n",
      "createdAt": "2020-04-24T23:37:57Z",
      "updatedAt": "2021-03-16T17:21:20Z",
      "closedAt": "2021-03-16T17:21:20Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Suggest removing the comparison -- that is a step in the protocol, but this section is describing what a redirection endpoint is.",
          "createdAt": "2021-03-15T23:56:07Z",
          "updatedAt": "2021-03-15T23:56:07Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "The sentence about comparing the two is removed since it's not needed at this point",
          "createdAt": "2021-03-16T17:21:20Z",
          "updatedAt": "2021-03-16T17:21:20Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU2MTYwNjY2ODE=",
      "title": "Refresh Token rotation as MUST for public clients?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/10",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Vittorio proposed to make this a MUST for SPAs only.\r\n\r\nWe need to think this through.",
      "createdAt": "2020-05-11T17:50:29Z",
      "updatedAt": "2020-07-02T16:23:40Z",
      "closedAt": "2020-07-02T16:23:40Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Does a client secret not already fall under the definition of a sender-constrained refresh token? I had actually already thought that a client secret would make refresh token rotation not necessary.",
          "createdAt": "2020-05-11T18:26:10Z",
          "updatedAt": "2020-05-11T18:26:10Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "that's correct. It only makes sense for public clients, which don't have a way to use mTLS or DPoP for sender constraining.",
          "createdAt": "2020-05-21T17:42:04Z",
          "updatedAt": "2020-05-21T17:42:04Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This has been resolved:\r\n\r\n```\r\nWhen client authentication is not possible, the\r\nauthorization server SHOULD issue sender-constrained refresh tokens\r\nor use refresh token rotation as described in (#refresh_token_protection).\r\n```",
          "createdAt": "2020-07-02T16:23:40Z",
          "updatedAt": "2020-07-02T16:23:40Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU2MTYwNjczOTE=",
      "title": "Remove IANA registry section",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/11",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Everything is already defined in the IANA registries by OAuth 2.0, no need to re-define them",
      "createdAt": "2020-05-11T17:51:38Z",
      "updatedAt": "2020-05-11T22:06:35Z",
      "closedAt": "2020-05-11T22:06:35Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWU2MTYwNjc0ODQ=",
      "title": "Point to existing IANA registries",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/12",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-11T17:51:47Z",
      "updatedAt": "2020-05-11T22:06:36Z",
      "closedAt": "2020-05-11T22:06:36Z",
      "comments": []
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU2MTYwNzcwNDA=",
      "title": "Name for the third client type",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/13",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "OAuth 2.0 defines two client types: confidential and public. However there are actually two attributes defined under these: authentication and identity.\r\n\r\nConfidential clients are clients that can authenticate at the AS and also whose identity is confirmed by the AS.\r\n\r\nPublic clients cannot authenticate and their identity also cannot be confirmed by the AS.\r\n\r\nThe third type of client is a client that can authenticate but whose identity has not been confirmed by the AS. Examples of this include:\r\n\r\n* A native app that uses dynamic client registration to register a unique client ID and secret\r\n* A WordPress plugin that uses dynamic client registration\r\n\r\nIn both cases, the existing public and confidential client definitions do not capture the situation. \r\n\r\nWe should brainstorm names for this type of client, and refer to this type in the document where appropriate.",
      "createdAt": "2020-05-11T18:07:14Z",
      "updatedAt": "2020-07-02T17:00:47Z",
      "closedAt": "2020-07-02T17:00:47Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "@dickhardt suggested \"credentialed\" as the name for the third client type",
          "createdAt": "2020-06-30T03:25:43Z",
          "updatedAt": "2020-06-30T03:25:43Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Done in 2dd065c09326386b6b17c7453f9207ccceea86cc",
          "createdAt": "2020-07-02T17:00:47Z",
          "updatedAt": "2020-07-02T17:00:47Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU2MTYxMDcwMzI=",
      "title": "Update redirect URI allowance for port based on Security BCP",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/14",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Depending on the outcome of this thread: https://mailarchive.ietf.org/arch/msg/oauth/cwJuRoDNf8XIFngoam-7IqwpHHc/",
      "createdAt": "2020-05-11T18:56:12Z",
      "updatedAt": "2021-03-16T17:26:31Z",
      "closedAt": "2021-03-16T17:26:31Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Closing this in favor of #40 ",
          "createdAt": "2021-03-16T17:26:31Z",
          "updatedAt": "2021-03-16T17:26:31Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU2MTcxOTMxMjA=",
      "title": "Consolidate Text on CSRF and Code Replay",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/15",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "client MUST use code_challenge to detect both attacks",
      "createdAt": "2020-05-13T06:55:30Z",
      "updatedAt": "2020-07-02T17:01:02Z",
      "closedAt": "2020-07-02T17:01:01Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This has been incorporated",
          "createdAt": "2020-07-02T17:01:01Z",
          "updatedAt": "2020-07-02T17:01:01Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU2NTc3MTUzMjM=",
      "title": "Clean up usage of the term \"client identity\"",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/18",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-definition-consolidation"
      ],
      "body": "https://tools.ietf.org/html/draft-parecki-oauth-v2-1-03#section-2.3\r\n\r\n> authorization server MUST NOT rely on credentialed\r\n> client authentication for the purpose of identifying the client.\r\n\r\nMost of the usage of the term is talking about identifying clients for the purposes of the consent screen. This usage seems to be different and is potentially confusing.\r\n\r\nThe concept of client identity needs to be defined somewhere.\r\n\r\nThe current text is hinting that there is something the AS should not be doing with credentialed clients that it might be doing if you're only looking for the presence of client authentication. That needs clarification.",
      "createdAt": "2020-07-15T23:04:24Z",
      "updatedAt": "2022-07-16T00:25:52Z",
      "closedAt": "2022-07-16T00:25:52Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Suggested text:\r\n\r\nHowever, the authorization server MUST ONLY rely on information obtained from the client after being converted to a credentialed client.",
          "createdAt": "2021-03-16T00:02:05Z",
          "updatedAt": "2021-03-16T00:02:05Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Addressed by the removal of \"credentialed client\" in #123 ",
          "createdAt": "2022-07-16T00:25:52Z",
          "updatedAt": "2022-07-16T00:25:52Z"
        }
      ]
    },
    {
      "number": 19,
      "id": "MDU6SXNzdWU2ODgyMDU2MjA=",
      "title": "Drop reference to \"third-party\" from abstract",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/19",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "https://mailarchive.ietf.org/arch/msg/oauth/Ltm9TJ2mtfNAnHYhdV0-q5mEjdc/",
      "createdAt": "2020-08-28T16:37:36Z",
      "updatedAt": "2022-07-24T22:47:39Z",
      "closedAt": "2022-07-24T22:47:39Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "   The OAuth 2.1 authorization framework enables an\r\n   application to obtain limited access to an HTTP service, either on\r\n   behalf of a resource owner by orchestrating an approval interaction\r\n   between the resource owner and the HTTP service, or by allowing the\r\n   application to obtain access on its own behalf.  This\r\n   specification replaces and obsoletes the OAuth 2.0 Authorization\r\n   Framework described in RFC 6749 <https://tools.ietf.org/html/rfc6749>\r\n   and the Bearer Token Usage in RFC 6750 <https://tools.ietf.org/html/rfc6750>",
          "createdAt": "2022-07-15T19:54:56Z",
          "updatedAt": "2022-07-15T19:54:56Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU3MDkzMTA4NzU=",
      "title": "Clarify refresh token rotation",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/20",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "The text from [RFC6819](https://tools.ietf.org/html/rfc6819#section-5.2.2) around refresh tokens didn't end up getting copied into OAuth 2.1 yet. \r\n\r\nThe Security BCP doesn't mention anything about revoking related access tokens when refresh token replay is detected, but 6819 does. We should consolidate the text into 2.1 to make this aspect clear.",
      "createdAt": "2020-09-25T22:06:13Z",
      "updatedAt": "2022-11-08T13:32:47Z",
      "closedAt": "2022-11-08T13:32:47Z",
      "comments": []
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU3MzE4MjI0MDU=",
      "title": "Why don't \"always TLS\" or similar",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/21",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "# Question\r\n\r\niiuc the spec says that TLS:\r\n- sometimes is MUST\r\n- sometimes is SHOULD\r\n- other parts say MUST always\r\n\r\nwhy don't always TLS?\r\n\r\n# Note\r\n\r\nHTTP/3 aka QUIC may offer TLS-like mechanisms. We could ping the HTTP/3 workgroup and ask them if it is reasonable to make oauth2.1 specs independent from the adopted integrity layer. ",
      "createdAt": "2020-10-28T22:05:09Z",
      "updatedAt": "2021-03-16T17:46:10Z",
      "closedAt": "2021-03-16T17:46:10Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I took a look through the doc and as far as I can tell the only instance of \"SHOULD\" is around redirect URLs. I'm going to close this in favor of keeping that discussion in #40 ",
          "createdAt": "2021-03-16T17:46:10Z",
          "updatedAt": "2021-03-16T17:46:10Z"
        }
      ]
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU3MzI0MjU0ODY=",
      "title": "TLS validation",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/23",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## Question\r\n\r\n7.4.2 states\r\n\r\n```the client MUST validate the TLS\r\n   certificate chain when making requests to protected resources,\r\n   including checking the Certificate Revocation List (CRL) [RFC5280].\r\n```\r\n\r\nWhile this is correct, there are various way of addressing TLS security, eg. https://httpwg.org/specs/rfc8740.html\r\n\r\nProbably we should find a way to start from a generic TLS BCP and extend on that.\r\n",
      "createdAt": "2020-10-29T15:38:00Z",
      "updatedAt": "2021-03-12T15:46:45Z",
      "closedAt": "2021-03-12T15:46:45Z",
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk WDYT ?",
          "createdAt": "2021-02-02T17:07:41Z",
          "updatedAt": "2021-02-02T17:07:41Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "the validation issue has been fixed directly in https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html\r\n\r\nclosed in favor of #50 ",
          "createdAt": "2021-03-12T15:46:45Z",
          "updatedAt": "2021-03-12T15:46:45Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU3NDQyODA2MzE=",
      "title": "Clarify when `client_id` is required to be sent to the token endpoint",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/24",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There is currently some inconsistency in implementations about whether `client_id` is a required parameter at the token endpoint. Some grants make it clear when it's required, but for example the refresh token grant does not mention it. We should clarify when it's required, and keep in mind existing deployments that may require it already for refresh token grants.\r\n\r\nHistorical note: This confusion between implementations is likely due to the fact that `client_id` was explicitly a required parameter in draft 10: https://tools.ietf.org/html/draft-ietf-oauth-v2-10#section-4",
      "createdAt": "2020-11-16T23:24:34Z",
      "updatedAt": "2021-09-08T20:51:46Z",
      "closedAt": "2021-09-08T20:51:39Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This has been cleared up in the refactoring from #78 ",
          "createdAt": "2021-09-08T20:51:39Z",
          "updatedAt": "2021-09-08T20:51:39Z"
        }
      ]
    },
    {
      "number": 25,
      "id": "MDU6SXNzdWU3OTg0NjUzODg=",
      "title": "Clarify scope of the spec",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/25",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "dickhardt"
      ],
      "labels": [
        "draft-00-feedback",
        "editorial"
      ],
      "body": "[From Vittorio](https://mailarchive.ietf.org/arch/msg/oauth/RP71xU8P4WLLIx0NcQMnw4gHScQ/):\r\n\r\n> I wonder whether we should take the opportunity offered by OAuth2.1 to clarify frequent points of confusion about OAuth, by explicitly calling out in the introduction what is out of scope.\r\n>\r\n> For example: OAuth is not an identity protocol, as it doesn\u2019t concern itself with how resource owners are authenticated; OAuth isn\u2019t meant to address 1st party scenarios, although the reader is free to use it in that context as well; and so on.\r\n>\r\n> I believe there is value in adding this in the introduction rather than relegating it in some later considerations section, as the people who need this information the most rarely read past this point.\r\n\r\n",
      "createdAt": "2021-02-01T15:36:13Z",
      "updatedAt": "2023-07-10T21:44:18Z",
      "closedAt": "2023-07-10T21:44:17Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Related comment from vittorio:\r\n\r\n> \u00a71.8\r\n> Should we say rich *delegated* authorization framework?",
          "createdAt": "2021-02-02T01:04:59Z",
          "updatedAt": "2021-02-02T01:04:59Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Also, the abstract likely needs to be updated. Currently it says:\r\n\r\n> The OAuth 2.1 authorization framework enables a third-party application to obtain limited access to an HTTP service...\r\n\r\nand we know that it's used for far more than third-party applications now.",
          "createdAt": "2021-02-02T01:05:39Z",
          "updatedAt": "2021-02-02T01:05:39Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with both points. We should include what it is not, and ensure how it is used is included.",
          "createdAt": "2021-03-16T00:03:27Z",
          "updatedAt": "2021-03-16T00:03:27Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Related to #19 ",
          "createdAt": "2022-06-28T23:33:30Z",
          "updatedAt": "2022-06-28T23:33:30Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Most of this is resolved now, but could probably use some additional text in the intro on these two points:\r\n\r\n* OAuth is not an identity protocol\r\n* it doesn\u2019t concern itself with how resource owners are authenticated\r\n\r\nThere is now some text that mentions the AS authenticating the resource owner, but could be more explicit to address this point.",
          "createdAt": "2022-10-24T22:20:31Z",
          "updatedAt": "2022-10-24T22:20:31Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Addressed in 125b9a41ed1c71a66f6b69aafa75e56af8323d60",
          "createdAt": "2023-07-10T21:44:17Z",
          "updatedAt": "2023-07-10T21:44:17Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWU3OTg4MDA4Nzk=",
      "title": "Update \"Protocol Flow\" introduction section",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/26",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "from Vittorio:\r\n\r\n---\r\n\r\n\u00a71.2\r\n\r\nI always found this part extraordinarily difficult to decipher. I get that this is the first description and doesn\u2019t have to be exhaustive and consider all cases (eg it\u2019s ok if step 3 claims that the client authenticates w the AS even tho that\u2019s only for confidential clients), but I think it could be much clearer than it is today.\r\n\r\nStep 1 says\r\n\r\nThe client requests authorization from the resource owner.  The authorization request can be made directly to the resource owner (as shown), or preferably indirectly via the authorization server as an intermediary.\r\n\r\nBesides the fact that \u201crequests authorization\u201d is a bit vague, this step and the corresponding diagram leg does not correspond at all to what normally happens- to get a code, the client does need to hit the AS and the mention in passing in the text isn\u2019t enough to figure that out. Also, with the omission of ROPG there really isn\u2019t any way of asking anything to the RO directly (the client creds doesn\u2019t involve the RO).\r\n\r\nI would recommend updating that diagram to be more descriptive of the canonical scenario.\r\n\r\nStep 2\r\n\r\nmentions the 2 grants defined in the spec, but only one of them represents the RO\u2019s authorization. Claiming that the client itself is the RO is a formalism that doesn\u2019t meet the reader\u2019s intuition at this point.\r\n\r\nStep 5\r\n\r\nThe language here triggered multiple discussions, in particular on whether the AT can actually be used to ascertain the identity of the client \u2013 that isn\u2019t the case for public clients, for example; besides, that\u2019s not really the highest order bit of the AT. If it is, it seems that the spec should be more explicit about how client identification from the RS by means of an AT works. If it isn\u2019t, perhaps we should change the language to omit authenticate.\r\n\r\nThe last paragraph is emblematic IMO \u2013 if the preferred method is very different from the diagram here, and if the abstraction presented here is not terribly useful (given that we no longer have multiple RO based grants, excluding the extension grants that are still too far at this point to warrant a cognitive downpayment for the reader) I wonder whether we\u2019d be better off doing the authz code diagram directly (and mention that we also have the client creds grant separately).\r\n\r\n ",
      "createdAt": "2021-02-01T23:47:42Z",
      "updatedAt": "2022-06-28T23:35:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "and from Justin:\r\n\r\n> \u00a71.2: This diagram could use an update to not show the client talking directly to the RO in the first step, especially because the ROPC grant has been removed here. The way it\u2019s written now makes it look like the user gives something to the client which it then trades for a token directly, which doesn\u2019t happen quite like that anywhere.\r\n",
          "createdAt": "2021-02-02T01:32:08Z",
          "updatedAt": "2021-02-02T01:32:08Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "The diagram is an abstract protocol flow of who talks to who. I do agree it is confusing as drawn, and the description is quite confusing.",
          "createdAt": "2021-03-16T00:06:05Z",
          "updatedAt": "2021-03-16T00:06:05Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm understanding the attempt to come up with an abstract description of the flow, but I don't see a common denominator between client credential, code and refresh token. I suggest to focus on the grant specific flow descriptions or perhaps one for code + refresh token to give a bigger picture.",
          "createdAt": "2021-03-16T16:45:22Z",
          "updatedAt": "2021-03-16T16:45:22Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Also related to #29 \"Clarify 'authorization grant'\"",
          "createdAt": "2022-06-28T23:35:37Z",
          "updatedAt": "2022-06-28T23:35:37Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "MDU6SXNzdWU3OTg4MDIzNjc=",
      "title": "Clients as Resource Owners",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/27",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "ietf-114"
      ],
      "body": "from Vittorio:\r\n\r\n---\r\n\r\n\u00a71.3\r\n\r\nI understand that we can\u2019t really change this because we inherit from OAuth 2 but I\u2019ll mention it anyway- modeling clients as ROs is problematic, as it doesn\u2019t often match what happens in practice. A confidential client might batch-read a user\u2019s inbox searching for ad words, but the resource owner remains the user.\r\n\r\nI know we straighten things up in 1.3.2, but the positioning here is confusing.\r\n\r\nAlso: isn\u2019t the refresh token grant a core-specified grant as well? I know I am nitpicking.",
      "createdAt": "2021-02-01T23:51:34Z",
      "updatedAt": "2022-07-21T02:05:45Z",
      "closedAt": "2022-07-16T00:20:14Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't understand the issue being brought up.",
          "createdAt": "2021-03-16T00:09:20Z",
          "updatedAt": "2021-03-16T00:09:20Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I think the mismatch is that \"resource owner\" is often thought of as an end user. The actual definition is \"An entity capable of granting access to a protected resource\", so I actually don't think there is a problem here other than it being slightly confusing. Under that definition, a client as a resource owner may already be capable of granting access to a resource that might be an actual user's data. ",
          "createdAt": "2022-06-28T23:38:38Z",
          "updatedAt": "2022-06-28T23:38:38Z"
        }
      ]
    },
    {
      "number": 28,
      "id": "MDU6SXNzdWU3OTg4MzY5NTg=",
      "title": "Resolve \"obsoletes and replaces\" language",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/28",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "ietf-process"
      ],
      "body": "We need to figure out exactly what and how this draft replaces and obsoletes according to the IETF processes. Given the number of drafts that it's rolling up we need to make sure the references are in the right place and it's done properly.",
      "createdAt": "2021-02-02T01:12:03Z",
      "updatedAt": "2022-06-28T23:40:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See #49 ",
          "createdAt": "2021-03-12T15:47:57Z",
          "updatedAt": "2021-03-12T15:47:57Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's get language from our AD. Agree we want a complete list of what is being impacted.",
          "createdAt": "2021-03-16T00:10:14Z",
          "updatedAt": "2021-03-16T00:10:14Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "any news?",
          "createdAt": "2022-06-10T06:30:52Z",
          "updatedAt": "2022-06-10T06:30:52Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "any news?",
          "createdAt": "2022-06-10T06:30:52Z",
          "updatedAt": "2022-06-10T06:30:52Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWU3OTg4NDY1MjQ=",
      "title": "Clarify \"authorization grant\"",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/29",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [
        "draft-00-feedback",
        "ietf-114"
      ],
      "body": "From Justin:\r\n\r\n---\r\n\r\n\u00a71.3: Having taught many OAuth 2 classes to hundreds of people over the years, I can say with confidence that this definition of \u201cgrant\u201d as a credential has historically been problematic and confusing to most people. And in particular, it doesn\u2019t even really apply to the client credentials flow listed here: there is not a separate \"credential representing authorization\", just the client\u2019s own authentication. Suggest new text to more accurately reflect what a \u201cgrant\u201d is in the OAuth reality:\r\n\r\n> An authorization grant is a process by which a client obtains authorization from a resource owner to obtain an access token to act on that resource owner\u2019s behalf. This specification defines...\r\n\r\nChanging this would require a consensus call ",
      "createdAt": "2021-02-02T01:34:37Z",
      "updatedAt": "2022-07-21T02:05:41Z",
      "closedAt": "2022-07-16T00:20:05Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "most people refer to it as \"flow\" and there are flow not even involving a RO (like client credentials).",
          "createdAt": "2021-03-02T14:00:19Z",
          "updatedAt": "2021-03-02T14:00:19Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think changing this will help -- and will likely cause lots of confusion. \r\nMyself, I think the larger issue is that we are conflating protocol roles with entities. The RO is not really part of the protocol, and the client can't own a resource. ",
          "createdAt": "2021-03-16T00:14:46Z",
          "updatedAt": "2021-03-16T00:14:46Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Actually I'm now thinking maybe we should just drop section 1.3 entirely, since it's mainly a summary/duplicate of the new Section 4 \"Grant Types\". If anything, it could stay as just a summary of the flows and the header could change to \"Summary of Grant Types\" or something.",
          "createdAt": "2022-03-19T18:22:35Z",
          "updatedAt": "2022-03-19T18:22:35Z"
        }
      ]
    },
    {
      "number": 31,
      "id": "MDU6SXNzdWU4MDk0OTI3ODM=",
      "title": "NIST SP 800-63-1 obsoleted ",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/31",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "question"
      ],
      "body": "## I expect\r\n\r\nAn updated ref to NIST SP publication.\r\n\r\n## Instead \r\n\r\nThe I-D cites NIST SP 800-63-1 withdrawn in 2013\r\nNote: 800-63-2 was Withdrawn on June 22, 2017. Superseded by SP 800-63-3; SP 800-63C; SP 800-63A; SP 800-63B\r\n",
      "createdAt": "2021-02-16T17:09:59Z",
      "updatedAt": "2022-06-29T07:24:35Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "@ioggstream Can you confirm that the current list of threats in the doc are still included in the latest set of NIST documents? What I'm looking for is whether the list in the OAuth draft needs to be updated with more/less items based on the latest NIST docs.",
          "createdAt": "2022-06-28T23:42:05Z",
          "updatedAt": "2022-06-28T23:42:05Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good question :)\n\nI need to work on it.\n",
          "createdAt": "2022-06-29T07:24:34Z",
          "updatedAt": "2022-06-29T07:24:34Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWU4MTk0MTYwMTA=",
      "title": "AS's confidence in the client's identity ",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/33",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "client-definition-consolidation",
        "ietf-114"
      ],
      "body": "From Vittorio:\r\n\r\n---\r\n\r\nSection 2.1 P4\r\n> \u201cAuthorization servers SHOULD consider the level of confidence in a client's identity when deciding whether they allow such a client access to more critical functions, such as the Client Credentials grant type.\u201d \r\n\r\nI don\u2019t understand this sentence. Is the client credentials grant type a \u201cmore critical function\u201d? Or is it a level of confidence? Either ways, I think it needs clarifying.",
      "createdAt": "2021-03-01T23:44:14Z",
      "updatedAt": "2022-07-21T02:05:37Z",
      "closedAt": "2022-07-16T00:27:56Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree it needs more clarification.",
          "createdAt": "2021-03-16T00:15:40Z",
          "updatedAt": "2021-03-16T00:15:40Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "The \"more critical functions\" text was changed in #123 ",
          "createdAt": "2022-07-16T00:27:56Z",
          "updatedAt": "2022-07-16T00:27:56Z"
        }
      ]
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU4MTk0MTY5NTg=",
      "title": "A single \"client_id\" MUST NOT be treated as more than one type of client.",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/34",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "client-definition-consolidation",
        "ietf-114"
      ],
      "body": "From Vittorio:\r\n\r\n---\r\n\r\nIMPORTANT: this is going to break many OAuth implementations with significant adoption. Auth0 is fine (each client_id is tied to a single client type) but I know of others that will break.\r\nI suggest softening to a SHOULD NOT.",
      "createdAt": "2021-03-01T23:46:10Z",
      "updatedAt": "2022-07-21T02:05:32Z",
      "closedAt": "2022-07-16T00:39:35Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I actually can't find the source for this text, it doesn't appear in 6749 or the Security BCP",
          "createdAt": "2021-03-01T23:46:27Z",
          "updatedAt": "2021-03-01T23:46:27Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "my either - but it sounds reasonable. Let's add it.",
          "createdAt": "2021-03-02T13:58:02Z",
          "updatedAt": "2021-03-02T13:58:02Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "agreed",
          "createdAt": "2021-03-02T16:56:25Z",
          "updatedAt": "2021-03-02T16:56:25Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk this has been merged iiuc, but the spec does not define `client_id` previously so it is not clear to the reader what a `client_id` is.",
          "createdAt": "2021-03-11T13:31:21Z",
          "updatedAt": "2021-03-11T13:31:21Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This was apparently added between April and July 2020, but I don't remember why.\r\n\r\nhttps://www.ietf.org/rfcdiff?difftype=--hwdiff&url2=draft-parecki-oauth-v2-1-03.txt",
          "createdAt": "2022-03-19T18:06:16Z",
          "updatedAt": "2022-03-19T18:06:16Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWU4MTk0MjcwMzU=",
      "title": "warn against using structured client_ids",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/35",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "from Vittorio:\r\n\r\n---\r\n\r\nWondering whether a warning against structured client_ids (eg identifiers assembled thru some string template, like developer name+region+serial) would be in order. Perhaps in the security considerations?",
      "createdAt": "2021-03-02T00:06:49Z",
      "updatedAt": "2023-07-27T15:50:14Z",
      "closedAt": "2023-07-27T15:22:27Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "What is Vittorio's concern? Leakage of metadata? An attacker can construct a client_id?",
          "createdAt": "2021-03-16T00:17:24Z",
          "updatedAt": "2021-03-16T00:17:24Z"
        }
      ]
    },
    {
      "number": 36,
      "id": "MDU6SXNzdWU4MTk0MzIzMjQ=",
      "title": "Authorization servers SHOULD use client authentication if possible",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/36",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "editorial",
        "client-definition-consolidation"
      ],
      "body": "From vittorio:\r\n\r\n---\r\n\r\n\u00a7[2.3](https://tools.ietf.org/html/draft-ietf-oauth-v2-1-00#section-2.3)\r\n\r\n> Authorization servers SHOULD use client authentication if possible\r\n\r\nThat sounds vague. Shouldn\u2019t it be mandatory for the AS to require client auth for the client types who have creds? \u201cif possible\u201d seem to open the possibility of circumstances where that\u2019s not he case.\r\n\r\n[\u00a73.2.1](https://tools.ietf.org/html/draft-ietf-oauth-v2-1-00#section-3.2.1)\r\nP1\r\nThat\u2019s stricter than \u00a72.3P3 \u2013 I think the language there should be tweaked to be coherent with the one here.\r\n",
      "createdAt": "2021-03-02T00:15:17Z",
      "updatedAt": "2022-07-16T00:30:48Z",
      "closedAt": "2022-07-16T00:30:47Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This came from the Security BCP. I think we should clarify this now that it's rolled into this draft. The Security BCP might also need to clarify the intent of this as well.",
          "createdAt": "2021-03-02T00:16:23Z",
          "updatedAt": "2021-03-02T00:16:23Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you point me to the respective text in the Security BCP?",
          "createdAt": "2021-03-02T13:52:24Z",
          "updatedAt": "2021-03-02T13:52:24Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think 2.3 (and 9.1) is merely meant as general recommendation to use client authentication wherever possible. Stating that credentialed clients always need to authenticated seems obvious, but adding it does not hurt. ",
          "createdAt": "2021-03-02T13:56:22Z",
          "updatedAt": "2021-03-02T13:56:22Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "agreed",
          "createdAt": "2021-03-02T16:56:13Z",
          "updatedAt": "2021-03-02T16:56:13Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This was removed in draft -03\r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-03#section-2.4",
          "createdAt": "2022-07-16T00:30:47Z",
          "updatedAt": "2022-07-16T00:30:47Z"
        }
      ]
    },
    {
      "number": 37,
      "id": "MDU6SXNzdWU4MTk0MzM5NDA=",
      "title": "clarify \"identify the client\"",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/37",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "editors discussion"
      ],
      "body": "From vittorio:\r\n\r\n---\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-oauth-v2-1-00#section-2.3\r\n\r\nI think that this idea of identifying the client will need to be fleshed out more for people to fully understand it. Credentialed clients can prove that they are the same client instance across multiple transactions, which some might consider a weak form of identification. To rule that out, it has to be mentioned upfront IMO. If not here, in some of the considerations section\u2026 with a forward reference here.",
      "createdAt": "2021-03-02T00:17:41Z",
      "updatedAt": "2021-09-22T20:05:25Z",
      "closedAt": "2021-09-22T18:44:04Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think a couple examples of how credentialed clients can be used, and should not be used will help.",
          "createdAt": "2021-03-16T00:19:14Z",
          "updatedAt": "2021-03-16T00:19:14Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Clients are confidential clients when the AS has prior knowledge of the client. Clients are credentialed clients when the AS only knows the clients credential.",
          "createdAt": "2021-09-21T19:58:03Z",
          "updatedAt": "2021-09-21T19:58:03Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWU4MTk0MzUxNjY=",
      "title": "The client MUST NOT use more than one authentication method",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/38",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "from Vittorio:\r\n\r\n---\r\n\r\n> The client MUST NOT use more than one authentication method\r\n\r\nDo we say why anywhere? If yes, we should reference it. If not, perhaps we should.\r\n",
      "createdAt": "2021-03-02T00:19:07Z",
      "updatedAt": "2021-09-22T20:05:35Z",
      "closedAt": "2021-09-22T18:24:01Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "why MUST a client not use more than one authentication method? Why do we even need to talk about this in the spec?",
          "createdAt": "2021-03-02T13:49:33Z",
          "updatedAt": "2021-03-02T13:49:33Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Agree w/ Torsten",
          "createdAt": "2021-03-16T00:19:53Z",
          "updatedAt": "2021-03-16T00:19:53Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "The question would be what happens if there are multiple authentication methods but they contain different credentials? Which would take priority etc",
          "createdAt": "2021-09-08T21:00:15Z",
          "updatedAt": "2021-09-08T21:00:15Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think an AS should treat this as an error.",
          "createdAt": "2021-09-21T16:45:32Z",
          "updatedAt": "2021-09-21T16:45:32Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "What about if the client is distributed, IE there are numerous servers that each have their own valid private key?\r\n",
          "createdAt": "2021-09-21T16:51:12Z",
          "updatedAt": "2021-09-21T16:51:12Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "ok, I think I misread Aaron's statement. I don't see any issue with multiple private keys per client.\r\n\r\n1. Credentials of different kind (mechanism): the client is only allowed to authenticate in a certain request using one mechanism. An attempt to use e.g. mTLS for client authentication and BASIC is an error. \r\n2. Multiple credentials of same kind: If there are multiple instances of a client using the same mechanism but different credentials (e.g. different private keys), then this is possible as long as the client authentication mechanism supports it. mTLS does support the setup of clients with multiple certs.  ",
          "createdAt": "2021-09-21T16:56:48Z",
          "updatedAt": "2021-09-21T16:57:23Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "The sentence quoted is actually this:\r\n\r\n> The client MUST NOT use more than one authentication method **in each request**\r\n\r\nSo specifically about a single client request to the AS, it wouldn't make sense for it to have multiple authentication methods (e.g. mTLS as well as a client ID/secret)",
          "createdAt": "2021-09-21T19:23:56Z",
          "updatedAt": "2021-09-21T19:23:56Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "to prevent a conflict of which authentication mechanism is authoritative for the request.",
          "createdAt": "2021-09-21T19:24:13Z",
          "updatedAt": "2021-09-21T19:24:13Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU4MTk0NjIxNDg=",
      "title": "clarify case sensitivity of redirect URI string matching",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/39",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "tlodderstedt"
      ],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "from Vittorio:\r\n\r\n---\r\n\r\n> The authorization server MUST compare the two URIs using simple\r\n>  string comparison as defined in [RFC3986], Section 6.2.1.\r\n\r\nRFC3986 6.2.1 talks about character by character comparison, but doesn\u2019t mention case sensitivity. I am sure it does elsewhere in the spec, but for clarify and readability I recommend specifying the desired behavior directly here.",
      "createdAt": "2021-03-02T00:44:29Z",
      "updatedAt": "2024-02-24T01:04:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Technically I'm not sure case sensitive matching of the host name is actually required if you were to follow RFC3986, since host names are case insensitive. We should probably clarify this in the Security BCP and 2.1.",
          "createdAt": "2021-03-02T00:45:26Z",
          "updatedAt": "2021-03-02T00:45:26Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "RFC 3986 6.2.1. talks about \"bit-for-bit\" or \"byte-for-byte\" comparison, which means case sensitive matching. Is that what you want to state?",
          "createdAt": "2021-03-02T13:48:47Z",
          "updatedAt": "2021-03-02T13:48:47Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "character by character comparison? byte for byte can be challenging as different byte arrangements can represent the same character. I do think we are intending a case sensitive string comparison.",
          "createdAt": "2021-03-16T00:21:55Z",
          "updatedAt": "2021-03-16T00:21:55Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "@tlodderstedt I believe the Security BCP has some updated language to use here, could you pull from that and make a PR?",
          "createdAt": "2024-02-24T00:14:36Z",
          "updatedAt": "2024-02-24T00:14:36Z"
        },
        {
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Using simple string comparison for redirect URIs is not always possible due to the usage of randomly assigned ports in Redirect URIs for public (native) clients.\r\n\r\nThe OpenID Connect Core spec says that\r\n\r\n> REQUIRED. Redirection URI to which the response will be sent. This URI MUST exactly match one of the Redirection URI values for the Client pre-registered at the OpenID Provider, with the matching performed as described in Section 6.2.1 of [[RFC3986]](https://openid.net/specs/openid-connect-core-1_0.html#RFC3986) (Simple String Comparison).\r\n\r\nwhich kind of makes it \"impossible\" to use an ephemeral port obtained from the OS for these clients.",
          "createdAt": "2024-02-24T00:36:34Z",
          "updatedAt": "2024-02-24T00:36:34Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "There's already an exception for the random port, so we'll need to carve that out in this top section too.",
          "createdAt": "2024-02-24T01:04:14Z",
          "updatedAt": "2024-02-24T01:04:14Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU4MTk0NjQwMzQ=",
      "title": "require HTTPS redirect URLs",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/40",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "from vittorio:\r\n\r\n---\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-oauth-v2-1-00#section-3.1.2.1\r\n\r\nPersonally, I would advocate for a MUST here. True, lots of people won\u2019t comply at development time, but I think that\u2019s OK as long as they do use TLS when going in production.\r\n\r\nAlso, SameSite changes are making the use of HTTPS at dev time more and more common. If OAuth2.1 is about picking the best of the security practices, this seems like a an obvious candidate.\r\n",
      "createdAt": "2021-03-02T00:46:28Z",
      "updatedAt": "2022-02-10T00:05:34Z",
      "closedAt": "2022-02-10T00:05:34Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 MUST - it makes sense, is simpler to explain than SHOULD and does not leave security holes",
          "createdAt": "2021-03-02T13:40:51Z",
          "updatedAt": "2021-03-02T13:40:51Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "See #30 for a possible fix",
          "createdAt": "2021-03-11T14:29:08Z",
          "updatedAt": "2021-03-11T14:29:08Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 with exceptions for loop back and non-http schemes",
          "createdAt": "2021-03-16T00:22:19Z",
          "updatedAt": "2021-03-16T00:22:53Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "+1 with exceptions for localhost and custom URL schemes",
          "createdAt": "2021-03-16T17:26:53Z",
          "updatedAt": "2021-03-16T17:26:53Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Are we making recommendations on the loopback address? localhost vs 127.0.0.1 vs ::1?",
          "createdAt": "2021-09-21T16:47:46Z",
          "updatedAt": "2021-09-21T16:47:46Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Rebased #30 to -> #98 . Once it's merged, you can close #30.",
          "createdAt": "2021-10-19T13:45:27Z",
          "updatedAt": "2021-10-19T13:45:27Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Done in #98 ",
          "createdAt": "2022-02-10T00:05:33Z",
          "updatedAt": "2022-02-10T00:05:33Z"
        }
      ]
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWU4MTk0ODYyNjI=",
      "title": "drop explicit requirement/mention of client_ids",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/41",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "client-definition-consolidation",
        "ietf-114"
      ],
      "body": "from Justin:\r\n\r\n---\r\n\r\n[\u00a72.2](https://tools.ietf.org/html/draft-ietf-oauth-v2-1-00#section-2.2): While it\u2019s usually the case that the AS issues the client_id, it\u2019s increasingly common in profiles of OAuth 2 for that to no longer be true. Ultimately, the AS needs to be able to :recognize: the client software identified by the client ID, and issuing an ID associated with some known set of policies (like which redirect URIs are allowed) is just one way to do it. We should be more precise in the definition and allow for the more general use cases that we already know are in the wild. Additionally, fixed client IDs are a thing, and so the restriction of it being unique to the AS is also untrue. Now allowing client_id choice is important mostly for registration-based clients, where the AS does issue the ID, and not for other cases where the AS \u201crecognizes\u201d and processes the client ID, like in OIDC\u2019s Federation profile and some other specs.",
      "createdAt": "2021-03-02T01:08:45Z",
      "updatedAt": "2022-07-21T02:05:27Z",
      "closedAt": "2022-07-16T00:32:35Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "uniqueness of the client_id within the AS's namespace is still required, however opening it up to externally managed client ids make sense. We also use such client ids.  ",
          "createdAt": "2021-03-02T13:38:49Z",
          "updatedAt": "2021-03-02T13:38:49Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "agreed ",
          "createdAt": "2021-03-15T23:44:53Z",
          "updatedAt": "2021-03-15T23:44:53Z"
        },
        {
          "author": "ybelenko",
          "authorAssociation": "NONE",
          "body": "I've used popular PHP server implementation which sets client ID required for all grants. Maybe my use case is wrong.\n\nCan somebody explain to me whether I should consider internal front web application as API client or not? It feels that way.\n\nI know that \"password\" grant has been deprecated and shouldn't be used, but what if I want to use it for private API only? I like token system so I don't wanna roll back to cookies and sessions.\n\nTo summarize my question, can I use OAuth flow at my front login page? And should I use it without client ID(extend password grant and make client_id optional) or I need to create static one(eg. \"website-front\").\n\n",
          "createdAt": "2021-04-16T15:24:19Z",
          "updatedAt": "2021-04-16T15:25:33Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "\n> To summarize my question, can I use OAuth flow at my front login page? And should I use it without client ID(extend password grant and make client_id optional) or I need to create static one(eg. \"website-front\").\n\n@ybelenko I'm not sure about your use case. The objective of an OAuth flow is to issue an access token for API access. How does this fit with your front login page?\n\n",
          "createdAt": "2021-05-01T09:05:39Z",
          "updatedAt": "2021-05-01T09:05:39Z"
        },
        {
          "author": "ybelenko",
          "authorAssociation": "NONE",
          "body": "@tlodderstedt Yes, I now that OAuth flow has been designed for API access. Since it's most stable and secure standard of authorization right now I don't want to reinvent the wheel or use cookie sessions which got many drawbacks. Anyway, many articles already describe this case:\r\n\r\nFrom [When to use the Password Grant Type | Okta Developer](https://developer.okta.com/blog/2018/06/29/what-is-the-oauth2-password-grant#when-to-use-the-password-grant-type)\r\n> While a service should never let a third party developer use the Password grant, it is quite reasonable for a service\u2019s own application to ask the user to enter their password. For example, if you download Twitter\u2019s mobile app, you wouldn\u2019t be surprised if the first thing it does when you launch is ask for your Twitter password. In contrast, if you download a third-party Gmail app, it should use Google\u2019s OAuth server rather than ask you to enter your Gmail password.\r\n>\r\n> The benefit of this grant type is that it lets the application take advantage of the rest of the benefits that OAuth provides around access tokens and token lifetimes. Instead of storing the user\u2019s password on the device, the application only has to touch the user\u2019s password for as long as it takes to get the access token, then it can store and use the access token instead.\r\n\r\nFrom [Password Grant - OAuth 2.0 Simplified](https://www.oauth.com/oauth2-servers/access-tokens/password-grant/): \r\n> A common use for this grant type is to enable password logins for your service\u2019s own apps. Users won\u2019t be surprised to log in to the service\u2019s website or native application using their username and password, but third-party apps should never be allowed to ask the user for their password.\r\n\r\nFrom [Resource Owner Password Credentials Grant | PHP OAuth2 Server ](https://oauth2.thephpleague.com/authorization-server/resource-owner-password-credentials-grant/):\r\n> This grant is a great user experience for <ins>trusted</ins> first party clients both on the web and in native applications.\r\n\r\nI consider my own front login page as <ins>trusted</ins> first party client. Talking about new 2.1 framework version, since password grant is deprecated and not recommended. I don't understand whether it's not recommended entirely or as part of public API? Can I turn it on for trusted apps while I don't describe that flow in public API documentation?",
          "createdAt": "2021-05-02T07:06:28Z",
          "updatedAt": "2021-05-02T07:06:28Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "@ybelenko I think what you are looking for is an internal API for password checks or you just use your OAuth AS as login server via OpenID Connect (code flow)",
          "createdAt": "2021-05-02T07:43:51Z",
          "updatedAt": "2021-05-02T07:43:51Z"
        },
        {
          "author": "ybelenko",
          "authorAssociation": "NONE",
          "body": "@tlodderstedt I've already implemented password grant for internal API. I'm just a user not an author of this spec, so I cannot understand why password grant has been deprecated and is this a big security vulnerability to still use it for internal API.\r\n\r\nAs long as I use password grant for internal API I can extend it anyway I want, including make client_id optional. client_id seems not really important/valuable for first party trusted apps.",
          "createdAt": "2021-05-02T08:01:33Z",
          "updatedAt": "2021-05-02T08:01:33Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This was updated in #123 ",
          "createdAt": "2022-07-16T00:32:35Z",
          "updatedAt": "2022-07-16T00:32:35Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU4MTk0ODk1MzA=",
      "title": "clarify \"unregistered client\"",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/42",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "editorial",
        "client-definition-consolidation",
        "ietf-114"
      ],
      "body": "from Justin:\r\n\r\n---\r\n\r\n[\u00a72.4](https://tools.ietf.org/html/draft-ietf-oauth-v2-1-00#section-2.4): We need to define what exactly an \u201cunregistered client\u201d is if we\u2019re going to refer to it here. I think rewriting of \u00a72.2 could help address a lot of this.\r\n",
      "createdAt": "2021-03-02T01:12:07Z",
      "updatedAt": "2022-07-21T02:05:19Z",
      "closedAt": "2022-07-16T00:23:53Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Suggested new text for 2.4\r\n\r\nThis specification does not require that clients be registered with the authorization server. However, the use of unregistered clients is beyond the scope of this specification and requires additional security analysis and review of its interoperability impact.\r\n\r\nI don't know what Justin's suggestion for 2.2 would entail or how it would resolve.",
          "createdAt": "2021-03-15T23:43:32Z",
          "updatedAt": "2021-03-15T23:43:32Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWU4MTk1MDg4MTA=",
      "title": "add a reference to CORS support on the token endpoint",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/43",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "editorial"
      ],
      "body": "If the AS expects to be used by SPA clients it will need to support the necessary CORS headers. I think the best place to mention this is https://tools.ietf.org/html/draft-ietf-oauth-v2-1-00#section-3.2",
      "createdAt": "2021-03-02T01:31:33Z",
      "updatedAt": "2022-10-24T22:33:03Z",
      "closedAt": "2022-10-24T22:33:02Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "Section 11 would be an alternative",
          "createdAt": "2021-03-02T13:36:03Z",
          "updatedAt": "2021-03-02T13:36:03Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree with adding a reference",
          "createdAt": "2021-03-15T23:39:22Z",
          "updatedAt": "2021-03-15T23:39:22Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU4MTk1MDk0ODU=",
      "title": "require scope in the access token response",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/44",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "from Justin:\r\n\r\n---\r\n\r\n[\u00a73.3](https://tools.ietf.org/html/draft-ietf-oauth-v2-1-00#section-3.3): Can we start to mandate or at least recommend that scope is always returned and not just when it differs? Yes this is a breaking change for the AS but it doesn\u2019t affect clients negatively, and it\u2019s similar in requirement to doing exact redirect URI matching which is already done in this spec that OAuth 2.0 didn\u2019t do.",
      "createdAt": "2021-03-02T01:32:17Z",
      "updatedAt": "2021-09-28T19:09:20Z",
      "closedAt": "2021-09-28T19:09:17Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I'm generally in favor of this, especially since a lot of ASs already behave this way anyway. I don't really see the benefit of allowing the AS to omit the scope values, and it's something I always have to explain to developers as a \"well you might or might not get back the scope value, who knows\"",
          "createdAt": "2021-03-02T01:33:15Z",
          "updatedAt": "2021-03-02T01:33:15Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "that makes things simpler, I'm in favor of it. And it is not a breaking change from a client's perspective. ",
          "createdAt": "2021-03-02T13:36:55Z",
          "updatedAt": "2021-03-02T13:36:55Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "+1",
          "createdAt": "2021-03-15T23:38:42Z",
          "updatedAt": "2021-03-15T23:38:42Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU4MjAwNDk1NzI=",
      "title": "Referencing OIDC implicit flows",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/45",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "Thanks as lot Vittorio! You gave us a lot of homework but I think the draft will be improved a lot based on it.\r\n \r\nRe OIDC implicit: I\u2018m reluctant to explicitly endorse use of OIDC implicit (response type \u201eid_token\u201c or \u201ecode id_token\u201c) as there are examples in the wild where the id_token is used as access token. Moreover, I\u2018m not aware of any systematic security threat analysis of those flows.\r\n \r\nI\u2018m fine with pointing out to readers that omission of response type \u201etoken\u201c does not deprecate other extension response types.\r\n \r\nWDYT?\r\n----\r\nThank you, I am so glad you think so!\r\n \r\nI hear you on the id_token abuse. That would be easily solved by appending a \u201cprovided that the resulting id_token is not abused by using it as access token\u201d, in fact that would explicitly address one of the most common abuses we witness in this space by finally providing explicit language on the matter. I had frequent clashes with the Kubernetes crowd about it, and they required nuanced arguments, making them grok the concept of audience etc etc- all stuff that could have been avoided by having straightforward language along the lines of the above. We could argue whether that language belongs to the OIDC spec more than the OAuth2.1: my position is that we should take this opportunity to bring extra clarity, nothing prevents repeating that if the OIDC people will do their own updates in the future.\r\nI also hear you on the open endorsement, however I suspect that just saying what you suggest without mentioning OIDC at all will not solve the problem of people thinking this deprecates those OIDC flows, too. Perhaps a compromise would make it explicit that the security considerations that led to the omission of implicit for the token response type in oauth2.1 do not apply to those flows in OIDC, provided that the id_token is not used as access token. So non an endorsement, but an explicit scoping statement \ud83d\ude0a would that sound more balanced?",
      "createdAt": "2021-03-02T14:04:08Z",
      "updatedAt": "2021-10-13T17:08:03Z",
      "closedAt": "2021-10-13T17:08:03Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "> I\u2018m fine with pointing out to readers that omission of response type \u201etoken\u201c does not deprecate other extension response types.\r\n\r\nBest place to add this is probably https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-03#section-6.4\r\n",
          "createdAt": "2021-09-28T19:07:07Z",
          "updatedAt": "2021-09-28T19:07:07Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "We got consensus in the interim meeting to add the proposed text.",
          "createdAt": "2021-10-13T17:07:57Z",
          "updatedAt": "2021-10-13T17:07:57Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU4MjAwNTM3NjU=",
      "title": "add iss authorisation response parameter",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/46",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "aaronpk"
      ],
      "labels": [
        "ietf-113",
        "ietf-114"
      ],
      "body": "The Security BCP is going to recommend the iss response parameter as mix-up defense. \r\n\r\nhttps://github.com/oauthstuff/draft-ietf-oauth-security-topics/pull/19/files\r\n\r\nI think we should consider to add this parameter to OAuth 2.1.",
      "createdAt": "2021-03-02T14:09:10Z",
      "updatedAt": "2022-07-21T00:41:10Z",
      "closedAt": "2022-07-21T00:40:24Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "At the interim meeting it was discussed to revisit this topic once the `iss` draft reaches RFC status.",
          "createdAt": "2021-10-13T19:23:23Z",
          "updatedAt": "2021-10-13T19:23:23Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "At IETF 113 it was agreed to fold in guidance on using the `iss` parameter by including an example in the spec and referencing RFC 9207 for the full details.\r\n\r\n[minutes](https://notes.ietf.org/notes-ietf-113-oauth#issue-46---iss-response-parameter)",
          "createdAt": "2022-03-22T10:58:18Z",
          "updatedAt": "2022-03-22T10:58:18Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWU4MjIwMzQ0MjA=",
      "title": "1.2.  Protocol Flow - figure 1 is misleading",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/48",
      "state": "OPEN",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "In a discussion with OAuth implementers the following issue was raised: \r\n\r\nThe first messages of the flow show that the client obtains the grant from the resource owner and passes it the AS. That might work for RO password grant but it does not work that way for code and other grant types.\r\nThe text on step 1 is resolving this issue by stating: \r\n\r\nThe client requests authorization from the resource owner.  The\r\n       authorization request can be made directly to the resource owner\r\n       (as shown), or preferably indirectly via the authorization server\r\n       as an intermediary.\r\n\r\nI would say with OAuth 2.1 the authorization is always captured by the AS. I suggest to modify figure and description accordingly. ",
      "createdAt": "2021-03-04T11:20:17Z",
      "updatedAt": "2022-06-29T00:03:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the diagram is correct in the steps as an abstract flow -- the descriptions of each step is confusing. I'm confused by what \"preferably indirectly via the authorization server as an intermediary.\" is to mean. ",
          "createdAt": "2021-03-15T23:38:05Z",
          "updatedAt": "2021-03-15T23:38:05Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Related: #26 ",
          "createdAt": "2022-06-29T00:02:59Z",
          "updatedAt": "2022-06-29T00:02:59Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU4MzIyODg4NDU=",
      "title": "Consider removing \"flow\" language",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/53",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "From Justin's feedback:\r\n\r\n> We should remove the \u201cflow\u201d based language throughout the document. This seems to have never quite gotten cleaned up previously.",
      "createdAt": "2021-03-15T23:52:56Z",
      "updatedAt": "2021-06-08T14:14:19Z",
      "closedAt": "2021-03-16T18:09:21Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "+1\r\n+1\r\n+1\r\n+1",
          "createdAt": "2021-03-16T16:33:55Z",
          "updatedAt": "2021-03-16T16:33:55Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "The only inconsistency in the draft was the use of \"client credentials flow\", which is now resolved in 67cb9989140460fed39a40f75a4aa4929f88fbd6. The rest of the use of \"flow\" is consistent now.",
          "createdAt": "2021-03-16T18:09:21Z",
          "updatedAt": "2021-03-16T18:09:21Z"
        }
      ]
    },
    {
      "number": 54,
      "id": "MDU6SXNzdWU4MzIyOTE2Njc=",
      "title": "Drop redirect_uri as a required parameter in the token request?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/54",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ietf-115"
      ],
      "body": "I believe the theory behind including the redirect_uri in the token request was to avoid some mixup attacks. However PKCE would solve that attack in a much more elegant way, which suggests that we don't need the redirect_uri in this request at all anymore. Would it make sense to drop this parameter from the request entirely? Or at least switch it to optional? (If there's some attack I'm not thinking of that this prevents please let me know!)",
      "createdAt": "2021-03-15T23:59:50Z",
      "updatedAt": "2023-07-10T19:43:42Z",
      "closedAt": "2023-07-10T19:43:41Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "+1\r\n\r\nThat's the conclusion of https://tools.ietf.org/html/draft-ietf-oauth-security-topics-09#section-3.5\r\n\r\n\"This document therefore recommends to instead bind every\r\n   authorization code to a certain client instance on a certain device\r\n   (or in a certain user agent) in the context of a certain transaction.\"",
          "createdAt": "2021-03-16T16:33:35Z",
          "updatedAt": "2021-03-16T16:33:35Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "What about non-PKCE scenarios?  Fine dropping it if it is now just security theater -- but not sure that is the always the case.",
          "createdAt": "2021-09-21T16:45:39Z",
          "updatedAt": "2021-09-21T16:45:39Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "It's not clear from the meeting minutes whether the decision was to drop this parameter from the request entirely or just make it more clear that it's optional in the token request. I *think* we agreed to drop it entirely as long as that is clearly documented in the \"changes from OAuth 2.0\" section",
          "createdAt": "2022-02-10T00:27:21Z",
          "updatedAt": "2022-02-10T00:27:21Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "We discussed this during the side meeting at IETF 114, and the resolution was to leave this as is. Currently the spec says the `redirect_uri` in the authorize request is only required if there are multiple registered, and it's only required in the token request if it was included in the authorize request. While some existing ASs may not be following these rules exactly, any change to the rules in either direction would cause more interop problems than it solves.",
          "createdAt": "2022-07-26T15:33:07Z",
          "updatedAt": "2022-07-26T15:33:07Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "The redirect URI does not serve any meaningful purpose in the token request. I therefore think it should be removed. \r\n\r\nIf we care about backward compatibility (which we don't at the authorization endpoint), we could make acceptance mandatory for ASs but sending the redirect URI optional for clients. ",
          "createdAt": "2022-07-26T16:00:10Z",
          "updatedAt": "2022-07-26T16:03:39Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "As discussed at IETF 115, we agreed to:\r\n\r\n* Remove the redirect_uri parameter from the token endpoint request\r\n* For backwards compatibility, note that ASs that support 2.0 clients will need to allow the redirect_uri parameter, and if provided, should also enforce it\r\n* Document in the \"Differences from OAuth 2.0\" section that an OAuth 2.1 client that doesn't send the redirect_uri will not work with an OAuth 2.0 server that expects it\r\n\r\nI also just realized, the breaking change isn't even as breaking as it was made out to be during the meeting. OAuth 2.0 only requires the redirect_uri in the token request *if* it was provided in the authorization request. So technically there are OAuth 2.0 ASs that currently don't require the redirect_uri parameter in all cases.\r\n",
          "createdAt": "2022-11-07T10:32:06Z",
          "updatedAt": "2022-11-07T10:32:06Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "It is not clear which (if any) 2.1 behaviour makes this change possible. AS implementers that want to support both 2.0, or 2.0 + BCP and 2.1 behaviours need to know exactly when its okay to drop the requirement to provide the parameter.\r\n\r\n> OAuth 2.0 only requires the redirect_uri in the token request if it was provided in the authorization request.\r\n\r\nI believe there to be only a handful of servers that support this optional behaviour.",
          "createdAt": "2022-11-08T17:07:20Z",
          "updatedAt": "2022-11-08T17:07:20Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "ASs should be following the current RFC6749 guidance and only requiring the redirect_uri parameter in the authorization request if more than one is registered, then following that, only require the redirect_uri parameter at the token endpoint if one was provided in the authorization request given the authorization code being used. If an AS has its own policy of requiring the redirect_uri all the time, then that is outside the scope of RFC6749, it's a decision the AS made that client developers would have to follow for that particular AS.\r\n\r\nSince this parameter is after issuing the authorization code to the client, the AS already knows which client this is, so it could have a mechanism for clients to opt in to all the 2.1 requirements, including this.\r\n\r\nSince there are many ASs that require the parameter all the time, many OAuth client library always include it. That behavior would still be allowed with the new text.\r\n\r\nOne comment I made at the end of this discussion at the meeting was that after we finish documenting the changes from OAuth 2.0 (#97), we should revisit this item. If it turns out this is the only change that breaks OAuth 2.1 clients from working with OAuth 2.0 servers, then we could roll this back. I suspect that won't be the case though.",
          "createdAt": "2022-11-08T17:37:51Z",
          "updatedAt": "2022-11-08T17:37:51Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "@panva the fact that PKCE is mandatory in 2.1 makes this change possible, as it effectively detects injection attempts (which was the main reason for including the _effective_ redirect URI in the token request in 2.0)",
          "createdAt": "2022-11-09T09:21:55Z",
          "updatedAt": "2022-11-09T09:21:55Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "Cheers @tlodderstedt. @aaronpk, I believe what Torsten noted above should make it to #97.",
          "createdAt": "2022-11-09T09:45:05Z",
          "updatedAt": "2022-11-09T09:45:05Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "MDU6SXNzdWU4MzIyOTM1ODk=",
      "title": "Clean up authorization code flow diagram",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/55",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "ietf-114"
      ],
      "body": "From Vittorio:\r\n\r\n> The first time I saw this diagram I found it confusing. The fact that the same numeral is assigned to multiple legs is just odd for anyone not already familiar with the flow, possibly still struggling to understand the client as a service side component.\r\n> Also, now that we have mighty SVG support, I would strongly advocate for a modern version of this diagram (there lines perhaps don\u2019t need to be broken into segments).",
      "createdAt": "2021-03-16T00:04:29Z",
      "updatedAt": "2022-07-21T01:50:41Z",
      "closedAt": "2022-07-16T00:19:49Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "+1",
          "createdAt": "2021-03-16T16:30:37Z",
          "updatedAt": "2021-03-16T16:30:37Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "```\r\n     +----------+\r\n     | Resource |\r\n     |   Owner  |\r\n     +----------+\r\n           ^\r\n           |\r\n           |\r\n     +-----|----+          Client Identifier      +---------------+\r\n     | .---+---------(A)-- & Redirection URI ---->|               |\r\n     | |   |    |                                 |               |\r\n     | |   '---------(B)-- User authenticates --->|               |\r\n     | | User-  |                                 | Authorization |\r\n     | | Agent  |                                 |     Server    |\r\n     | |        |                                 |               |\r\n     | |    .--------(C)-- Authorization Code ---<|               |\r\n     +-|----|---+                                 +---------------+\r\n       |    |                                         ^      v\r\n       |    |                                         |      |\r\n       ^    v                                         |      |\r\n     +---------+                                      |      |\r\n     |         |>---(D)-- Authorization Code ---------'      |\r\n     |  Client |          & Redirection URI                  |\r\n     |         |                                             |\r\n     |         |<---(E)----- Access Token -------------------'\r\n     +---------+       (w/ Optional Refresh Token)",
          "createdAt": "2022-07-15T19:49:19Z",
          "updatedAt": "2022-07-15T19:49:19Z"
        }
      ]
    },
    {
      "number": 56,
      "id": "MDU6SXNzdWU4MzIzNDAxMjc=",
      "title": "Restrictions on authorization code content",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/56",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "From Vittorio:\r\n\r\n> Should we say that the code should be opaque to the client, to discourage the use of structured code templates that can be partially manufactured?",
      "createdAt": "2021-03-16T02:02:14Z",
      "updatedAt": "2021-09-28T18:47:27Z",
      "closedAt": "2021-09-28T18:47:22Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I agree, but I am not sure the best way or place to say this.",
          "createdAt": "2021-03-16T02:04:05Z",
          "updatedAt": "2021-03-16T02:04:05Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "I suggest to add this to the definition of the code parameter (similar to access token opaqueness).",
          "createdAt": "2021-03-16T16:29:31Z",
          "updatedAt": "2021-03-16T16:29:31Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 ",
          "createdAt": "2021-09-28T17:52:19Z",
          "updatedAt": "2021-09-28T17:52:19Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWU4MzIzNDMwOTc=",
      "title": "Clarify extension grants",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/57",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "From Vittorio:\r\n\r\n> Section 4.3\r\n> We mentioned extension grants in passing, but I don\u2019t recall seeing a definition/description of their function in the context of the framework. Even a short sentence to that effect here would help, given that the section title names them explicitly. Also, stressing that the device flow is just one example and other extensions might differ (for example in their logic to establish whether an access token request is valid and authorized) would go a long way in helping the reader put this section in better focus.",
      "createdAt": "2021-03-16T02:09:45Z",
      "updatedAt": "2021-09-28T18:36:43Z",
      "closedAt": "2021-09-28T18:36:40Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 lets refactor the spec to make the extensibility a 1st class citizen",
          "createdAt": "2021-03-16T16:28:32Z",
          "updatedAt": "2021-03-16T16:28:32Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 ",
          "createdAt": "2021-09-28T17:51:59Z",
          "updatedAt": "2021-09-28T17:51:59Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Extension Grants in 4.4 next to the other grants makes this more clear now!\r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-03#section-4.4",
          "createdAt": "2021-09-28T18:36:37Z",
          "updatedAt": "2021-09-28T18:36:37Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWU4MzIzNTM1NjA=",
      "title": "Clarify differences in refresh token responses",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/58",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [
        "draft-00-feedback",
        "editorial"
      ],
      "body": "Section 5.1\r\n\r\nFrom Vittorio:\r\n\r\n> On the refresh_token parameter. The lack of details in how OAuth2 describes how/when an AS returns refresh tokens led to today\u2019s complicated situation in which many implementations issue RTs only when OIDC\u2019s offline_access is received in the scopes, as it was the only mention in public specs describing a concrete behavior. See the associated online_access discussion on the OIDC list, as RTs gain importance as session artifacts of sort for SPAs now that implicit is dead and ITP makes iframe renewals problematic.\r\n> Unfortunately it is too late to be prescriptive here, as we cannot break compatibility with whatever choices existing AS implementations made. However we can be more descriptive and give the reader a better idea of what\u2019s the range of possibilities. Some nonnormative examples of how existing AS determine whether to issue an RT or not (eg as an option determined at client registration time, or any other heuristic you guys encountered in the wild) might help people to better understand their options and the intent of the specification here.\r\n",
      "createdAt": "2021-03-16T02:35:37Z",
      "updatedAt": "2024-01-31T15:11:00Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "We should consider to make support for refresh tokens a MUST on the client side. This would allow ASs to issue RTs if needed (either always or based on policy).\r\n\r\nSome text on what policies ASs might use would be good as well. ",
          "createdAt": "2021-03-16T16:27:28Z",
          "updatedAt": "2021-03-16T16:27:28Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Why would the client MUST support a RT if it does not use / need one? ",
          "createdAt": "2021-09-28T17:51:33Z",
          "updatedAt": "2021-09-28T17:51:33Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "The text in 5.1 is now in 3.2.3 https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-03#section-3.2.3",
          "createdAt": "2021-09-28T18:35:27Z",
          "updatedAt": "2021-09-28T18:35:27Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "We'll add a new Security Considerations section for refresh tokens and describe more detail the things mentioned in this paragraph:\r\n\r\n> Issuing a refresh token is optional at the discretion of the authorization server, and may be issued based on properties of the client, properties of the request, policies within the authorization server, or any other criteria",
          "createdAt": "2023-07-27T15:29:33Z",
          "updatedAt": "2023-07-27T15:29:33Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWU4MzIzNTQzMTU=",
      "title": "Clarify limits and caveats on access token formats",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/59",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "tlodderstedt"
      ],
      "labels": [
        "draft-00-feedback",
        "editorial"
      ],
      "body": "Section 5.1\r\n\r\nFrom Vittorio\r\n\r\n> On the access_token parameter. Given the discussions we had for the JWT AT profile draft, I am wondering whether it should be called out here that the AT recipient is the RS, that the client should not expect to be able to parse the access_token, and that the AS is under no obligation to use a consistent AT encoding outside of what is negotiated with the RS. I don\u2019t feel very strongly about this, or about where in the spec this should be called out, but it sure would have made life easier in those discussions- hence the comment.",
      "createdAt": "2021-03-16T02:37:36Z",
      "updatedAt": "2024-01-09T22:48:46Z",
      "closedAt": "2024-01-09T22:48:46Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I agree, but I would like to think further on where the best place for this description is.",
          "createdAt": "2021-03-16T02:37:44Z",
          "updatedAt": "2021-03-16T02:37:44Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think 5.1 is the best place as the parameter is defined there. ",
          "createdAt": "2021-03-16T16:24:37Z",
          "updatedAt": "2021-03-16T16:24:37Z"
        }
      ]
    },
    {
      "number": 60,
      "id": "MDU6SXNzdWU4MzIzNTQ2MDM=",
      "title": "Access token error response",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/60",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "editorial"
      ],
      "body": "Section 5.2\r\n\r\nfrom Vittorio:\r\n\r\n> It might help to remind the reader here that extensions to the core spec might specify or further specialize circumstances in which the errors mentioned here are returned (for example, see the validation errors in the JWT AT profile). There\u2019s a mention of that in \u00a77.3.1 but that\u2019s pretty far, and having even brief language here might be handy for people reading the spec for reference rather than cover to cover.\r\n",
      "createdAt": "2021-03-16T02:38:24Z",
      "updatedAt": "2023-07-27T15:49:59Z",
      "closedAt": "2023-07-27T15:49:56Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "+1",
          "createdAt": "2021-03-16T16:21:37Z",
          "updatedAt": "2021-03-16T16:21:37Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "MDU6SXNzdWU4MzIzNTgzMjE=",
      "title": "Move refresh token section into the section with the other grants",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/61",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "tlodderstedt"
      ],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "from Vittorio:\r\n\r\n> \u00a76: I wonder if now we should move this back to a \u201cgrant\u201d type in \u00a74. It originally was but the editor moved it out to its own section, but I have found that it confuses developers who are looking for it to have it on its own. Semantically it\u2019s a grant (process to get an access token), but it feels like something \u201cspecial\u201d where it isn\u2019t really.\r\n",
      "createdAt": "2021-03-16T02:48:02Z",
      "updatedAt": "2021-06-08T14:13:26Z",
      "closedAt": "2021-06-08T14:08:01Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I'm on the fence about this. Right now section 4 is about \"obtaining authorization\", so the refresh token grant doesn't really fit there. That said, there is a certain elegance in having all of the requests to the token endpoint described in the same section.",
          "createdAt": "2021-03-16T02:48:48Z",
          "updatedAt": "2021-03-16T02:48:48Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "I fully agree with Vittorio. The spec currently is organized by use case, which results in the definition of the token endpoint scattered across sections 3-6 and even missing a clear request & response definition. \r\nI think the better way would be to have a base definition, which includes request base parameters (grant_type), client authentication, token response, token error response and so on and additional sections covering code, client credentials and refresh token. \r\nWe could even consider to put authz code in a separate section covering the authorisation endpoint as well. That would be a reasonable blueprint for extension grant types, e.g. assertion, device or CIBA.\r\n\r\nSomething like this: \r\n\r\nX. token endpoint\r\nX+1 client credentials grant type\r\nX+2 authorization code grant type\r\nX+3 refresh token grant type\r\n",
          "createdAt": "2021-03-16T16:20:54Z",
          "updatedAt": "2021-03-16T16:23:20Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Done in #78",
          "createdAt": "2021-06-08T14:08:01Z",
          "updatedAt": "2021-06-08T14:08:07Z"
        }
      ]
    },
    {
      "number": 62,
      "id": "MDU6SXNzdWU4MzIzNjQxMjg=",
      "title": "Clarify limits on new access tokens issued from refresh tokens",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/62",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "from Vittorio:\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-oauth-v2-1-00#section-6\r\n\r\n> We might need to be more precise here. Do we mean the scopes consented by the RO in the request that led to the issuance of the RT being used? Just saying consented by the RO for the client does not exclude cases in which there are more instances of the client in operation. Say that I am running uber on phone 1 and I consent to read my google calendar, getting AT1 and RT1. Say that on phone 2 I also run the uber app, and this time I consent to write my google calendar, obtaining AT2 and RT2 on this new device. Now consider the various combinations here. Should RT2 allow me to get calendar:read too, given that it was already consented by RO for this client? Should RT1 allow me to get AT1\u2019 containing calendar:write, given that RO consented for it when using a different instance of the same client? Whatever is the answer you want to the questions above, I think the spec should have language clear enough to unambiguously determine the desired behavior.\r\n",
      "createdAt": "2021-03-16T03:03:00Z",
      "updatedAt": "2024-01-31T15:11:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This is from the Security BCP, and I generally agree with this. I remember seeing somewhere a better description of limiting the access tokens to the same scope/permissions/privileges/etc as the original, but I can't seem to find it now.",
          "createdAt": "2021-03-16T03:03:34Z",
          "updatedAt": "2021-03-16T03:03:34Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "What part of the Security BCP are you referring to? I'm only aware of https://tools.ietf.org/html/draft-ietf-oauth-security-topics-09#section-2.3, which refers to access tokens. \r\n\r\nIn my opinion the meaning of the text in OAuth 2.1. should be \"refresh tokens shall always have a clear scope\". In the end this requires the AS to tie the RT to a certain user approved grant (and its scope) (3rd parties) or a certain policy (1st parties).\r\n\r\nI would consider this best practice and suggest to adopt the wording along these + move this to the security considerations.",
          "createdAt": "2021-03-16T16:13:46Z",
          "updatedAt": "2021-03-16T16:13:46Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "We'll call out that the scope authorized in subsequent flows being either what was just asked for or includes scopes that were previously authorized to that client ID is dependent on AS policies. This will the new scope section #159",
          "createdAt": "2023-07-27T15:57:31Z",
          "updatedAt": "2023-07-27T15:57:31Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWU4MzIzNjg0MTM=",
      "title": "How to handle refresh token requests when the RO revokes specific scopes?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/63",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "editorial"
      ],
      "body": "from Vittorio:\r\n\r\n> On the identical scopes requirement. Say that after obtaining RT1, which includes scopes s1 and s2 for client c1, the RO revokes authorization for c1 to use s2. Should the AS fail the RT redemption, or return an AT with only s1 and a scopes parameter informing the client of the change? As developer I would prefer the latter, to preserve the experience: but if we are adamant about the current language, I think it might be useful to explicitly call out that any changes to the grant on the AS side should result in failure of the RT redemption.\r\n",
      "createdAt": "2021-03-16T03:13:39Z",
      "updatedAt": "2024-01-31T15:11:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm in favor of retaining the RT but reduce its scope. The token response shall return the adjusted scope value. \r\n\r\nI don't see a value in revoking the RT in this case. This would force the RO to go through the authorization process again. If that's the intended behaviour, the AS should directly revoke the grant and the RT(s) instead of modifying the scope of the grant, which in turn causes a RT revocation .... \r\n\r\nI also suggest to change section 5.1. to require the scope response parameter. ",
          "createdAt": "2021-03-16T16:05:38Z",
          "updatedAt": "2021-03-16T16:05:38Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "The refresh token grant response now more clearly extends the base access token response with the refactoring of the grants into the new structure, so `scope` is more obviously listed as a possible property in the response to a refresh token grant.\r\n\r\nOne thing it could be useful to clarify is that if the AS does return an access token with less scopes, then it should return the scope parameter in the response. I believe this is already technically required, but not explicitly spelled out. Currently the AS MUST return the scope in the response if it's different from what the client requests. If the client doesn't include a scope parameter in the request, then the client is implicitly requesting the same scope as the previous refresh token has, so if the AS returns an access token with less scope that would be considered less than the client requested.",
          "createdAt": "2022-03-19T17:57:37Z",
          "updatedAt": "2022-03-19T17:57:37Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This also goes in the new scope section (#159), and we can call out several different situations by which the token issued may have different scopes than what was requested: both different from the scopes in the authorization request as well as different from the scopes in a refresh token request. (If the RO revokes a particular scope, then the refresh token previously issued will have different scopes than the new access token returned, so the \"scope\" parameter will be required in the token response.)",
          "createdAt": "2023-07-27T16:00:55Z",
          "updatedAt": "2023-07-27T16:00:55Z"
        }
      ]
    },
    {
      "number": 64,
      "id": "MDU6SXNzdWU4MzMwNTMxNTk=",
      "title": "Move normative text from security considerations inline in the doc",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/64",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "Security considerations should be reserved for implementation details ",
      "createdAt": "2021-03-16T17:44:35Z",
      "updatedAt": "2021-10-19T10:39:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Moreover, the Summary of recommendations should not duplicate mandatory text. I'd replace it with a table referencing the actual spec sections.",
          "createdAt": "2021-10-19T10:39:13Z",
          "updatedAt": "2021-10-19T10:39:13Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU4MzMwNTQyNjU=",
      "title": "single use authorization code",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/65",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tlodderstedt"
      ],
      "labels": [
        "interim"
      ],
      "body": "\"Authorization codes MUST be short lived and single-use.\"\r\nCan we relax the requirement given PKCE is used to detect replay?",
      "createdAt": "2021-03-16T17:46:07Z",
      "updatedAt": "2023-09-16T21:01:03Z",
      "closedAt": "2022-02-10T00:17:12Z",
      "comments": [
        {
          "author": "danielfett",
          "authorAssociation": "MEMBER",
          "body": "The single-use limitation makes all attacks harder to execute where an attacker has the ability to read the authorization response: With this limitation, just reading a response (e.g., attacker with access to log files) is not sufficient. Instead, the attacker has to stop the legitimate response from reaching its destination OR the attacker has to be quicker than the victim. \r\n\r\nEven with PKCE, this limitation has not lost its importance.",
          "createdAt": "2021-03-22T14:28:37Z",
          "updatedAt": "2021-03-22T14:28:37Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "How is the attacker supposed to circumvent PKCE protection with the data from the authorisation response?",
          "createdAt": "2021-03-22T15:14:22Z",
          "updatedAt": "2021-03-22T15:14:22Z"
        },
        {
          "author": "danielfett",
          "authorAssociation": "MEMBER",
          "body": "Maybe the attacker has chosen/replayed the PKCE challenge or the attacker is able to read the token request.",
          "createdAt": "2021-03-22T16:00:22Z",
          "updatedAt": "2021-03-22T16:00:22Z"
        },
        {
          "author": "jricher",
          "authorAssociation": "NONE",
          "body": "It would be beneficial to be clearer in how we define \"single use\" to make it clear what the intended implementation is. Most implementations are \"burn on first use\" for the authz code, but do we mean for it to be remembered on replay for some limited amount of time? The intent is clearly not to remember all authz codes forever to prevent replay.",
          "createdAt": "2021-03-22T16:21:20Z",
          "updatedAt": "2021-03-22T16:21:20Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I believe the discussion on the list concluded with keeping the existing language requiring single-use authorization codes.",
          "createdAt": "2022-02-10T00:11:24Z",
          "updatedAt": "2022-02-10T00:11:24Z"
        },
        {
          "author": "wparad",
          "authorAssociation": "NONE",
          "body": "I almost would like to reopen this, I believe there was some discussion around non-PKCE that just has to do with intermittent failures while either receiving the authorization code response OR handling the response. In so for as much to say, that forcing a client to completely restart the whole authentication request when a request to exchange the authorization code fails due to a connection problem is a lot to request.\r\n\r\nAlso the real problem is that some AS have taken it upon themselves to have the code exchange do more than generate a token. One actual implementation we ran into a problem with is Slack.\r\n\r\nSlack is using the OAuth credentialed client authorization code flow to install apps. When the authorization code flow is completed for the app, the result is an access token returned to the client, and the app installed from Slack's standpoint.\r\n\r\nHowever, if there is an error with connection or with the handling of the authorization code, now there is an inconsistent state. The **app** is considered **installed**, but the client doesn't have a valid token. And because of this, the flow that existed before to **start the installation process** no longer exists. The client could not retry the authorization code request, and throwing an error back to the user is also not possible.\r\n\r\nAssuming we left the language alone, there are two counterarguments:\r\n1. You could attempt a retry by sending the client back to the AS and asking for a new authorization code.\r\nThe problem here is that many AS will actually block this request since the **state**, **nonce**, or whatever else you asked for is the same. As in an authorization code was already requested and generated. So returning the user back to the AS isn't possible as a complete solution, nor can the client know that is the right place to send the user.\r\n\r\n2. You could attempt to retry by sending the client back to the starting point and asking the user to start a new flow. \r\nThis amounts to starting all over again. And as I mentioned above since **state** of the system is now different because the AS changed how it regards users and clients (which isn't forbidden in the OAuth spec) starting the flow over again is not possible because from the user and AS standpoint, the flow was already completed.",
          "createdAt": "2023-09-15T09:11:53Z",
          "updatedAt": "2023-09-15T09:11:53Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Warren: why would the issue Slack has not be considered an implementation\r\nerror by Slack?\r\n\u1427\r\n\r\nOn Fri, Sep 15, 2023 at 2:12\u202fAM Warren Parad ***@***.***>\r\nwrote:\r\n\r\n> I almost would like to reopen this, I believe there was some discussion\r\n> around non-PKCE that just has to do with intermittent failures while either\r\n> receiving the authorization code response OR handling the response. In so\r\n> for as much to say, that forcing a client to completely restart the whole\r\n> authentication request when a request to exchange the authorization code\r\n> fails due to a connection problem is a lot to request.\r\n>\r\n> Also the real problem is that some AS have taken it upon themselves to\r\n> have the code exchange do more than generate a token. One actual\r\n> implementation we ran into a problem with is Slack.\r\n>\r\n> Slack is using the OAuth credentialed client authorization code flow to\r\n> install apps. When the authorization code flow is completed for the app,\r\n> the result is an access token returned to the client, and the app installed\r\n> from Slack's standpoint.\r\n>\r\n> However, if there is an error with connection or with the handling of the\r\n> authorization code, now there is an inconsistent state. The *app* is\r\n> considered *installed*, but the client doesn't have a valid token. And\r\n> because of this, the flow that existed before to *start the installation\r\n> process* no longer exists. The client could not retry the authorization\r\n> code request, and throwing an error back to the user is also not possible.\r\n>\r\n> Assuming we left the language alone, there are two counterarguments:\r\n>\r\n>    1.\r\n>\r\n>    You could attempt a retry by sending the client back to the AS and\r\n>    asking for a new authorization code.\r\n>    The problem here is that many AS will actually block this request\r\n>    since the *state*, *nonce*, or whatever else you asked for is the\r\n>    same. As in an authorization code was already requested and generated. So\r\n>    returning the user back to the AS isn't possible as a complete solution,\r\n>    nor can the client know that is the right place to send the user.\r\n>    2.\r\n>\r\n>    You could attempt to retry by sending the client back to the starting\r\n>    point and asking the user to start a new flow.\r\n>    This amounts to starting all over again. And as I mentioned above\r\n>    since *state* of the system is now different because the AS changed\r\n>    how it regards users and clients (which isn't forbidden in the OAuth spec)\r\n>    starting the flow over again is not possible because from the user and AS\r\n>    standpoint, the flow was already completed.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/oauth-wg/oauth-v2-1/issues/65#issuecomment-1720943041>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAFIGVWHYC4YI36FPTUBGTDX2QLWJANCNFSM4ZJAUQPA>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2023-09-15T17:23:51Z",
          "updatedAt": "2023-09-15T17:23:51Z"
        },
        {
          "author": "wparad",
          "authorAssociation": "NONE",
          "body": "> Warren: why would the issue Slack has not be considered an implementation error by Slack? \u1427\r\n\r\nFor sure 100% it is. The point is that Providers will make these mistakes, so I'm wondering what's the best way to prevent them from doing so. Sure we can't guarantee no mistakes in implementation would be made. For instance, it could be said here, \"authorization code exchange must not impact the state of the system\". But what is that language, and will that work? The question for me becomes, does encouraging code reuse during an even smaller than the validity window offer an improvement?\r\n\r\nI do recall there was a conversation from the WG emails from microsoft about the technical issues with actually implementing a solution that durable without allowing a short interval where retries are allowed.",
          "createdAt": "2023-09-16T13:21:00Z",
          "updatedAt": "2023-09-16T13:21:00Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm confused how your suggestion resolves the Slack implementation error.\r\n\r\nI don't think vague as you suggest is helpful. Crisp guidance is much\r\neasier to implement.\r\n\r\nAn implementation can decide to not follow the spec and allow code reuse if\r\nthey think that is better for their use case. The security considerations\r\nshould explain the concerns with code reuse if not already covered.\r\n\r\n\u1427\r\n\r\nOn Sat, Sep 16, 2023 at 6:21\u202fAM Warren Parad ***@***.***>\r\nwrote:\r\n\r\n> Warren: why would the issue Slack has not be considered an implementation\r\n> error by Slack? \u1427\r\n>\r\n> For sure 100% it is. The point is that Providers will make these mistakes,\r\n> so I'm wondering what's the best way to prevent them from doing so. Sure we\r\n> can't guarantee no mistakes in implementation would be made. For instance,\r\n> it could be said here, \"authorization code exchange must not impact the\r\n> state of the system\". But what is that language, and will that work? The\r\n> question for me becomes, does encouraging code reuse during an even smaller\r\n> than the validity window offer an improvement?\r\n>\r\n> I do recall there was a conversation from the WG emails from microsoft\r\n> about the technical issues with actually implementing a solution that\r\n> durable without allowing a short interval where retries are allowed.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/oauth-wg/oauth-v2-1/issues/65#issuecomment-1722229169>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAFIGVT5C47EBVJQG577NQ3X2WRUPANCNFSM4ZJAUQPA>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2023-09-16T20:40:02Z",
          "updatedAt": "2023-09-16T20:40:02Z"
        },
        {
          "author": "wparad",
          "authorAssociation": "NONE",
          "body": "Well I don't think we should be vague at all, the starter question is, since providers are getting this wrong, is the advice that Auth Codes must not be reused the right one? Or if we suggest that the current language is indeed still the right one, should we potentially include further explanation about the expectations for how auth code exchanges should be treated by an authorization server?",
          "createdAt": "2023-09-16T20:43:33Z",
          "updatedAt": "2023-09-16T20:43:33Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "The Slack IdP got it right. Another part of the Slack\r\ninfrastructure decided that the process was complete before it actually was\r\ncomplete. I don't see that as an OAuth issue.\r\n\r\nI believe the one time use motivation is security related. An attacker that\r\nexfiltrates a code can't use it if it has already been used, and if it has\r\nalready been used, the user would restart the whole process to get a new\r\ncode and then access token, and the IdP could invalidate the previous\r\naccess token.\r\n\r\nPerhaps I am not understanding what you problem you are wanting to solve?\r\n\r\n\u1427\r\n\r\nOn Sat, Sep 16, 2023 at 1:43\u202fPM Warren Parad ***@***.***>\r\nwrote:\r\n\r\n> Well I don't think we should be vague at all, the starter question is,\r\n> since providers are getting this wrong, is the advice that Auth Codes must\r\n> not be reused the right one? Or if we suggest that the current language is\r\n> indeed still the right one, should we potentially include further\r\n> explanation about the expectations for how auth code exchanges should be\r\n> treated by an authorization server?\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/oauth-wg/oauth-v2-1/issues/65#issuecomment-1722312518>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAFIGVVDR4L2BVD5NALLUI3X2YFQDANCNFSM4ZJAUQPA>\r\n> .\r\n> You are receiving this because you commented.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2023-09-16T20:52:46Z",
          "updatedAt": "2023-09-16T20:52:46Z"
        },
        {
          "author": "wparad",
          "authorAssociation": "NONE",
          "body": "Funny enough:\r\n> IdP could invalidate the previous access token.\r\n\r\nEvery time the auth code exchange completes, the same access token is generated. So the same user or a different user completing the exchange, you still get the exact same access token.\r\n\r\nThe problem as I see it, is that the auth code exchange causes other things to happen. Since the AS can't know that the client didn't correctly receive the access token, the AS taking actions as if it can know is a mistake. In this case, Slack does take additional actions with the assumption that once it has returned the access token the client definitely has it. Those actions it takes are for the most part irreversible and navigate a state machine in a direction that requires that the client has received the access token.\r\n\r\nHowever, since the AS can't know that the client has it or doesn't have it, the assumption that it does is a mistake. And in the case where the client hasn't been able to persist it for some reason, there is little that the client can do here. I'm wishing there were some way to convince IdPs to not make assumptions about the persistence of an access token based on the auth code exchange result.\r\n\r\nTangentially, my standpoint is, as you put it, OAuth should not be used here, or at least OAuth returning an access token should not be used here. But it is being used, and my point is that it is being used badly. I don't think this is the first time I have seen this, so I'm pondering if there was something we could do help avoid cases like this. But I think it is a pipedream.",
          "createdAt": "2023-09-16T21:01:03Z",
          "updatedAt": "2023-09-16T21:01:03Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWU4MzMzNzc3NjU=",
      "title": "Incorporate changes for Errata ID 3446",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/68",
      "state": "CLOSED",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.rfc-editor.org/errata/eid3446\r\n\r\n> Section 1 says:\r\n> \r\n> o  Resource owners cannot revoke access to an individual third party\r\n>    without revoking access to all third parties, and must do so by\r\n>    changing the third party's password.\r\n> It should say:\r\n> \r\n> o  Resource owners cannot revoke access to an individual third party\r\n>    without revoking access to all third parties, and must do so by\r\n>    changing their password.\r\n> Notes:\r\n> \r\n> The text was originally \"their\" but changed to \"the third party's\" between the last draft and RFC.\r\n> However, \"their\" means \"resource owners'\", not \"the third party's\".",
      "createdAt": "2021-03-17T03:58:23Z",
      "updatedAt": "2021-06-08T14:12:54Z",
      "closedAt": "2021-03-19T21:51:27Z",
      "comments": [
        {
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/aaronpk/oauth-v2-1/pull/66",
          "createdAt": "2021-03-17T04:05:03Z",
          "updatedAt": "2021-03-17T04:05:03Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "closed in #66 ",
          "createdAt": "2021-03-19T21:51:27Z",
          "updatedAt": "2021-03-19T21:51:27Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU4MzMzNzk5NjE=",
      "title": "Incorporate changes for Errata ID 5793",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/69",
      "state": "CLOSED",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://www.rfc-editor.org/errata/eid5793\r\n\r\n> Section 2.3.1 says:\r\n> \r\n>    Alternatively, the authorization server MAY support including the\r\n>    client credentials in the request-body using the following\r\n>    parameters:\r\n> It should say:\r\n> \r\n>    In addition to that, the authorization server MAY support including\r\n>    the client credentials in the request-body using the following\r\n>    parameters:\r\n> Notes:\r\n> \r\n> Given that the authorization MUST support the HTTP Basic authentication scheme in the paragraphs just before this one, using the word \"alternatively\" here can be understood as \"instead of\", which is not the intention and can lead to confusion for implementors.\r\n> \r\n> This intention is further highlighted by the use of the word MAY in the paragraph above.",
      "createdAt": "2021-03-17T04:04:22Z",
      "updatedAt": "2021-06-08T14:12:21Z",
      "closedAt": "2021-03-19T21:51:08Z",
      "comments": [
        {
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/aaronpk/oauth-v2-1/pull/67",
          "createdAt": "2021-03-17T04:05:26Z",
          "updatedAt": "2021-03-17T04:05:26Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "MDU6SXNzdWU4MzY0MjQ3ODQ=",
      "title": "Incorporate editorial feedback from Justin and Vittorio's reviews",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/70",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [
        "editorial"
      ],
      "body": "Sections 7-13 are remaining\r\n\r\n* Vittorio: https://mailarchive.ietf.org/arch/msg/oauth/RP71xU8P4WLLIx0NcQMnw4gHScQ/\r\n* Justin: https://mailarchive.ietf.org/arch/msg/oauth/Ex2eSkHBAKnmP0cFIyzEywLzeDk/\r\n",
      "createdAt": "2021-03-19T22:32:15Z",
      "updatedAt": "2022-03-19T17:46:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Section 7 is done, either changes made or issues filed.",
          "createdAt": "2021-09-08T02:56:34Z",
          "updatedAt": "2021-09-08T02:56:34Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "MDU6SXNzdWU4Mzc0NDAyNDU=",
      "title": "Editorial improvements",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/71",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## I expect\r\n\r\nSome editorial improvements\r\n\r\n- [x] definition of user agent (`user-agent` is an abnf syntax)",
      "createdAt": "2021-03-22T08:03:49Z",
      "updatedAt": "2021-06-08T14:17:13Z",
      "closedAt": "2021-06-08T14:17:13Z",
      "comments": []
    },
    {
      "number": 76,
      "id": "MDU6SXNzdWU4NDk3NTg1NDc=",
      "title": "Potential new Security Consideration - Malicious Clients (Consent Phishing)",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/76",
      "state": "OPEN",
      "author": "mpeck12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Potential new Security Consideration - Malicious Clients, Consent Phishing, or other appropriate term:\r\n\r\nAs service providers adopt stronger user authentication methods, attackers seek additional means to gain access to resources. An attacker may attempt to register an attacker-controlled client with the authorization server, then attempt to trick resource owners into granting the client access to resources through a phishing attack [1][2][3][4]. The access request may not appear malicious to the user as it originates from the legitimate authorization server.\r\n\r\nAuthorization servers should enforce controls over client registration, as well as controls over the scopes that particular clients are allowed to request. Authorization servers should also allow administrators and/or users to view a list of clients that have been granted access to resources and provide the ability to revoke access.\r\n\r\n[1] https://www.trendmicro.com/en_us/research/17/d/pawn-storm-abuses-open-authentication-advanced-social-engineering-attacks.html\r\n[2] https://www.proofpoint.com/us/blog/threat-insight/ta2552-uses-oauth-access-token-phishing-exploit-read-only-risks\r\n[3] https://www.microsoft.com/security/blog/2020/07/08/protecting-remote-workforce-application-attacks-consent-phishing/\r\n[4] https://security.googleblog.com/2017/05/protecting-you-against-phishing.html\r\n",
      "createdAt": "2021-04-03T23:20:09Z",
      "updatedAt": "2021-04-03T23:20:09Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 77,
      "id": "MDU6SXNzdWU4NTE4MDAxMzQ=",
      "title": "Prohibit sending access token as URI query parameter?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/77",
      "state": "CLOSED",
      "author": "mpeck12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "RFC 6750 section 2.3 recommends against clients sending access tokens to resource servers as a URI query parameter.\r\n\r\nWould it make sense to explicitly disallow this practice in OAuth 2.1 section 7.2?\r\n(Currently as far as I can tell, OAuth 2.1 just doesn't define the query parameter approach)\r\n",
      "createdAt": "2021-04-06T20:50:16Z",
      "updatedAt": "2021-09-22T20:05:40Z",
      "closedAt": "2021-09-22T18:22:39Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "agree on MUST NOT send as URI query parameter",
          "createdAt": "2021-09-21T16:39:43Z",
          "updatedAt": "2021-09-21T16:39:43Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWU5MDE1MjM2NjA=",
      "title": "Require authorization endpoint to be accessible by the user agent",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/79",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See this thread for context:\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/oauth/I9v_RvsGDHbfIpqwnH4vLXlTCls/\r\n\r\nCould be worded to either require the authorization endpoint be \"publicly accessible\" (for whatever \"public\" means tho that might be tricky), or to be accessible by the user agent with no other form of authentication needed, or specifically prohibit known lists of things like MTLS.",
      "createdAt": "2021-05-25T23:48:59Z",
      "updatedAt": "2021-09-28T18:31:25Z",
      "closedAt": "2021-09-28T18:31:25Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Unclear why we would prohibit MTLS. The browser could be using MTLS to with the authorization endpoint.",
          "createdAt": "2021-09-28T17:50:12Z",
          "updatedAt": "2021-09-28T17:50:12Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWU5MTgxOTIyMzY=",
      "title": "Use iss+sub, not just sub, to identify resource owner",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/80",
      "state": "CLOSED",
      "author": "manger",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The \"Client Impersonating Resource Owner\" section in \"Security Considerations\" says:\r\n\r\n> \"Resource servers may make access control decisions based on the identity of the resource owner as communicated in the sub claim\"\r\n\r\nHowever, the \"sub\" may only be \"scoped to be locally unique in the context of the issuer\" [RFC7519 JWT section 4.1.2 \"sub\" (Subject) claim]. So the identity of the resource owner is communicated by the combination of the \"sub\" and \"iss\" claims.\r\n",
      "createdAt": "2021-06-11T04:00:40Z",
      "updatedAt": "2021-09-21T19:04:03Z",
      "closedAt": "2021-09-21T19:03:58Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps I am missing something, but iss+sub looks like what it should be\r\n\r\nFWIW: I've always been miffed that `sub` was not defined to be globally unique\r\n",
          "createdAt": "2021-09-21T16:39:10Z",
          "updatedAt": "2021-09-21T16:39:10Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "agree",
          "createdAt": "2021-09-21T16:42:10Z",
          "updatedAt": "2021-09-21T16:42:10Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "9.6 addresses conflation of client_id and sub => not identity of the resource owner",
          "createdAt": "2021-09-21T19:03:38Z",
          "updatedAt": "2021-09-21T19:03:38Z"
        }
      ]
    },
    {
      "number": 81,
      "id": "MDU6SXNzdWU5MTk2MjI1MDQ=",
      "title": "Make sure TLS 1.0 and 1.1 are not referenced",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/81",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "RFC8996 deprecates TLS 1.0 and 1.1 and is marked as updating OAuth 2.0 core \r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc8996",
      "createdAt": "2021-06-12T17:39:51Z",
      "updatedAt": "2021-09-08T19:59:08Z",
      "closedAt": "2021-09-08T19:59:03Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "All references have been replaced",
          "createdAt": "2021-09-08T19:59:03Z",
          "updatedAt": "2021-09-08T19:59:03Z"
        }
      ]
    },
    {
      "number": 82,
      "id": "MDU6SXNzdWU5MTk2MjM0ODM=",
      "title": "Clarify what should happen to authorization codes on an error response",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/82",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "If there was a problem with the token request that otherwise contained a valid authorization code, clarify whether the authorization code should remain valid or should be treated as if it had been used successfully.",
      "createdAt": "2021-06-12T17:44:09Z",
      "updatedAt": "2024-01-09T23:39:22Z",
      "closedAt": "2024-01-09T23:39:22Z",
      "comments": [
        {
          "author": "Zegnat",
          "authorAssociation": "NONE",
          "body": "From the current [OAuth RFC 6749 \u00a7 10.5 Authorization Codes](https://datatracker.ietf.org/doc/html/rfc6749#section-10.5), emphasis mine:\r\n\r\n> Authorization codes MUST be short lived and single-use. If the authorization server **observes multiple attempts to exchange** an authorization code for an access token, the authorization server SHOULD attempt to revoke all access tokens already granted based on the compromised authorization code.\r\n\r\nI always read this to mean that any attempt to exchange, whether failing or not, counts as a use. As soon as the token endpoint sees any request coming in with the authorization code, the code can be marked as having had its single use, no matter what the endpoint decides to respond to the request.\r\n\r\nThis makes sense to me too. As soon as the first request has gone over the wire we start being susceptible to replay attacks, so even if that first request could not be exchanged correctly we would not want to see the same code again.\r\n\r\nMy 2\u00a2 after missing the discussion on IRC. But this has always been my reading, whether valid or not.",
          "createdAt": "2021-06-14T11:26:42Z",
          "updatedAt": "2021-06-14T11:26:42Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think the AS should revoke previously valid access tokens. The authorization code should only be presented once, subsequent presentations should be an error.\r\n\r\nSome more color on the problems that might occur would help this discussion!\r\n",
          "createdAt": "2021-09-21T16:33:17Z",
          "updatedAt": "2021-09-21T16:33:17Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "To throw a few considerations in here:\r\n\r\nIt is useful if a successful authorization code use can be attempted again in the event that the client fails to receive/successfully process the response. (i.e. the same problem many folks have seen with refresh token rotation where the new refresh token isn't received by the client and, if the old refresh token was immediately invalidated, then the client has lost access to the data and can't regain access until the user next interacts with the client - but in the case of the authorization code this is a smaller problem as the client is likely interacting with the user at the same and can just send them through the authorization endpoint again. Also to add this isn't a theoretical problem, multiple Openbanking ecosystems have had issues with clients losing access to data due to refresh token rotation failing.)\r\n\r\nFor the purposes of testing an OAuth implementation, it'd be really handy if it was clearly defined that an erroneous use of an authorization code did NOT count as a use. Defining it like that means a large number of tests can be done against a production system, without requiring that a manual authorization endpoint interaction (potentially with 2FA) happens for each test. (Currently the OpenID Foundation FAPI test suite is a bit constrained in the testing it can do against the authorization code grant as we have to assume the authorization code has been consumed even when we use it unsuccessfully, meaning we have to carefully weigh up the benefits of performing an extra test vs the \"cost\" of the test user having to do extra manual interactions.\r\n\r\nA further point is that I believe the DPoP spec assumes (or should assume) an authorization code is NOT consumed if the token endpoint call fails because the server wants a newly provided nonce to be used. I don't recall this being mentioned before so opened https://github.com/danielfett/draft-dpop/issues/164\r\n\r\n",
          "createdAt": "2022-07-27T09:13:47Z",
          "updatedAt": "2022-07-27T09:13:47Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "From the side meeting\r\n* Allow the request to be rejected without touching the authorization code if it failed because of client authentication\r\n* Specify in the authorization code extension how to reject the request and when to invalidate the authorization code\r\n* Put this in the error response section in the authorization code flow",
          "createdAt": "2022-07-27T14:38:59Z",
          "updatedAt": "2022-07-27T14:38:59Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "concur with the side meeting decisions FWIW ",
          "createdAt": "2022-07-27T15:20:18Z",
          "updatedAt": "2022-07-27T15:20:18Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I went with describing the intended outcome instead of all the details:\r\n\r\n> The authorization server MUST return an access token only once for a given authorization code.\r\n\r\nThis allows DPoP to have the client send the authorization code multiple times, since it doesn't place a restriction on clients \"using\" authorization codes.",
          "createdAt": "2024-01-09T23:39:22Z",
          "updatedAt": "2024-01-09T23:39:22Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "MDU6SXNzdWU5OTA1OTA2MjY=",
      "title": "Better term for a Bearer token that also has PoP",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/83",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "From Vittorio:\r\n\r\n> \u00a77.2 \u201cbearer tokens may be extended to include proof-of-possession  techniques by other specifications\u201d sounds like an oxymoron. Wouldn\u2019t PoP make the token no longer bearer by the very definition above? It looks like we might need a term for simply \u201ctoken\u201d.",
      "createdAt": "2021-09-08T02:12:45Z",
      "updatedAt": "2021-09-22T20:05:30Z",
      "closedAt": "2021-09-22T18:26:43Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "bearer tokens may be enhanced with proof-of-possession specifications such as XXX to provider proof-of-possession characteristics",
          "createdAt": "2021-09-21T16:30:11Z",
          "updatedAt": "2021-09-21T16:30:11Z"
        },
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "mTLS uses BEARER as token type ",
          "createdAt": "2021-09-21T16:36:49Z",
          "updatedAt": "2021-09-21T16:36:49Z"
        }
      ]
    },
    {
      "number": 84,
      "id": "MDU6SXNzdWU5OTA1OTIzOTE=",
      "title": "Clarify scope of \"Insufficient_scope\" error",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/84",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "dickhardt"
      ],
      "labels": [
        "draft-00-feedback",
        "editors discussion"
      ],
      "body": "From Vittorio:\r\n\r\n---\r\n\r\n[\u00a77.2.3](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-00#section-7.2.3)\r\nThe \u201cinsufficient_scope\u201d description here is problematic. The privileges the AT carries/points to are not necessarily (or exclusively) represented by the included scopes (eg the RO might have granted document:read to the client, but RO might have no privileges for the particular document being requested in this particular call). It might be useful to specify that \u201cinvalid_scope\u201d should be used for authorization errors that can be actually expressed in terms of delegated authorization, leaving to RS implementers the freedom to handle other authorization issues (eg user privileges, RBAC, etc) with a different error code. Or at least, we should be clear that authorization logic not expressed via scopes is out of scope (pun not intended) for this specification.\r\nNote, this isn\u2019t an abstract problem: there are SDKs out there that use \u201cinvalid_scope\u201d for every permission issues. Very confusing.",
      "createdAt": "2021-09-08T02:14:08Z",
      "updatedAt": "2021-09-28T18:22:14Z",
      "closedAt": "2021-09-28T18:22:14Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "to me, insufficient_scope => the client does not have scope required for the request\r\ninvalid_scope => when I see invalid_scope, I think that the RS does not understand what scope the client has",
          "createdAt": "2021-09-21T16:27:24Z",
          "updatedAt": "2021-09-21T16:27:24Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll get clarity for what Vittorio is asking for.",
          "createdAt": "2021-09-21T18:30:23Z",
          "updatedAt": "2021-09-21T18:30:23Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Here is my restatement from thread with Vittorio:\r\n\r\n\"insufficient_scopes\" - is the correct error to return if the application has not been granted the scopes required for the request\r\n\r\nVittorio:\r\n\"to me the highest order but is ensuring that the reader doesn\u2019t abuse insufficient_scopes and realizes other error codes are possible.\"\r\n\r\nI've submitted a pull request with suggested language changes\r\n",
          "createdAt": "2021-09-24T00:59:26Z",
          "updatedAt": "2021-09-24T01:11:22Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "MDU6SXNzdWU5OTA2MDk2NDc=",
      "title": "Should we tell RSs to ignore access tokens passed in the query string?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/85",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "From Vittorio:\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/oauth/RP71xU8P4WLLIx0NcQMnw4gHScQ/",
      "createdAt": "2021-09-08T02:27:22Z",
      "updatedAt": "2021-09-22T20:25:04Z",
      "closedAt": "2021-09-22T20:25:04Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Related to #77 ",
          "createdAt": "2021-09-21T16:21:58Z",
          "updatedAt": "2021-09-21T16:23:02Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm wondering if we can be stronger and have it be an error. Ignore is likely the best approach.",
          "createdAt": "2021-09-21T16:23:36Z",
          "updatedAt": "2021-09-21T16:23:36Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Aaron and I agree to ignore",
          "createdAt": "2021-09-21T18:25:25Z",
          "updatedAt": "2021-09-21T18:25:25Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "MDU6SXNzdWU5OTA2MTA1NTk=",
      "title": "What happens to the registries defined by 6749 and 6750 when this supersedes them?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/86",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "question",
        "draft-00-feedback"
      ],
      "body": "Some comments from Vittorio about that here:\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/oauth/RP71xU8P4WLLIx0NcQMnw4gHScQ/",
      "createdAt": "2021-09-08T02:28:06Z",
      "updatedAt": "2022-07-15T19:51:40Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "No change unless we are changing what is in registry -- are there any registry changes?",
          "createdAt": "2022-07-15T19:51:39Z",
          "updatedAt": "2022-07-15T19:51:39Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "MDU6SXNzdWU5OTA2MTM5MDk=",
      "title": "Add something in Access Token Privilege Restriction about the first-party use case",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/87",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "question",
        "draft-00-feedback"
      ],
      "body": "From Vittorio:\r\n\r\n---\r\n\r\n[\u00a77.4.5](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-00#section-7.4.5)\r\n\r\nAlong the same lines of the comments about delegated authorization earlier for \u00a77.2.3. I think it would be useful to acknowledge here that ATs might carry, and RSs might expect, authorization information that go beyond the delegated authorization for 3rd party API case that is core to OAuth- and remind the reader that those mechanisms are out of scope for oauth hence they shouldn\u2019t expect those aspects to be addressed/handled/regulated by this specification. ",
      "createdAt": "2021-09-08T02:30:45Z",
      "updatedAt": "2021-09-28T18:17:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I don't see anything in 7.4.5 that limits the use to the delegated authorization scenario so I'm not sure what would need to change.",
          "createdAt": "2021-09-28T18:16:25Z",
          "updatedAt": "2021-09-28T18:16:25Z"
        }
      ]
    },
    {
      "number": 88,
      "id": "MDU6SXNzdWU5OTA2MjMwMzQ=",
      "title": "Fix leftover language from RFC6750",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/88",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "from Justin:\r\n\r\n---\r\n\r\n[\u00a77.2.2](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-00#section-7.2.2): some leftover language from this being standalone: \u201cAll challenges defined by this specification MUST use the auth-scheme value Bearer\u201d. Change to \u201call challenges for this token type\u2026\u201d\r\n\r\nhttps://mailarchive.ietf.org/arch/msg/oauth/Ex2eSkHBAKnmP0cFIyzEywLzeDk/\r\n",
      "createdAt": "2021-09-08T02:43:42Z",
      "updatedAt": "2021-09-08T20:11:02Z",
      "closedAt": "2021-09-08T20:10:55Z",
      "comments": []
    },
    {
      "number": 89,
      "id": "MDU6SXNzdWU5OTA2MjQwNzk=",
      "title": "Clarify that RSs are free to define their own error responses",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/89",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "From Justin:\r\n\r\n---\r\n\r\n[\u00a77.3](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-00#section-7.3): This section should probably discuss the fact that a given API can have its own error codes and responses and doesn\u2019t have to use the OAuth responses. This isn\u2019t clear by the text, and if the intention of the original text was to have everyone return the same JSON error, that\u2019s violating design principles of OAuth as a security layer on top of an API (and we should fix that). Either way we should be clear about the place of OAuth\u2019s error messages.",
      "createdAt": "2021-09-08T02:45:23Z",
      "updatedAt": "2021-10-11T21:59:18Z",
      "closedAt": "2021-10-11T21:59:15Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "In looking through this again, the spec doesn't mandate any JSON response for RSs, only from the token endpoint. The error codes referred to are in the `WWW-Authenticate` header, which seems like the appropriate place for it.",
          "createdAt": "2021-10-11T21:59:15Z",
          "updatedAt": "2021-10-11T21:59:15Z"
        }
      ]
    },
    {
      "number": 90,
      "id": "MDU6SXNzdWU5OTE0NTc0MDU=",
      "title": "Update references to new RFCs that were previously drafts",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/90",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2021-09-08T19:26:56Z",
      "updatedAt": "2022-02-10T00:31:42Z",
      "closedAt": "2022-02-10T00:31:42Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "* https://datatracker.ietf.org/doc/html/draft-ietf-oauth-jwt-introspection-response\r\n* https://datatracker.ietf.org/doc/html/draft-ietf-oauth-par\r\n* https://datatracker.ietf.org/doc/html/draft-ietf-oauth-access-token-jwt",
          "createdAt": "2021-09-08T19:48:27Z",
          "updatedAt": "2021-09-08T19:48:27Z"
        }
      ]
    },
    {
      "number": 91,
      "id": "MDU6SXNzdWU5OTE1Mzk2NzA=",
      "title": "Rewrite \"Protocol Flow\" section to address/acknowledge alternative flows",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/91",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Some flows and extensions work differently from the core authorization code flow, such as PAR and the device flow which start out with a POST request to the authorization server. These should be clarified in the Protocol Flow section so that people know this is a possibility and where to go for further reading.",
      "createdAt": "2021-09-08T21:17:58Z",
      "updatedAt": "2022-03-19T17:43:30Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 92,
      "id": "I_kwDODkfq5s47yc2R",
      "title": "Consider dropping complex authorization code replay mitigations in favor of PKCE",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/92",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There are a number of authorization code replay mitigations in 6749 that are not strictly necessary thanks to PKCE. Additionally, some of the mitigation techniques are quite burdensome to implement.\r\n\r\n* #65\r\n* #82\r\n* #54\r\n\r\nIt should still be possible to allow ASs to limit authorization codes to one time use if they want to put that limitation in place and it's feasible for them.\r\n\r\nThis may have some implications around one-time-use requests to resource servers such as payment initiation.\r\n",
      "createdAt": "2021-09-21T18:56:56Z",
      "updatedAt": "2024-01-09T23:39:38Z",
      "closedAt": "2024-01-09T23:39:37Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "During the interim we agreed to move forward with these changes, as well as better document all the breaking changes compared to OAuth 2.0, captured here #97",
          "createdAt": "2021-10-13T17:09:52Z",
          "updatedAt": "2021-10-13T17:09:52Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "All related issues have been addressed.",
          "createdAt": "2024-01-09T23:39:37Z",
          "updatedAt": "2024-01-09T23:39:37Z"
        }
      ]
    },
    {
      "number": 93,
      "id": "I_kwDODkfq5s47yj37",
      "title": "Consolidate loopback/localhost language",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/93",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Move the language in in [7.7.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-03#section-7.7.1) with the recommendation of avoiding the name `localhost` into section [8.3.3](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-03#section-8.3.3) and add a reference in 7.7.1 to that.",
      "createdAt": "2021-09-21T19:14:52Z",
      "updatedAt": "2021-09-22T20:04:59Z",
      "closedAt": "2021-09-22T20:04:47Z",
      "comments": []
    },
    {
      "number": 95,
      "id": "I_kwDODkfq5s48CNkl",
      "title": "Security consideration of size of client parameters",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/95",
      "state": "CLOSED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "An attacker could pass a client generated parameter that is too long for the server potentially. Should this be mentioned in security considerations, or would that be considered a general web security consideration and not need mentioning?",
      "createdAt": "2021-09-25T22:38:07Z",
      "updatedAt": "2024-12-04T12:17:18Z",
      "closedAt": "2024-12-04T12:17:18Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Check if HTTP or URL BCPs have anything to reference",
          "createdAt": "2024-11-20T15:50:02Z",
          "updatedAt": "2024-11-20T15:50:02Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "I did not find any BCPs on query parameter length",
          "createdAt": "2024-12-04T12:17:18Z",
          "updatedAt": "2024-12-04T12:17:18Z"
        }
      ]
    },
    {
      "number": 97,
      "id": "I_kwDODkfq5s49H4Qe",
      "title": "Expand differences from OAuth 2.0 section 10",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/97",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "Document each change and when there is a breaking change note for which role it breaks.\r\n\r\ne.g.\r\n\r\nA 2.1 client trying to work with a 2.0 server that uses PKCE would break if the redirect_uri is not sent to the token endpoint if the client is configured with more than one redirect_uri.\r\n",
      "createdAt": "2021-10-13T16:45:42Z",
      "updatedAt": "2024-01-31T15:11:48Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 100,
      "id": "I_kwDODkfq5s4_tWcS",
      "title": "Authorization Request Header Field: CRLF Injections",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/100",
      "state": "OPEN",
      "author": "lauritzh",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In [Section 5.2.1.1.](https://github.com/aaronpk/oauth-v2-1/blob/main/draft-ietf-oauth-v2-1.md#authorization-request-header-field) the syntax of `access_token` values that are used in the context of HTTP headers is explicitly outlined as follows:\r\n\r\n```\r\nb64token    = 1*( ALPHA / DIGIT /\r\n                 \"-\" / \".\" / \"_\" / \"~\" / \"+\" / \"/\" ) *\"=\"\r\ncredentials = \"Bearer\" 1*SP b64token\r\n```\r\n\r\nI think it is a good thing that this description was moved from [rfc6750](https://datatracker.ietf.org/doc/html/rfc6750#section-2.1) to the \"core\". \ud83d\ude42\r\n\r\nOne particular issue I observed in the wild are CRLF injection issues caused by `access_token` values being used without any sanitisation. Examples for this can for instance be found in my [master's thesis](https://www.nds.ruhr-uni-bochum.de/media/nds/arbeiten/2020/11/30/Masterarbeit_Lauritz_Holtmann_Single_Sign-On_Security.pdf) (section 5.4.3.1) and on [my blog](https://security.lauritz-holtmann.de/post/sso-security-crlf-injection/).\r\n\r\nA CRLF injection via the bearer token could have significant impact, as the IdP may be also in the position to directly make the SP to perform requests to a chosen destination (e.g. \"malicious Endpoint Attack\" via UserInfo request in OIDC). Cloud providers tend to implement mitigations against SSRF to the internal network using [special HTTP headers](https://cloud.google.com/compute/docs/metadata/overview#parts-of-a-request). This mitigation could be bypassed using this type of injection issue.\r\n\r\nTherefore, I would like to propose to add a recommendation to carefully sanitise the bearer tokens before using them in the context of HTTP headers.",
      "createdAt": "2021-12-01T20:45:04Z",
      "updatedAt": "2022-11-08T14:00:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Newlines aren't allowed in bearer tokens according to that definition. Are you suggesting adding something in the security considerations to suggest that clients double check that there are no newlines in a bearer token before using one in an HTTP header?",
          "createdAt": "2022-02-10T00:35:39Z",
          "updatedAt": "2022-02-10T00:35:39Z"
        },
        {
          "author": "lauritzh",
          "authorAssociation": "NONE",
          "body": "Hey @aaronpk!\r\n\r\nThank you very much for having a look into this. \r\n\r\nYes, I would suggest to add something to the security considerations regarding the handling of received `access_token`. SPs must check that the received value follows the specification and does not include any dangerous meta characters like CRLF sequences. \r\n\r\nWhat do you think about this? I could on the one hand think about a general recommendation to carefully sanitize the `access_token` in a context aware manner before utilizing it. On the other hand a specific recommendation regarding HTTP headers would be maybe easier to follow for implementers. ",
          "createdAt": "2022-02-10T17:57:36Z",
          "updatedAt": "2022-02-10T17:57:36Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I don't think any recommendation that involves the client modifying (sanitizing) the access token is a good idea. At most I would say check whether the access token has any invalid characters and discard it if there are any.",
          "createdAt": "2022-02-10T18:03:54Z",
          "updatedAt": "2022-02-10T18:03:54Z"
        },
        {
          "author": "lauritzh",
          "authorAssociation": "NONE",
          "body": "I agree on that. \r\nDiscarding malformed tokens that include invalid characters sounds like a reasonable recommendation to me and is indeed less complex implementation-wise :+1: ",
          "createdAt": "2022-02-10T19:45:00Z",
          "updatedAt": "2022-02-10T19:45:00Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "On further thought, this actually sounds like more of a recommendation for the HTTP client rather than the OAuth client. An HTTP client shouldn't allow CRLF characters in values of HTTP headers. I don't think it's a good idea to recommend that OAuth clients validate the syntax of an access token without it sounding like we mean clients should be fully parsing an access token.",
          "createdAt": "2022-11-08T14:00:16Z",
          "updatedAt": "2022-11-08T14:00:16Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "I_kwDODkfq5s5DT3N3",
      "title": "Drop requirement that bearer tokens must expire?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/101",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ietf-113"
      ],
      "body": "I never actually realized this before, but RFC6750 requires that bearer tokens have a limited lifetime.\r\n\r\n> the lifetime of the token MUST be limited; one means\r\n> of achieving this is by putting a validity time field inside the\r\n> protected part of the token\r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc6750#section-5.2\r\n\r\nGiven that there are plenty of examples of authorization servers that issue non-expiring bearer tokens, should we remove this requirement or at least make it a SHOULD?",
      "createdAt": "2022-02-10T01:07:36Z",
      "updatedAt": "2022-07-21T00:58:43Z",
      "closedAt": "2022-07-21T00:58:43Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This was discussed at IETF 113: [minutes](https://notes.ietf.org/notes-ietf-113-oauth#issue-101-Access-tokens-must-have-a-limited-lifetime)\r\n\r\nIt was agreed that the text needs a better definition of what \"limited lifetime\" means, to ensure that it is not limited to scheduled time-based expiration. I need to review the recording, but IIRC we agreed to remove the sentence containing \"the lifetime of the token MUST be limited\" and instead add more security considerations describing different ways and reasons a token may be revoked/become inactive.",
          "createdAt": "2022-03-22T11:03:55Z",
          "updatedAt": "2022-03-22T11:03:55Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "I_kwDODkfq5s5DT7bm",
      "title": "mention whether native clients should be allowed to be upgraded?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/102",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "client-definition-consolidation",
        "ietf-114"
      ],
      "body": "https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-04.html#section-7.3\r\n\r\n> Should we say something about whether native clients should be allowed to be \u201cupgraded\u201d as confidential clients in the future, or the other way round? I know of scenarios where people did that to preserve consent info, but that seem sketchy security wise.\r\n\r\n",
      "createdAt": "2022-02-10T01:28:06Z",
      "updatedAt": "2022-07-21T01:50:26Z",
      "closedAt": "2022-07-16T00:37:58Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "With the decision to simplify the definition of confidential/public clients, I wouldn't say \"upgraded\" is the right term. If anything, mentioning that a native app might be considered a confidential client if it obtains a client secret somehow, but we don't want to make any recommendations on how that might happen right now.",
          "createdAt": "2022-06-28T23:18:01Z",
          "updatedAt": "2022-06-28T23:18:01Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "I_kwDODkfq5s5EdK4f",
      "title": "limited access to an HTTP service",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/103",
      "state": "CLOSED",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This specification defines that\r\n\r\n> The OAuth 2.1 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and an authorization service, or by allowing the third-party application to obtain access on its own behalf. \r\n\r\nin the same way as the specification for OAuth 2.0 did. Although it's only partially true these days as there are tons of examples where the oAuth clients work with non-HTTP-based applications, such as POP3, IMAP, SMTP, various proprietary protocols... this list goes on and on.\r\n\r\nBelow is an excerpt from [A Set of Simple Authentication and Security Layer (SASL) Mechanisms for OAuth (RFC 7628)](https://datatracker.ietf.org/doc/html/rfc7628#section-1) on the same\r\n\r\n> The main use cases for OAuth 1.0a and OAuth 2.0 have so far focused\r\n>    on an HTTP-based [[RFC7230](https://datatracker.ietf.org/doc/html/rfc7230)] environment only.  This document\r\n>    integrates OAuth 1.0a and OAuth 2.0 into non-HTTP-based applications\r\n>    using the integration into the Simple Authentication and Security\r\n>    Layer (SASL) [[RFC4422](https://datatracker.ietf.org/doc/html/rfc4422)].  Hence, this document takes advantage of the\r\n>    OAuth protocol and its deployment base to provide a way to use SASL\r\n>    to gain access to resources when using non-HTTP-based protocols, such\r\n>    as the Internet Message Access Protocol (IMAP) [[RFC3501](https://datatracker.ietf.org/doc/html/rfc3501)] and the\r\n>    Simple Mail Transfer Protocol (SMTP) [[RFC5321](https://datatracker.ietf.org/doc/html/rfc5321)].  This document gives\r\n>    examples of use in IMAP and SMTP.\r\n\r\nI suggest replacing \"an HTTP service\" with a more generic \"resource server\" or \"resource service\".",
      "createdAt": "2022-02-23T19:35:39Z",
      "updatedAt": "2022-02-23T19:55:09Z",
      "closedAt": "2022-02-23T19:55:09Z",
      "comments": []
    },
    {
      "number": 106,
      "id": "I_kwDODkfq5s5Fdjqm",
      "title": "authorization servers MUST support Private-Use URI Scheme Redirection?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/106",
      "state": "CLOSED",
      "author": "jogu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "ietf-113",
        "ietf-114"
      ],
      "body": "I'm potentially a little bit concerned by the wording here:\r\n\r\nhttps://github.com/aaronpk/oauth-v2-1/blame/main/draft-ietf-oauth-v2-1.md#L3078-L3080\r\n\r\n> To fully support native apps, authorization servers MUST offer\r\n> at least the three redirect URI options described in the following\r\n> subsections to native apps.\r\n\r\n\r\nAdmittedly this is very similar to the text in the [native apps BCP](https://datatracker.ietf.org/doc/html/rfc8252#section-7) (which I believe is where it came from). However having this text in a standard (rather than a BCP) seems problematic to me:\r\n\r\nI think there are servers, particularly ones that aim for a higher-security profile (like OIDF's Financial-grade API), that would choose not to support private-use URI schemes (because of their generally poorer security compared to claimed `https` scheme redirects), and it seems such a server would not be OAuth 2.1 compliant.\r\n",
      "createdAt": "2022-03-10T15:30:59Z",
      "updatedAt": "2022-07-21T01:06:25Z",
      "closedAt": "2022-07-21T01:06:24Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "From the IETF 113 minutes:\r\n\r\n> we are going to re-order the list, claimed https URL first, loopback second, and private URI schemes. Remove the sentence for the mandatory-implementing all three",
          "createdAt": "2022-07-21T01:02:32Z",
          "updatedAt": "2022-07-21T01:02:32Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "I_kwDODkfq5s5GIeDs",
      "title": "Remove \"credentialed client\" term",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/107",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "client-definition-consolidation",
        "ietf-114"
      ],
      "body": "Email from Brian: https://mailarchive.ietf.org/arch/msg/oauth/emOUhFGpiOUrIjHfOssFv4HucEc/\r\n\r\nThis was discussed at IETF 113: https://notes.ietf.org/s/notes-ietf-113-oauth#credentialed-client\r\n\r\n* Remove the new term, reverting back to just \"confidential\" and \"public\" clients\r\n* Clarify that \"confidential\" clients are any client able to protect a secret/credential, regardless of how that credential was obtained (both via out of band registration/configuration, or at runtime)\r\n* Add new text talking about the different concerns an AS might have about a particular client, e.g. how much it is trusted, which often has nothing to do with whether the client has credentials. e.g. a confidential client on a system that allows public registration of clients should not be treated with the same privileges as a confidential client that was registered by a system administrator",
      "createdAt": "2022-03-22T11:10:12Z",
      "updatedAt": "2022-07-16T00:42:19Z",
      "closedAt": "2022-07-16T00:42:19Z",
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "I came here (two days later) to file this very issue. Thanks for doing it before I got around to it. ",
          "createdAt": "2022-03-23T17:31:35Z",
          "updatedAt": "2022-03-23T17:31:35Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Related issues that include additional concerns that should be addressed with this change:\r\n\r\n#18 Clean up usage of the term \"client identity\"\r\n#33 AS's confidence in the client's identity\r\n#34 A single \"client_id\" MUST NOT be treated as more than one type of client\r\n#102 mention whether native clients should be allowed to be upgraded?\r\n#36 Authorization servers SHOULD use client authentication if possible",
          "createdAt": "2022-06-28T23:18:06Z",
          "updatedAt": "2022-06-28T23:31:40Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "The term was removed in #123 ",
          "createdAt": "2022-07-16T00:25:36Z",
          "updatedAt": "2022-07-16T00:25:36Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "There is a discussion of the privileges of different clients in the security considerations section 7.2.\r\n\r\nAll related issues to this have been resolved.",
          "createdAt": "2022-07-16T00:42:19Z",
          "updatedAt": "2022-07-16T00:42:19Z"
        }
      ]
    },
    {
      "number": 108,
      "id": "I_kwDODkfq5s5GtscV",
      "title": "Should auth-param in WWW-Authenticate be optional?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/108",
      "state": "OPEN",
      "author": "johakoch",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07 section 5.2.3 (The WWW-Authenticate Response Header Field):\r\n\r\n>    All challenges for this token type MUST use the auth-scheme value\r\n>    Bearer.  This scheme MUST be followed by one or more auth-param\r\n>    values.\r\n\r\nWhy is at least one `auth-param` required? It makes\r\n```\r\nWWW-Authenticate: Bearer\r\n```\r\n\r\nin response to a request lacking any authentication information (thus without an `error` auth-param attribute) non-compliant. The optional `scope` attribute is not useful in this case. The optional `realm` attribute may not be necessary (e.g. if there is only one realm). So to be compliant, you would have to add a non-meaningful auth-param like `foo=bar`.\r\n\r\nNote: While in [rfc2617](https://datatracker.ietf.org/doc/html/rfc2617#section-1.2) `challenge` was defined as\r\n```\r\n  challenge   = auth-scheme 1*SP 1#auth-param\r\n```\r\n(requiring at least one `auth-param`), [rfc9110](https://www.rfc-editor.org/rfc/rfc9110#section-11.3) does not have this requirement (neither did [rfc7235](https://www.rfc-editor.org/rfc/rfc7235#section-2.1)):\r\n```\r\n  challenge   = auth-scheme [ 1*SP ( token68 / #auth-param ) ]\r\n```\r\n",
      "createdAt": "2022-03-30T12:26:19Z",
      "updatedAt": "2024-11-12T16:37:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "johakoch",
          "authorAssociation": "NONE",
          "body": "In the meantime, the section numbering has changed. This issue refers to section 5.3.1 of the draft version 11.",
          "createdAt": "2024-11-12T16:37:09Z",
          "updatedAt": "2024-11-12T16:37:09Z"
        }
      ]
    },
    {
      "number": 109,
      "id": "I_kwDODkfq5s5H9oWF",
      "title": "the refresh token response and the scope parameter",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/109",
      "state": "CLOSED",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'm wondering if the refresh token response section should also recommend including the scope parameter when the client uses an RT in order to obtain a new AT with narrowed scope.\r\n\r\nPer the \"Refresh Token\" section.\r\n\r\n> Refresh tokens are issued to the client by the authorization server and are used to obtain a new access token when the current access token becomes invalid or expires, or to obtain additional access tokens with identical or narrower scope (access tokens may have a shorter lifetime and fewer permissions than authorized by the resource owner).\r\n\r\nFor the token response (grant_type = authorization_code), [the specification states](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-05#section-3.2.3) that\r\n\r\n> \"scope\": : RECOMMENDED, if identical to the scope requested by the client; otherwise, REQUIRED. The scope of the access token as described by {{access-token-scope}}.\r\n\r\nwhich as you know, is one of the minor differences between OAuth 2.0 and 2.1 and a bit of a corner case but anyway...",
      "createdAt": "2022-04-18T18:53:14Z",
      "updatedAt": "2023-07-10T19:18:01Z",
      "closedAt": "2023-07-10T19:18:01Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This is true in both RFC6749 as well as OAuth 2.1. Both specs actually refer to the main token response section which says the `scope` property should be returned if it was different than what the client requests. Do you think this needs to be made more explicit?\r\n\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-4.3.2",
          "createdAt": "2022-11-08T13:24:44Z",
          "updatedAt": "2022-11-08T13:24:44Z"
        }
      ]
    },
    {
      "number": 112,
      "id": "I_kwDODkfq5s5LgA8z",
      "title": "HTTP is not RFC9110. RFC723x are now obsoleted",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/112",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## I expect\r\n\r\n- this I-D to rely on RFC9110 which is the new HTTP.",
      "createdAt": "2022-06-09T21:34:50Z",
      "updatedAt": "2022-06-10T17:59:09Z",
      "closedAt": "2022-06-10T17:59:09Z",
      "comments": []
    },
    {
      "number": 114,
      "id": "I_kwDODkfq5s5Lhksg",
      "title": "Use HTTP style guide",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/114",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## I suggest\r\n\r\n- to align to the https://httpwg.org/admin/editors/style-guide for editorial consistency with HTTP specification",
      "createdAt": "2022-06-10T06:20:53Z",
      "updatedAt": "2022-06-10T06:20:53Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 115,
      "id": "I_kwDODkfq5s5Lhp0X",
      "title": "Terminology nits",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/115",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "## I expect\r\n\r\n- to clarify some terminology nits. eg. the document seems to use interchangably the words \"identify\" and \"authenticate\", or \"AS\", \"authorization server\" and \"Authorization Server\" eg.\r\n\r\n>  The authorization server\r\n> MUST first verify the identity of the resource owner.  The way in\r\n> which the authorization server authenticates the resource owner\r\n\r\nIf this is the case, I'd pick one, eg.\r\n\r\n> The AS MUST authenticate the Resource Owner. The way the AS authenticates the Resource Owner ...",
      "createdAt": "2022-06-10T06:38:55Z",
      "updatedAt": "2022-11-08T13:18:56Z",
      "closedAt": "2022-11-08T13:18:56Z",
      "comments": []
    },
    {
      "number": 116,
      "id": "I_kwDODkfq5s5LhuqL",
      "title": "HTTP 307. duplicate normative statements",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/116",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## I expect\r\n\r\n- no duplicate normative statements\r\n- state the normative sentences first,  and once\r\n- then explain\r\n\r\n```\r\nAn AS which redirects a request that potentially contains user\r\ncredentials MUST NOT use the 307 status code (see {{Section 15.4.8 of RFC9110}}) for\r\nredirection.\r\n\r\nThe RECOMMENDED status code for HTTP redirects is 303.\r\n\r\n...\r\n```\r\n## Instead\r\n\r\n```\r\nIf an HTTP redirection (and not, for example,\r\nJavaScript) is used for such a request, AS SHOULD use the status\r\ncode 303 \"See Other\".\r\n...\r\nTherefore, the RECOMMENDED status code for HTTP redirects is 303.\r\n```\r\n\r\n",
      "createdAt": "2022-06-10T06:52:15Z",
      "updatedAt": "2023-07-10T19:16:26Z",
      "closedAt": "2023-07-10T19:16:21Z",
      "comments": []
    },
    {
      "number": 117,
      "id": "I_kwDODkfq5s5LiMHJ",
      "title": "Clarification on redirect",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/117",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## I expect\r\n\r\n- clarifications on redirect strategies expliciting issues.",
      "createdAt": "2022-06-10T08:50:08Z",
      "updatedAt": "2023-07-10T19:16:31Z",
      "closedAt": "2023-07-10T19:16:21Z",
      "comments": []
    },
    {
      "number": 119,
      "id": "I_kwDODkfq5s5LiV1X",
      "title": "application/x-www-form-urlencoded is a media type",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/119",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## I expect\r\n\r\n- application/x-www-form-urlencoded is a media type\r\n- IANA registration points to https://url.spec.whatwg.org/#application/x-www-form-urlencoded",
      "createdAt": "2022-06-10T09:26:38Z",
      "updatedAt": "2023-07-11T15:02:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "YataoFeng",
          "authorAssociation": "NONE",
          "body": "Why can't we use application/json?",
          "createdAt": "2023-07-11T14:46:12Z",
          "updatedAt": "2023-07-11T14:46:12Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "@YataoFeng All the responses are JSON. Changing the request format to JSON is out of scope of OAuth 2.1, and also would serve no practical purpose.",
          "createdAt": "2023-07-11T15:02:21Z",
          "updatedAt": "2023-07-11T15:02:21Z"
        }
      ]
    },
    {
      "number": 120,
      "id": "I_kwDODkfq5s5M6lfr",
      "title": "How can an AS support both 2.0 and 2.1 clients concurrently",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/120",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "dickhardt"
      ],
      "labels": [
        "ietf-122"
      ],
      "body": "We may need some additional client registration metadata parameters in order to enforce some of the non-optional things in 2.1 while allowing 2.0 clients to still treat them as optional.\r\n\r\nRelated to #97 ",
      "createdAt": "2022-06-30T17:13:04Z",
      "updatedAt": "2025-01-09T17:53:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "We need AS metadata to tell clients what kind of clients it supports: OAuth 2.1 clients, or both clients. If the parameter doesn't exist, clients can assume the server only supports 2.0.\r\n\r\nAS metadata:\r\n* `oauth_versions: [\"2.1\",\"2.0\"]`\r\n\r\nShould go in a new metadata section before extensibility https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-12.html#section-6\r\n\r\nThe client metadata needs to indicate whether the AS should follow 2.1 processing rules or 2.0 processing rules.\r\n\r\nClient metadata\r\n* `oauth_version: \"2.1\"`\r\n\r\nNeed a new client metadata section in https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-12.html#section-2.3.1\r\n",
          "createdAt": "2024-11-20T15:40:33Z",
          "updatedAt": "2024-11-20T15:42:36Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "* There are multiple ways someone might want to migrate clients\r\n* How do I support both 2.0 and 2.1 clients at the same time\r\n* How do I not break existing clients, some of which might never upgrade\r\n* Provide clients a way to opt in to 2.1 behavior in a slow rollout (e.g. native apps where upgrades roll out slowly)\r\n",
          "createdAt": "2025-01-09T17:52:25Z",
          "updatedAt": "2025-01-09T17:52:25Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "I_kwDODkfq5s5NFgyH",
      "title": "Add multi factor authentication to OAuth justification",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/121",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "OAuth allows service provides to use advanced user authentication methods while continue to allow 3rd party apps API access. Wasn't relevant back in 2010, is very relevant nowadays.",
      "createdAt": "2022-07-04T15:04:39Z",
      "updatedAt": "2022-10-24T22:33:02Z",
      "closedAt": "2022-10-24T22:33:02Z",
      "comments": []
    },
    {
      "number": 122,
      "id": "I_kwDODkfq5s5NFhpR",
      "title": "Add more security sensitive examples to intro to illustrate suitability",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/122",
      "state": "OPEN",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "A bit about OAuth adoption in scenarios beyond its original scope (e.g. Open Banking). ",
      "createdAt": "2022-07-04T15:07:57Z",
      "updatedAt": "2024-12-04T15:11:19Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "> With OAuth, an end user (resource owner) can grant a printing service (client) access to their protected photos stored at a photo- sharing service (resource server), without sharing their username and password with the printing service. Instead, they authenticate directly with a server trusted by the photo-sharing service (authorization server), which issues the printing service delegation- specific credentials (access token).\r\n\r\n",
          "createdAt": "2024-11-20T15:26:39Z",
          "updatedAt": "2024-11-20T15:26:39Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Related to #168",
          "createdAt": "2024-11-20T15:27:05Z",
          "updatedAt": "2024-11-20T15:27:05Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Examples:\r\n\r\n* granting access to account information to a financial management app.\r\n* granting a third party app access to post to a social media account\r\n",
          "createdAt": "2024-12-04T15:10:19Z",
          "updatedAt": "2024-12-04T15:11:19Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "I_kwDODkfq5s5NFqBu",
      "title": "client id can be issued by trusted third party ",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/124",
      "state": "CLOSED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "the [spec text](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-2.2) is too strict - client ids must be unique within the context of an AS. However, there is no need to require client ids always to be issued by the authorization server. In a federation, the client id might be issued by a trusted third party (see https://openid.net/specs/openid-connect-federation-1_0.html). I could also imagine to allow clients to determine their client ids (need to check with client impersonating resource owner attack). ",
      "createdAt": "2022-07-04T15:43:31Z",
      "updatedAt": "2022-11-08T11:30:59Z",
      "closedAt": "2022-11-08T11:30:47Z",
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "Text proposal\r\n\r\n`Every client is identified in the context of an authorization server \r\nby a client identifier -- a unique string representing the registration\r\ninformation provided by the client. The Authorization Server may itself \r\nissue the client identifier, it may also server clients whose client identifier\r\nwas issued by a trusted third party. The client identifier is not a\r\nsecret; it is exposed to the resource owner and MUST NOT be used\r\nalone for client authentication.  The client identifier is unique in the \r\ncontext of an authorization server.`",
          "createdAt": "2022-07-04T15:44:09Z",
          "updatedAt": "2022-07-04T15:44:09Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This was added in c56d23b9f97ef4f58db5a10e8dd2bfee6540aa02",
          "createdAt": "2022-11-08T11:30:47Z",
          "updatedAt": "2022-11-08T11:30:47Z"
        }
      ]
    },
    {
      "number": 125,
      "id": "I_kwDODkfq5s5N4Xzp",
      "title": "Update references of private_key_jwt to RFC7523",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/125",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [
        "ietf-114"
      ],
      "body": "",
      "createdAt": "2022-07-15T23:26:38Z",
      "updatedAt": "2022-07-21T01:48:57Z",
      "closedAt": "2022-07-16T00:19:29Z",
      "comments": []
    },
    {
      "number": 126,
      "id": "I_kwDODkfq5s5OOVuc",
      "title": "Clean up references to URL vs URI vs application/x-www-form-urlencoded",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/126",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There are still some references to old URI specs like RFC3986, which have since been replaced by various IETF specs as well as the WHATWG URL spec.",
      "createdAt": "2022-07-21T02:36:36Z",
      "updatedAt": "2024-01-31T15:11:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk I asked to the HTTP ML and it seems there are many doubts on that point. In particular, \r\n\r\n@bagder (curl's author) referenced this post \r\n\r\n>  The current state of URLs and URIs cannot be described as anything less than a horrible mess, a security nightmare [*] and an infected area that lots of persons will not go near due to the past experiences and personal conflicts.\r\n> \r\n> [*] = https://daniel.haxx.se/blog/2022/01/10/dont-mix-url-parsers/\r\n\r\nand @royfielding wrote this interesting email https://lists.w3.org/Archives/Public/ietf-http-wg/2022AprJun/0173.html that iiuc states that\r\n\r\n> What URI (RFC3986) defines is a standard naming format that uses\r\nhierarchical name delegation to cover the entire Internet with identifiers.\r\n> The WHATWG url spec defines a set of rules for interpreting references\r\nand placing them in a url data structure within browser memory. url != URL.\r\nhref != URL. The spec says that this is somehow replacing URI, but it isn't\r\neven defining the same thing. \r\n\r\nAs of now, the application/x-www-form-urlencoded media type registration references the WHATWG url spec.\r\n\r\nI think that in OAuth we should:\r\n\r\n- consistently refer to IETF URL specifications;\r\n- avoid interchangeably use URI and URL when pointing to a dereferenceable location (e.g. a server URL);\r\n- only refer to WHATWG spec to reference the x-www-form-urlencoded specification.\r\n\r\nThis should minimize the security risks @bagder highlights in his post\r\nand provide a consistent language for implementers.\r\n\r\nSince I am not a veteran of the HTTP wg, I suggest asking for a preliminary review of this spec to the HTTP chairs: I think it will really improve the security profile of this great work.\r\n\r\nHTH,\r\nR\r\n\r\nSee also #119 ",
          "createdAt": "2022-07-21T10:11:37Z",
          "updatedAt": "2022-07-21T10:13:24Z"
        }
      ]
    },
    {
      "number": 128,
      "id": "I_kwDODkfq5s5OeEeG",
      "title": "Describe OAuth's use of application/x-www-form-urlencoded encoding",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/128",
      "state": "CLOSED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "help wanted",
        "interim",
        "ietf-117"
      ],
      "body": "499a8f88b70ca00bfa5ef588023c68c1d0277bff removed Appendix B but unlinked references to it are still within the document next to almost every `x-www-form-urlencoded` mention.\r\n\r\n---\r\n\r\nThroughout the years this Appendix was THE resource used over and over to explain why and how the OAuth use of the Basic authorization scheme encodes the username and password tokens.\r\n\r\nIf this Appendix is removed I would propose to add examples of client secret basic with username and password tokens where the client_id and client_secret encoding changes the octets that go into the basic authorization scheme base64 encoding. This is an often overlooked implementation detail that both client and server implementers get wrong and end up inoperable, further driving users to use client secret post which this document marks as NOT RECOMMENDED.",
      "createdAt": "2022-07-25T09:07:39Z",
      "updatedAt": "2024-05-15T00:00:57Z",
      "closedAt": "2024-05-15T00:00:56Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Does OAuth do something different than what's describe in the HTTP Basic Authentication Scheme spec?\r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc7617#section-2\r\n\r\n",
          "createdAt": "2022-11-08T16:23:24Z",
          "updatedAt": "2022-11-08T16:23:24Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "Yes.\r\n\r\n```\r\nThe client identifier is encoded using the\r\n\"application/x-www-form-urlencoded\" encoding algorithm per\r\nAppendix B, and the encoded value is used as the username; the client\r\npassword is encoded using the same algorithm and used as the\r\npassword.\r\n```\r\n\r\nThe client_id and client_secret are encoded before being passed to HTTP Basic as the username and password tokens.",
          "createdAt": "2022-11-08T16:27:47Z",
          "updatedAt": "2022-11-08T16:27:47Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I'm going to need someone who knows more about string encodings than me to write this section. I think it would be useful to have a new appendix that describes this encoding, but we can update it to avoid mentioning the out of date info in the 6749 appendix B. ",
          "createdAt": "2022-11-08T16:52:48Z",
          "updatedAt": "2022-11-08T16:52:48Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "In the mean time, there is a placeholder for this section and the internal references to it have been fixed\r\n\r\nhttps://drafts.oauth.net/oauth-v2-1/draft-ietf-oauth-v2-1.html#appendix-B",
          "createdAt": "2022-11-08T17:08:41Z",
          "updatedAt": "2022-11-08T17:08:41Z"
        },
        {
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "body": "String encoding does what it does, it escapes certain characters in the input string. Below are some JS examples with the intent to show the differences\r\n\r\n```\r\n> console.log(\"Authorization: Basic \" + btoa(\"client:secret\"))\r\n< Authorization: Basic Y2xpZW50OnNlY3JldA==\r\n>\r\n> console.log(\"Authorization: Basic \" + btoa(encodeURIComponent(\"client\") + \":\" + encodeURIComponent(\"secret\")))\r\n< Authorization: Basic Y2xpZW50OnNlY3JldA==\r\n```\r\nin both cases, we get the same results\r\n\r\nnow, let's use \"secret=\" instead of \"secret\"\r\n\r\n```\r\n> console.log(\"Authorization: Basic \" + btoa(\"client:secret=\"))\r\n< Authorization: Basic Y2xpZW50OnNlY3JldD0=\r\n>\r\n> console.log(\"Authorization: Basic \" + btoa(encodeURIComponent(\"client\") + \":\" + encodeURIComponent(\"secret=\")))\r\n< Authorization: Basic Y2xpZW50OnNlY3JldCUzRA==\r\n```\r\nwe get different results.\r\n\r\nThe OAuth specification requires us to use \"application/x-www-form-urlencoded\" encoding algorithm, and it's very often a source for interoperability issues as @panva mentions. ",
          "createdAt": "2022-11-09T20:06:59Z",
          "updatedAt": "2022-11-09T20:06:59Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "The correct js code that matches original appendix b behaviour to encode e.g. the client_id before passing it as username to basic auth is:\r\n\r\n\r\n    function formUrlEncode(token) {\r\n      return encodeURIComponent(token).replace(/(?:[-_.!~*'()]|%20)/g, (substring) => {\r\n        switch (substring) {\r\n          case '-':\r\n          case '_':\r\n          case '.':\r\n          case '!':\r\n          case '~':\r\n          case '*':\r\n          case \"'\":\r\n          case '(':\r\n          case ')':\r\n            return `%${substring.charCodeAt(0).toString(16).toUpperCase()}`\r\n          case '%20':\r\n            return '+'\r\n          default:\r\n            throw new Error()\r\n        }\r\n      })\r\n    }",
          "createdAt": "2022-11-09T21:26:08Z",
          "updatedAt": "2024-01-06T12:28:46Z"
        },
        {
          "author": "shartte",
          "authorAssociation": "NONE",
          "body": "> Does OAuth do something different than what's describe in the HTTP Basic Authentication Scheme spec?\r\n> \r\n> https://datatracker.ietf.org/doc/html/rfc7617#section-2\r\n\r\nI believe the important bit is that `application/x-www-form-urlencoded` specifies UTF-8 encoding, while basic authentication doesn't really say which encoding is to be used (causing interop issues when client secrets contain any non-ASCII characters).\r\nby saying \"use application/x-www-form-urlencoded\" to encode the client-id and client-secret before using them as username/password, it is ensured that the basic auth username and password are ASCII only.",
          "createdAt": "2023-10-02T10:35:21Z",
          "updatedAt": "2023-10-02T10:35:21Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "This continues to be a problematic point in the implementations. Both client and server implementations sometimes just rely on [Basic Authentication Scheme](https://datatracker.ietf.org/doc/html/rfc2617#section-2) plugins completely, or partially disregarding the requirement to encode the username/password tokens using application/x-www-form-urlencoded. This makes interop for client implementations particularly difficult.\r\n\r\nI've encountered clients that\r\n\r\n- don't do any encoding\r\n- encode every non-alphanumeric character except `- _ . ! ~ * ' ( )` and incorrectly uses `%20` instead of `+` for the U+0020 (SPACE) character\r\n- encode every non-alphanumeric character except `- _ . ! ~ * ' ( )`\r\n- do everything correctly\r\n\r\nI've encountered servers that\r\n\r\n- do not use any non-alphanumeric characters in their client_id and client_secret (deliberately limiting the syntax of these) as to avoid this mess altogether\r\n- use non-alphanumeric characters and gracefully handle the client mistakes mentioned above with the exception of no encoding used\r\n- use non-alphanumeric characters but fail to authenticate clients that encode properly as per the definition in OAuth\r\n\r\nThe biggest offender here is Google who uses `-` and `.` in their client_id values but fails to authenticate clients that properly encode those characters. Because of this, it's been the case for years that the most interoperable client implementation was to encode every non-alphanumeric character except `- _ . ! ~ * ' ( )`, which doesn't follow the definition.\r\n\r\ncc @jogu This issue is even present in the Google Federated Identity listing on https://openid.net/certification where the test suite back then did not properly encode. I hope that if the suite ran against google's implementation today the certification would fail.\r\n\r\nWhat a mess.\r\n\r\n- I think we should be giving more examples in the document. The current example of client_secret_basic avoids non-alphanumeric characters.\r\n- I think we should discuss restricting the client_id and client_secret syntax to alphanumerics only to avoid this mess completely.\r\n\r\nI'd like this issue to be discussed in future OAuth WG meetings.",
          "createdAt": "2024-01-06T10:36:51Z",
          "updatedAt": "2024-01-06T11:07:17Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "> I think we should discuss restricting the client_id and client_secret syntax to alphanumerics only to avoid this mess completely.\r\n\r\nI'd be very much in favour of something along these lines. The experience of the OIDF certification team very much matches Filip's experience - any time values end up with characters in them that require encoding the number of interoperability problems sky rockets, and often in ways that are complex and time consuming to resolve (as these kind of encodings are often happening automatically in libraries and not always in obvious ways). It really doesn't seem like a good use of any developer's time to try and make these things work correctly when there's really no great advantage to using the characters that do require encoding.\r\n\r\n(This is perhaps also a more general problem, e.g. similar interoperability issues arise if a client actually tries to use a state value that uses the current full set of allowed characters in state as per https://www.rfc-editor.org/rfc/rfc6749#appendix-A.5 )\r\n",
          "createdAt": "2024-01-07T01:24:04Z",
          "updatedAt": "2024-01-07T01:24:04Z"
        },
        {
          "author": "selfissued",
          "authorAssociation": "NONE",
          "body": "OpenID Federation Client IDs are HTTPS URLs.  Some OpenID4VC Client IDs are as well.  We need to keep the full character set.",
          "createdAt": "2024-03-22T05:34:32Z",
          "updatedAt": "2024-03-22T05:34:32Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "So interestingly, it isn't possible to use an HTTPS URL as a `userid` in HTTP Basic Auth, since HTTP Basic Auth defines `userid` as `*<TEXT excluding \":\">`: https://datatracker.ietf.org/doc/html/rfc2617#section-2\r\n\r\nUpdated reference: https://datatracker.ietf.org/doc/html/rfc7617#section-2",
          "createdAt": "2024-03-22T05:38:05Z",
          "updatedAt": "2024-03-22T05:45:28Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "I'm very glad this was discussed at IETF 119. Unfortunately it doesn't seem like any changes are likely to be acceptable.\r\n\r\nThis leaves client and server implementers in a tough spot where neither one can be compliant and/or strict about encoding/decoding the username/password tokens when interoperability is a goal because as seen - this current definition is already not followed.\r\n\r\nWhat guidance should we give to implementers, primarily clients, to be interoperable then? Don't use client_secret_basic, use client_secret_post instead? That's explicitly not meant to be the default and is defined as NOT RECOMMENDED.\r\n\r\n> Including the client credentials in the request content using the two parameters is NOT RECOMMENDED and SHOULD be limited to clients unable to directly utilize the HTTP Basic authentication scheme (or other password-based HTTP authentication schemes).",
          "createdAt": "2024-03-22T05:46:09Z",
          "updatedAt": "2024-03-22T05:47:49Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I suppose the other way to go is to open it up more rather than restrict it, for example saying that *only* the `:` character in a client ID or secret is encoded, but all other characters are left alone. That would seem to be allowed according to RFC7617.\r\n\r\nWhile this wouldn't automatically make everything interoperable, it would at least give people a faster path to interoperability for new implementations. Existing implementations that do some mix of pre-encoding the client ID/secret could be described as essentially defining their own encoding of the client ID/secret that the client developer would have to know by reading the docs, just like they already have to read the docs to know what scopes to use.",
          "createdAt": "2024-03-22T05:52:48Z",
          "updatedAt": "2024-03-22T05:52:48Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "@aaronpk unfortunately this would also not be compatible, in this case with existing implementations, which would continue to decode the unencoded resulting in malformed data and failed client authentications.",
          "createdAt": "2024-03-22T05:57:18Z",
          "updatedAt": "2024-03-22T05:57:18Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Right, but as was mentioned in the meeting, changing the spec also won't necessarily make existing implementations interoperable either. So my suggestion is more about making the spec reflect the reality of the variety of implementations instead.",
          "createdAt": "2024-03-22T06:04:32Z",
          "updatedAt": "2024-03-22T06:04:32Z"
        },
        {
          "author": "shartte",
          "authorAssociation": "NONE",
          "body": "> I suppose the other way to go is to open it up more rather than restrict it, for example saying that _only_ the `:` character in a client ID or secret is encoded, but all other characters are left alone. That would seem to be allowed according to RFC7617.\r\n> \r\n> While this wouldn't automatically make everything interoperable, it would at least give people a faster path to interoperability for new implementations. Existing implementations that do some mix of pre-encoding the client ID/secret could be described as essentially defining their own encoding of the client ID/secret that the client developer would have to know by reading the docs, just like they already have to read the docs to know what scopes to use.\r\n\r\nThis does not help IT departments that require \"special characters\" in generated passwords (please don't ask), which are non-ASCII (i.e. \u00a7). If clients encode the client secret as per the spec, the character set is well defined as UTF-8. If they don't encode it, it isn't.\r\n\r\nI'd personally say the reasoning for the encoding is clear. Making it known to implementers that they have to take care here is the key problem. :-(",
          "createdAt": "2024-03-22T12:23:29Z",
          "updatedAt": "2024-03-22T12:23:29Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "> This does not help IT departments that require \"special characters\" in generated passwords (please don't ask), which are non-ASCII (i.e. \u00a7). If clients encode the client secret as per the spec, the character set is well defined as UTF-8. If they don't encode it, it isn't.\r\n\r\nNon-ASCII characters are outside of the ABNF definition for client_id and client_secret in the first place.\r\n\r\n> I'd personally say the reasoning for the encoding is clear. Making it known to implementers that they have to take care here is the key problem. :-(\r\n\r\nI agree with this.\r\n\r\n---\r\n\r\nPutting my server developer hat on. I can deal with plenty of non-conformities coming from the clients on the server side.\r\n\r\nPutting my client developer hat on. I cannot deal with the different server implementations when they're not flexible. I would like to default to client_secret_post instead of client_secret_basic because of this issue but the fact that it's, a) a MAY support and b) as per spec, NOT RECOMMENDED, stops me from doing so. If that wasn't the case I'd be happy with the current character set and encoding rules, I could implement them properly in the client software and know that by default POST params are used that work with likely every server implementation.",
          "createdAt": "2024-03-22T12:42:19Z",
          "updatedAt": "2024-03-22T13:03:15Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "Sadly I couldn't join the meeting last night because of timezones, but I watched the recording at least.\r\n\r\nA couple of observations:\r\n\r\nThe Openbanking use cases that were mentioned that use urls as client ids don't use client secrets. I believe most federation use cases don't allow client secrets either. But I do agree with the conclusion that there's (unfortunately) not much we can/should do to restrict the client_id character set in general.\r\n\r\nI believe the problem only applies to client_secret_basic. I'm not sure how many of the problem authorization servers also support client_secret_post, but it seems google at least does.\r\n\r\nI agree with Aaron's suggestion of making the reality clearer, and Filip's suggestion of adding examples that cover this case.\r\n\r\nI think we could also encourage people to use client_secret_post instead of basic. (Although OAuth2.1 already recommends using asymmetric client authentication so already recommends against all forms of client secrets...)\r\n",
          "createdAt": "2024-03-22T12:46:14Z",
          "updatedAt": "2024-03-22T12:46:14Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "@panva (I didn't see your comment before posting mine)\r\n\r\n>  I would like to default to client_secret_post instead of client_secret_basic because of this issue but the fact that it's, as per spec, NOT RECOMMENDED, stops me from doing so.\r\n\r\nI don't think I was aware of that - where abouts is that recommendation?",
          "createdAt": "2024-03-22T12:49:09Z",
          "updatedAt": "2024-03-22T12:49:09Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "> I don't think I was aware of that - where abouts is that recommendation?\r\n\r\n@jogu \r\n\r\n[OAuth 2.0 section 2.3.1](https://www.rfc-editor.org/rfc/rfc6749.html#section-2.3.1)\r\n[OAuth 2.1 Draft 10 section 2.4.1](https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-10.html#section-2.4.1)",
          "createdAt": "2024-03-22T12:56:51Z",
          "updatedAt": "2024-03-22T12:56:51Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "Thanks Filip. That's a pain. I guess my suggestion is useless then.",
          "createdAt": "2024-03-22T13:58:33Z",
          "updatedAt": "2024-03-22T13:58:33Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "As discussed in the May 14 interim:\r\n\r\nResolved to:\r\n\r\n* Remove the \"NOT RECOMMENDED\" paragraph (but leave sentence \"The parameters can only be transmitted in the request content and MUST NOT be included in the request URI.\")\r\n* Change AS requirements to MUST support post body, MAY support HTTP Basic\r\n* Add a note about historic interop problems with HTTP Basic",
          "createdAt": "2024-05-14T17:06:22Z",
          "updatedAt": "2024-05-14T17:06:22Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "I_kwDODkfq5s5OlYu2",
      "title": "Reference PAR RFC 9126 exception to redirect URI registration",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/129",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-05#section-2.3.1\r\n\r\nRedirect URIs are not required to be registered if the client is using PAR and is a confidential client.",
      "createdAt": "2022-07-26T15:40:28Z",
      "updatedAt": "2022-10-24T21:06:05Z",
      "closedAt": "2022-10-24T21:06:05Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Discussed in the side meeting:\r\n\r\n* Mike suggested that if 2.1 talks about this exception at all, it include a note that PAR defines an exception to the pre-registration requirement, which cites the PAR section. The text should be a heads-up to implementers - not appear to be defining something new.",
          "createdAt": "2022-07-27T14:52:11Z",
          "updatedAt": "2022-07-27T14:52:11Z"
        }
      ]
    },
    {
      "number": 132,
      "id": "I_kwDODkfq5s5Uug27",
      "title": "Update link for OMAP spec",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/132",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "the domain seems to have gone stale",
      "createdAt": "2022-10-24T21:31:57Z",
      "updatedAt": "2022-10-24T21:32:40Z",
      "closedAt": "2022-10-24T21:32:39Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Done in 1ffa6f922384dc81b1f80a299af2053042ccd9f9",
          "createdAt": "2022-10-24T21:32:39Z",
          "updatedAt": "2022-10-24T21:32:39Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "I_kwDODkfq5s5VRa7V",
      "title": "Broader CORS recommendations",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/133",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "ietf-115"
      ],
      "body": "In a [recent commit](5f4d28a5b702346389f1f4bb3cc6044c15031981), I added a paragraph recommending supporting CORS on the token endpoint specifically, if expecting to be used by JS apps.\r\n\r\nA [recent discussion](https://bitbucket.org/openid/connect/issues/980/where-else-do-we-need-to-specify-the-use) in OpenID Connect also noted that it would be helpful to point out which endpoints might need to support CORS. \r\n\r\nWe should do something similar here, to point out endpoints in the core OAuth spec, and in known extensions, that might need CORS headers if used by SPAs. Additionally, it should be noted where it is _dangerous_ to add CORS support, such as the authorization endpoint.",
      "createdAt": "2022-10-31T23:35:31Z",
      "updatedAt": "2023-07-10T18:39:27Z",
      "closedAt": "2023-07-10T18:39:21Z",
      "comments": [
        {
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This's a good discussion, what's interesting is it has been open for a quite while (since 2015).\r\n\r\nI guess you referred to 5f4d28a5b702346389f1f4bb3cc6044c15031981 as one of the recent commits on this matter.",
          "createdAt": "2022-11-01T20:42:20Z",
          "updatedAt": "2022-11-01T20:42:20Z"
        },
        {
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The specification may recommend setting CORS policies per client_id + redirect_uri for the authorization endpoint when it's needed for JS clients. The main idea is not to just enable them globally for all the clients.\r\n\r\nThis should be possible to do because an AS knows what the client_id is (it's one of the parameters in the authorization request). It gets way trickier when it comes to other endpoints (such as the introspect or revocation endpoints), because of \"preflight\" requests, but I don't think it's completely impossible to do.",
          "createdAt": "2022-11-01T21:25:11Z",
          "updatedAt": "2022-11-01T21:25:11Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "At the very least, it seems the recommendations should be:\r\n\r\n* MUST NOT allow CORS requests at the authorization endpoint\r\n* To support JS apps, MUST support CORS requests at the token endpoint\r\n* Any other endpoints defined in extensions that the JS apps may need to call must also support CORS requests, such as AS metadata, revocation, JWK URLs, dynamic client registration, etc.\r\n",
          "createdAt": "2022-11-04T19:47:01Z",
          "updatedAt": "2022-11-04T19:47:01Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Need to sync this with the discussion that's happening with the Security BCP now.",
          "createdAt": "2023-03-13T22:35:46Z",
          "updatedAt": "2023-03-13T22:35:46Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Security BCP added CORS language here: https://github.com/oauthstuff/draft-ietf-oauth-security-topics/pull/78/files\r\n\r\nEnsure this text is in 2.1 but 2.1 can be more descriptive about it as well.",
          "createdAt": "2023-06-05T15:08:20Z",
          "updatedAt": "2023-06-05T15:08:20Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This was added in 7b398f740ac44626d19836f51a3b087e5d278c9b",
          "createdAt": "2023-07-10T18:39:21Z",
          "updatedAt": "2023-07-10T18:39:21Z"
        }
      ]
    },
    {
      "number": 134,
      "id": "I_kwDODkfq5s5YXKCO",
      "title": "Ambiguous text in Section 2.1",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/134",
      "state": "CLOSED",
      "author": "hosamaly",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The following text, which is under Section 2.1: Client Types, is ambiguous:\r\n\r\n> This might by the pre-requisite to use client policy and metadata in the course of processing this flow. \r\n\r\nSource: https://github.com/oauth-wg/oauth-v2-1/blob/52abd5ba65663d7dc7ffbd013f0d00e8964ccbce/draft-ietf-oauth-v2-1.md?plain=1#L653-L654",
      "createdAt": "2022-12-07T17:37:43Z",
      "updatedAt": "2023-01-25T01:18:09Z",
      "closedAt": "2023-01-25T01:18:09Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thank you, yes this is confusing. Will fix in the next revision.",
          "createdAt": "2022-12-07T22:19:16Z",
          "updatedAt": "2022-12-07T22:19:16Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "I_kwDODkfq5s5ajYM3",
      "title": "UNICODECHARNOCRLF no longer referenced in Syntax",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/135",
      "state": "CLOSED",
      "author": null,
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Presumably (unneeded) remnant from OAuth 2.0 specification for username/password syntax.",
      "createdAt": "2023-01-04T16:05:49Z",
      "updatedAt": "2023-07-10T18:37:56Z",
      "closedAt": "2023-07-10T18:37:25Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thank you!",
          "createdAt": "2023-07-10T18:37:48Z",
          "updatedAt": "2023-07-10T18:37:48Z"
        }
      ]
    },
    {
      "number": 136,
      "id": "I_kwDODkfq5s5cWrdI",
      "title": "Ensure Security BCP recommendations are all incorporated into 2.1",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/136",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-19T15:57:42Z",
      "updatedAt": "2024-03-21T22:51:10Z",
      "closedAt": "2024-03-21T22:51:10Z",
      "comments": [
        {
          "author": "danielfett",
          "authorAssociation": "MEMBER",
          "body": "Table for tracking the mapping: https://docs.google.com/spreadsheets/d/15NC1af2J9jMPqjPUxJgwMYjR-L_nSH-yqPvGHL_EZag/edit?usp=sharing",
          "createdAt": "2023-01-19T15:58:02Z",
          "updatedAt": "2023-01-19T15:58:02Z"
        },
        {
          "author": "danielfett",
          "authorAssociation": "MEMBER",
          "body": "Collecting new PRs in BCP that might be relevant for 2.1:\r\n\r\n* [x] 1. In-browser communication: https://github.com/oauthstuff/draft-ietf-oauth-security-topics/pull/64\r\n* [x] 2. Duplicate paragraph starting with \"However...\" in 4.10 and 4.16: https://github.com/oauthstuff/draft-ietf-oauth-security-topics/pull/65\r\n* [x] 3. Sender-constrained tokens too deeply nested: https://github.com/oauthstuff/draft-ietf-oauth-security-topics/pull/66\r\n* [x] 4. Mention CSRF token: https://github.com/oauthstuff/draft-ietf-oauth-security-topics/pull/67\r\n* [x] 5. Mention client TLS certificate headers: https://github.com/oauthstuff/draft-ietf-oauth-security-topics/pull/68",
          "createdAt": "2023-01-19T17:11:33Z",
          "updatedAt": "2023-06-12T15:05:55Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "* [x] https://github.com/oauthstuff/draft-ietf-oauth-security-topics/issues/70",
          "createdAt": "2023-01-25T00:52:28Z",
          "updatedAt": "2023-06-12T15:06:05Z"
        },
        {
          "author": "kmzs",
          "authorAssociation": "CONTRIBUTOR",
          "body": "- [x] Mix-up attack mitigations: #150 ",
          "createdAt": "2023-07-11T12:07:51Z",
          "updatedAt": "2024-03-21T22:51:05Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "I_kwDODkfq5s5dLRCV",
      "title": "Mark redirect_uri as a required parameter in the authorization request?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/137",
      "state": "CLOSED",
      "author": "vanbukin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'm trying to build an OAuth framework for .NET that supports OAuth 2.1 and OpenID Connect 1.0 and found that [OIDC requires `redirect_uri` in authorization request](https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.1.2.1), but in the current OAuth 2.1 draft it is marked as optional (and only required if the client has multiple pre-registered redirect URIs).\r\nMaybe it can be marked as required to simplify the logic for checking authorization requests on the side of the authorization server?",
      "createdAt": "2023-01-30T21:26:41Z",
      "updatedAt": "2023-06-27T20:17:42Z",
      "closedAt": "2023-06-27T20:17:42Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "That's interesting that OpenID Connect requires it. It's always been optional in OAuth 2.0 from the beginning https://www.rfc-editor.org/rfc/rfc6749#section-4.1.1 I don't think this is something we changed in OAuth 2.1",
          "createdAt": "2023-01-30T21:33:22Z",
          "updatedAt": "2023-01-30T21:33:22Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "I_kwDODkfq5s5gsg6E",
      "title": "Define \"explicit RO authentication\"",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/139",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "ietf-116"
      ],
      "body": "From RFC6749 Security Considerations\r\n\r\n> The authorization server SHOULD enforce explicit resource owner authentication and provide the resource owner with information about the client and the requested authorization scope and lifetime. It is up to the resource owner to review the information in the context of the current client and to authorize or deny the request.\r\n\r\nWhat does this mean in practice?\r\n* Is it a full credential prompt regardless of whether one session already exists? \r\n* A selection between existing sessions, if present?\r\n",
      "createdAt": "2023-03-13T21:20:11Z",
      "updatedAt": "2023-03-13T21:20:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 140,
      "id": "I_kwDODkfq5s5gshzl",
      "title": "Repeated authorization requests",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/140",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "ietf-116"
      ],
      "body": "From RFC6749 Security Considerations\r\n\r\n> The authorization server SHOULD NOT process repeated authorization\r\n> requests automatically (without active resource owner interaction)\r\n> without authenticating the client or relying on other measures to\r\n> ensure that the repeated request comes from the original client and\r\n> not an impersonator.\r\n\r\n(Vittorio) This is unclear. As it currently reads it seems to prohibit things like getting a new authz code silently via iframe (and prompt=none or equivalent UX suppressing mechanism, please ignore the ITP complications for the sake of argument). \r\n",
      "createdAt": "2023-03-13T21:23:02Z",
      "updatedAt": "2023-07-14T16:47:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "body": "I would say, the current practice is ok as long as there are alternative counter measures in place, e.g. if the AS is sure the code is only released to the legit owner of the client id because it controls the redirect URI.",
          "createdAt": "2023-07-14T16:30:58Z",
          "updatedAt": "2023-07-14T16:30:58Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "In OAuth 2.0, registration of the redirect URI was not required, which is why this paragraph is in here.\r\n\r\nNow that registration is required in OAuth 2.1, the concern of being redirected to arbitrary redirect URIs silently without user interaction is much less.",
          "createdAt": "2023-07-14T16:47:28Z",
          "updatedAt": "2023-07-14T16:47:28Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "I_kwDODkfq5s5gsm0_",
      "title": "Claimed https scheme as app identity proof",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/141",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback",
        "interim"
      ],
      "body": "From the \"[Impersonation of native apps](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-07#section-7.3.1)\" security considerations section:\r\n\r\n> Measures such as claimed https scheme redirects MAY be accepted by authorization servers as identity proof. Some operating systems may offer alternative platform-specific identity features that MAY be accepted, as appropriate.\r\n\r\nVittorio: I find this misleading. Client side measures such as claimed schemes, domains etc might work to prevent an app impersonating another app on the same device/OS, but they aren\u2019t guaranteed to be honored on other operating systems. The AS has no way of knowing whether those measures have been enforced on the client, hence it should not accept them as proof.\r\n\r\nAaron: I believe this was intended to allow the AS to skip the consent screen on repeated authorizations if the app is using a claimed https redirect URI vs a custom scheme. Would it be enough to clarify that this only applies to skipping the consent screen or other similar policies at the AS, but doesn't turn it into a confidential client?",
      "createdAt": "2023-03-13T21:39:10Z",
      "updatedAt": "2024-05-14T17:47:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "This is text that came from https://www.rfc-editor.org/rfc/rfc8252#section-8.6 and I agree that it's pretty odd text now it's been lifted out of that context.\r\n\r\n> Would it be enough to clarify that this only applies to skipping the consent screen or other similar policies at the AS, but doesn't turn it into a confidential client?\r\n\r\nI don't think that's entirely sufficient. As Vittorio noted there's no way for the AS to verify if the url is a claimed https scheme redirect, so this sentence isn't actually actionable:\r\n\r\n> Measures such as claimed https scheme redirects MAY be accepted by authorization servers as identity proof\r\n\r\nI don't know what to suggest. I think what this was trying to say was just a bit of a rewording of the text in https://www.rfc-editor.org/rfc/rfc6749#section-10.2 about using registered redirect urls but adding \"https urls are more trustable\", but that whole text about registered redirect urls seems not to be there in the equivalent place in OAuth 2.1: https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-10.html#section-7.3\r\n",
          "createdAt": "2024-05-14T17:47:37Z",
          "updatedAt": "2024-05-14T17:47:37Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "I_kwDODkfq5s5gs5B1",
      "title": "Native apps differences between mobile and desktop apps",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/142",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "draft-00-feedback"
      ],
      "body": "Much of Vittorio's feedback in the native apps section stems from the differences in practice of mobile apps and desktop apps. \r\n\r\nShould these recommendations be scoped to mobile apps now that we have more deployment experience since the Native Apps BCP was written? Do we all agree that the native apps recommendations are still valid?",
      "createdAt": "2023-03-13T22:34:57Z",
      "updatedAt": "2024-05-14T14:24:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This was discussed at IETF 116 and I believe the resolution was to ensure the language is in fact scoped to mobile apps, not desktop apps:\r\n\r\nhttps://datatracker.ietf.org/doc/minutes-116-oauth-202303310030/#differences-between-mobile-and-desktop-apps",
          "createdAt": "2024-05-14T14:24:46Z",
          "updatedAt": "2024-05-14T14:24:46Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "I_kwDODkfq5s5hJdVa",
      "title": "extension grants can allow unidentified clients",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/143",
      "state": "CLOSED",
      "author": "bc-pi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "ietf-116"
      ],
      "body": "I apologize in advance for this one... I really do. \r\n\r\nIt has always been my reading that OAuth 2.0 allows for client identification/authentication to be omitted in extension grants (if the grant type defines it that way), basically allowing (subject to policy and the grant type definition) token endpoint calls without any client identification in certain extension grant types  The text around this is admittedly somewhat ambiguous and hard to follow. And has some history to it. It could be argued that it's even open to different interpretations.  But allowing for unidentified clients in extension grants was my reading and it has been codified in RFCs 7521, 7522 & 7523 for SAML and JWT assertion grants with text like this in the grant definition (and examples with no client_id or any client auth).\r\n\r\n```\r\n  Authentication of the client is optional, as described in\r\n   Section 3.2.1 of OAuth 2.0 [RFC6749] and consequently, the\r\n   \"client_id\" is only needed when a form of client authentication that\r\n   relies on the parameter is used.\r\n```\r\n\r\nThis is some of the text from   Section 3.2.1  that it refers to:\r\n\r\n```\r\n   A client MAY use the \"client_id\" request parameter to identify itself\r\n   when sending requests to the token endpoint.  In the\r\n   \"authorization_code\" \"grant_type\" request to the token endpoint, an\r\n   unauthenticated client MUST send its \"client_id\" to prevent itself\r\n   from inadvertently accepting a code intended for a client with a\r\n   different \"client_id\".  This protects the client from substitution of\r\n   the authentication code.  (It provides no additional security for the\r\n   protected resource.)\r\n```\r\n\r\nrefs:\r\nhttps://www.rfc-editor.org/rfc/rfc7521#section-4.1\r\nhttps://www.rfc-editor.org/rfc/rfc7522#section-2.1\r\nhttps://www.rfc-editor.org/rfc/rfc7523#section-2.1\r\nhttps://www.rfc-editor.org/rfc/rfc6749?#section-3.2.1\r\nhttps://www.rfc-editor.org/rfc/rfc6749?#section-4.5\r\n\r\nAlso the pre-authorized_code grant being defined in OpenID for Verifiable Credential Issuance is another extension grant type that needs to allow for use by unidentified /anonymous clients. https://openid.net/specs/openid-4-verifiable-credential-issuance-1_0-11.html#name-token-request\r\n\r\nI think the text for \"client_id\" in https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-08.html#section-3.2.2 precludes the above cases (because it is for all token endpoint requests in 2.1 but came from the code grant in 2.0 https://www.rfc-editor.org/rfc/rfc6749?#section-4.1.3 ). \r\n\r\nIt's ugly and hard to capture the subtly here but maybe something like this instead for client_id in the Token Request section of v2.1?: \r\n \r\n```\r\n  \"client_id\":    \r\n    REQUIRED, if the client is not authenticating with the authorization server as described\r\n     in Section 3.2.1. and the grant_type requires client identification.\r\n```\r\n\r\nor:\r\n\r\n \r\n```\r\n  \"client_id\":    \r\n    REQUIRED, unless the client is authenticating with the authorization server as described\r\n     in Section 3.2.1. or the grant_type allows for unidentified clients.\r\n```\r\n\r\nor maybe:\r\n\r\n```\r\n  \"client_id\":    \r\n    OPTIONAL.  The client identifier is needed when a form of client authentication that\r\n   relies on the parameter is used or the grant_type requires identification of public clients. \r\n```\r\n\r\nor something better but in the spirt thereof. \r\n\r\n\r\nAlso maybe adding that ` \"client_id\":  REQUIRED, if the client is not authenticating with the authorization server as described in Section 3.2.1.` text to the authz code grant section https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-08.html#section-4.1.3 to be explicit like w/ v2.0 that client_id is needed in code grant for public clients.\r\n \r\n\r\n\r\n",
      "createdAt": "2023-03-17T19:59:25Z",
      "updatedAt": "2024-11-15T16:02:14Z",
      "closedAt": "2024-11-15T16:02:14Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Seems reasonable to me. We added it to the agenda for IETF 116.",
          "createdAt": "2023-03-27T07:35:16Z",
          "updatedAt": "2023-03-27T07:35:16Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "I_kwDODkfq5s5h1uuA",
      "title": "There is a broken link in draft 08.",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/144",
      "state": "CLOSED",
      "author": "kg0r0",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The following link appears to be broken.\r\n\r\nhttps://github.com/kg0r0/oauth-v2-1/blob/d384ca05d63bbce47b8f53699d6755dba5d3374b/draft-ietf-oauth-v2-1.md?plain=1#L1846\r\n\r\nI have confirmed that the link works correctly by fixing ``(#refresh-token-endpoint-extension)`` to ``{{refresh-token-endpoint-extension}}``.",
      "createdAt": "2023-03-27T06:36:56Z",
      "updatedAt": "2023-03-27T07:18:23Z",
      "closedAt": "2023-03-27T07:18:23Z",
      "comments": []
    },
    {
      "number": 146,
      "id": "I_kwDODkfq5s5lbHhH",
      "title": "Prohibition of using OAuth for user authentication",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/146",
      "state": "CLOSED",
      "author": "ritou",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Despite the specification explicitly stating \"This is an Authorization Framework\" as of OAuth 2.0, some Authorization Server/Resource Server and many Client developers have been using this for the purpose of user authentication. In order to avoid the occurrence of vulnerabilities and the lack of interoperability, I hope to include the following sentences:\r\n\r\n- Clients should not (or must not) implement user authentication functionality using this framework.\r\n- If an Authorization server wants to provide user authentication functionality to a Client, it should refer to the expanded OIDC specification for that purpose.",
      "createdAt": "2023-05-09T08:32:14Z",
      "updatedAt": "2024-11-20T15:24:36Z",
      "closedAt": "2024-11-20T15:24:36Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This paragraph is new in OAuth 2.1 which clarifies the details https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-12.html#section-1-7",
          "createdAt": "2024-11-20T15:24:36Z",
          "updatedAt": "2024-11-20T15:24:36Z"
        }
      ]
    },
    {
      "number": 149,
      "id": "I_kwDODkfq5s5oexzQ",
      "title": "Update DPoP references to RFC 9449",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/149",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "",
      "createdAt": "2023-06-12T14:29:18Z",
      "updatedAt": "2024-01-09T23:08:19Z",
      "closedAt": "2024-01-09T21:30:49Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "DPoP is now RFC 9449!",
          "createdAt": "2023-09-08T14:56:57Z",
          "updatedAt": "2023-09-08T14:56:57Z"
        }
      ]
    },
    {
      "number": 151,
      "id": "I_kwDODkfq5s5rmCns",
      "title": "point implementers to OIDC in intro",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/151",
      "state": "CLOSED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-14T16:18:15Z",
      "updatedAt": "2025-03-16T08:11:36Z",
      "closedAt": "2025-03-16T08:11:36Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@aaronpk remind me what we were going to do here?",
          "createdAt": "2024-12-04T12:21:11Z",
          "updatedAt": "2024-12-04T12:21:11Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I think the idea was to at least mention that OIDC exists as a common extension of OAuth that is useful for user authentication",
          "createdAt": "2024-12-04T13:48:22Z",
          "updatedAt": "2024-12-04T13:48:22Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Update this paragraph:\r\n\r\n> OAuth is an authorization protocol, and is not an authentication protocol. The access token represents the authorization granted to the client. It is a common practice for the client to present the access token to a proprietary API which returns a user identifier for the resource owner, and then using the result of the API as a proxy for authenticating the user. This practice is not part of the OAuth standard or security considerations, and may not have been considered by the resource owner. Implementors should carefully consult the documentation of the resource server before adopting this practice.",
          "createdAt": "2024-12-04T15:04:54Z",
          "updatedAt": "2024-12-04T15:04:54Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "OAuth is not authentication -- refer to OIDC for auth",
          "createdAt": "2024-12-04T15:04:56Z",
          "updatedAt": "2024-12-04T15:05:19Z"
        }
      ]
    },
    {
      "number": 152,
      "id": "I_kwDODkfq5s5rmLuZ",
      "title": "clarify last paragraph of 8.4.1",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/152",
      "state": "CLOSED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "If the app can claim and own a URI on a platform, it MUST use that mechanism ",
      "createdAt": "2023-07-14T16:48:41Z",
      "updatedAt": "2024-11-20T15:54:58Z",
      "closedAt": "2024-11-20T15:54:54Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Editor's call, agreed to close with no changes",
          "createdAt": "2024-11-20T15:54:54Z",
          "updatedAt": "2024-11-20T15:54:54Z"
        }
      ]
    },
    {
      "number": 153,
      "id": "I_kwDODkfq5s5sL-7r",
      "title": "Bad http message example format in 7.11. Clickjacking section",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/153",
      "state": "CLOSED",
      "author": "DevDengChao",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-09#name-clickjacking\r\n\r\n![image](https://github.com/oauth-wg/oauth-v2-1/assets/16363180/415bbb29-b5e8-4748-a46f-150c5349a272)\r\n",
      "createdAt": "2023-07-21T03:03:07Z",
      "updatedAt": "2024-01-09T23:08:06Z",
      "closedAt": "2023-07-21T17:01:05Z",
      "comments": []
    },
    {
      "number": 156,
      "id": "I_kwDODkfq5s5sRL5O",
      "title": "Ask for review from HTTP WG",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/156",
      "state": "OPEN",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-21T22:28:16Z",
      "updatedAt": "2024-11-04T12:12:51Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 157,
      "id": "I_kwDODkfq5s5sS0Zf",
      "title": "OAuth 2.1 + OIDC: The implicit flow grant type is indeed mandatory to support the Hybrid flow.",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/157",
      "state": "CLOSED",
      "author": "vanbukin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "wontfix"
      ],
      "body": "[According to the OpenID Connect Core 1.0 incorporating errata set 1 specification](https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3), for the Hybrid Flow, the `response_type` parameter should be set to `\"code id_token\"`. However, based on the [OpenID Connect Dynamic Client Registration 1.0 incorporating errata set 1](https://openid.net/specs/openid-connect-registration-1_0.html#rfc.section.2) specification, if a client is registered with this response_type, its grant_types should be `\"authorization_code\"` and `\"implicit\"`. \r\nPlease note that the Implicit Flow has been removed in OAuth 2.1. \r\nI am trying to create a provider that simultaneously supports OAuth 2.1 and OpenID Connect 1.0 but without OAuth 2.0 support, specifically excluding the Implicit Flow and ROCF. \r\nI see a contradiction between these specifications, and I'm not sure where to turn for guidance. \r\nHow can I proceed to support hybrid flow without using the implicit grant type?",
      "createdAt": "2023-07-22T19:34:23Z",
      "updatedAt": "2024-01-09T23:07:50Z",
      "closedAt": "2023-07-27T15:14:34Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Implicit is no longer part of authorization flows, and is not defined in OAuth 2.1. \r\n\r\nWhen OpenID Connect is updated to refer to OAuth 2.1, it should should define the implicit flow as an authentication flow that returns only an ID token.\r\n\r\nWhat OAuth 2.1 doesn't define is how to use the implicit flow to get an access token, and that is also explicitly prohibited in the Security BCP. However there's nothing stopping you from using the implicit flow to get an ID token, it's just not defined in OAuth 2.1. So you can continue to use the implicit flow as defined in OAuth 2.0 to get an ID token, and not be in violation of OAuth 2.1.",
          "createdAt": "2023-07-27T15:14:34Z",
          "updatedAt": "2023-07-27T15:14:34Z"
        }
      ]
    },
    {
      "number": 158,
      "id": "I_kwDODkfq5s5sY4XQ",
      "title": "GPG based authentication",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/158",
      "state": "CLOSED",
      "author": null,
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "invalid"
      ],
      "body": "Hello!\r\n\r\nI think that most part of current authorization methods have a problem - they require user to register an account with specific password at least in one service. This service can further be used as an authentication server for other services. That is nice, that users do not have to share their password between different services (as of what i understand, the problem which is solved with OAuth), but having an account in specific service should not be a requirement.\r\n\r\nCryptography and GPG allows users to send their identity to public server, and then verify their packages/messages/data with digital signatures. This approach can be extended/reused as authorization/authontication mechanism, which will allow user to verify their identity with GPG, instead of creating an account in specific service. This will also reduce the headache of connecting lots of different authorization services, since there would be a unified auth approach, which is not tied to specific authorization server.\r\n\r\nCurrently OAuth spec has [http signatures](https://oauth.net/http-signatures/) draft, which allows to sign/verify message with ssh-keys. This should also be possible to GPG for authorization and message verification.",
      "createdAt": "2023-07-24T13:44:24Z",
      "updatedAt": "2024-01-09T23:07:37Z",
      "closedAt": "2023-07-24T13:47:23Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "The reference to HTTP Signatures is for client authentication, not user authentication. User authentication is out of scope of the core OAuth spec.",
          "createdAt": "2023-07-24T13:47:22Z",
          "updatedAt": "2023-07-24T13:47:22Z"
        }
      ]
    },
    {
      "number": 159,
      "id": "I_kwDODkfq5s5swh0v",
      "title": "Define \"scope\" higher up in the doc",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/159",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-07-27T15:47:25Z",
      "updatedAt": "2023-08-20T13:12:02Z",
      "closedAt": "2023-08-20T13:12:01Z",
      "comments": []
    },
    {
      "number": 160,
      "id": "I_kwDODkfq5s5syuu_",
      "title": "Strengthen \"Authorization server SHOULD NOT process repeated authorization requests automatically\" for public clients",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/160",
      "state": "OPEN",
      "author": "hickford",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-09#name-client-impersonation\r\n\r\n> The authorization server SHOULD NOT process repeated authorization requests automatically (without active resource owner interaction) without authenticating the client or relying on other measures to ensure that the repeated request comes from the original client and not an impersonator.\r\n\r\nHow about strengthening this for public clients to MUST NOT? ",
      "createdAt": "2023-07-27T21:12:18Z",
      "updatedAt": "2023-07-27T21:13:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hickford",
          "authorAssociation": "NONE",
          "body": "Mailing list discussion https://mailarchive.ietf.org/arch/msg/oauth/P3snfqtO2Seb8iAYX8rRRu-16Aw/\r\n\r\n> Does anyone know why this is only SHOULD NOT? For public clients, how about strengthening it to MUST NOT?  How else can the authorization server ensure the request comes from the original client, not an impersonator?\r\n",
          "createdAt": "2023-07-27T21:13:43Z",
          "updatedAt": "2023-07-27T21:13:52Z"
        }
      ]
    },
    {
      "number": 161,
      "id": "I_kwDODkfq5s5syzh8",
      "title": "Problems with authorization servers that don't support public clients",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/161",
      "state": "OPEN",
      "author": "hickford",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-09.html\r\n\r\n> Authorization servers MUST record the client type in the client registration details in order to identify and process requests accordingly\r\n\r\nUnfortunately many authorization servers *don't* record client type. Some authorization servers explicitly say that they don't support public clients. Is this okay? Banning public clients tempts app developers to bend the rules and register a public client as a confidential client, compromising security. \r\n\r\nSourceHut bans public clients https://man.sr.ht/meta.sr.ht/oauth.md\r\n\r\n> Only confidential clients are supported; public clients are not allowed\r\n\r\nAzure DevOps bans public clients https://learn.microsoft.com/en-us/azure/devops/integrate/get-started/authentication/azure-devops-oauth?view=azure-devops\r\n\r\n> Can I use OAuth with my mobile phone app? No. Azure DevOps Services only supports the web server flow... as [public clients] can't securely store the app secret.\r\n\r\nGitHub doesn't record client type but seems to deduce it based on redirect URI https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/creating-an-oauth-app\r\n",
      "createdAt": "2023-07-27T21:32:29Z",
      "updatedAt": "2024-11-20T15:19:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hickford",
          "authorAssociation": "NONE",
          "body": "Mailing list discussion https://mailarchive.ietf.org/arch/msg/oauth/iJ6WAbJzHWiGmaFO-qAzg30B_28/\n\n> Such servers typically assume all clients to be confidential, neglecting security measures appropriate for public clients.",
          "createdAt": "2023-07-27T21:35:21Z",
          "updatedAt": "2023-07-27T21:49:28Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I don't think there is any requirement in the spec that an AS has to support both types of clients, did you see any language to the contrary?",
          "createdAt": "2024-05-11T00:58:09Z",
          "updatedAt": "2024-05-11T00:58:09Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Add an explicit mention in https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-12.html#section-2.1 that an AS doesn't have to support public clients.",
          "createdAt": "2024-11-20T15:19:48Z",
          "updatedAt": "2024-11-20T15:19:48Z"
        }
      ]
    },
    {
      "number": 162,
      "id": "I_kwDODkfq5s5tghbb",
      "title": "the invalid_client error and HTTP authentication schemas",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/162",
      "state": "OPEN",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "interim"
      ],
      "body": "https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-09#section-3.2.3.1 says that\r\n\r\n> \"**invalid_client**\":  Client authentication failed (e.g., unknown client, no client authentication included, or unsupported authentication method). The authorization server MAY return an HTTP 401 (Unauthorized) status code to indicate which HTTP authentication schemes are supported.\r\n\r\nI am not so sure if it's possible to indicate HTTP authentication schemas for _private_key_jwt_ and _client_secret_jwt_ client authentication types.\r\n\r\nThis text also indicates that multiple authentication schemas are supported. Thus, does the authorization server need to specify multiple WWW-Authenticate headers, say \"WWW-Authenticate: Basic\" and \"WWW-Authenticate: Bearer\"?\r\n\r\nIt would be great to clarify these nuances.\r\n",
      "createdAt": "2023-08-04T19:31:16Z",
      "updatedAt": "2025-03-24T09:54:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "I'm honestly not sure how much useful behaviour can really be dictated about `invalid_client` errors.\r\n\r\nI wonder if there are any clients that attempt to parse the WWW-Authenticate header and try a different authentication mechanism? The clients I'm aware of all require the client authentication to be explicitly configured.",
          "createdAt": "2024-05-14T17:52:08Z",
          "updatedAt": "2024-05-14T17:52:08Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "> I wonder if there are any clients that attempt to parse the WWW-Authenticate header and try a different authentication mechanism? The clients I'm aware of all require the client authentication to be explicitly configured.\n\nI concur.",
          "createdAt": "2025-03-24T09:54:56Z",
          "updatedAt": "2025-03-24T09:54:56Z"
        }
      ]
    },
    {
      "number": 163,
      "id": "I_kwDODkfq5s5uXS_5",
      "title": "Scope in relation to OIDC",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/163",
      "state": "CLOSED",
      "author": "arukiidou",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "interim"
      ],
      "body": "- relates #151\r\n\r\n## Summary of proposal\r\n\r\nAdd the following description to https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-09#access-token-scope\r\n\r\nThe authorization server SHOULD NOT define different content with the same scope name as an OIDC defined claim, even if it does not implement the OIDC specification.\r\n\r\n## Why?\r\n\r\n- Interoperability with OIDC specifications as much as possible\r\n- If client could implicitly expect the request content from the scope name, do not mislead\r\n\r\n## Example\r\n\r\n### \u2705Its OK.\r\n\r\n| scope           | description             |\r\n|------------------------|-----------------------------------------------|\r\n|    openid     |  REQUIRED. for all OpenID Connect OAuth2 requests.   | \r\n|    profile     |  OPTIONAL. This scope value requests access to the End-User's default profile Claims, which are: name, family_name, given_name, middle_name, nickname, preferred_username, profile, picture, website, gender, birthdate, zoneinfo, locale, and updated_at.   | \r\n| email          |  OPTIONAL. This scope value requests access to the email and email_verified Claims.  | \r\n| address         |  OPTIONAL. This scope value requests access to the address Claim.   | \r\n| phone         |  OPTIONAL. This scope value requests access to the phone_number and phone_number_verified Claims.   | \r\n\r\n### \u2705not OIDC, but Its also OK( as OAuth2.1).\r\n\r\nNot having a scope defined in the OIDC specification is permitted.\r\n\r\n| scope           | description             |\r\n|------------------------|-----------------------------------------------|\r\n| profile         |  OPTIONAL. This scope value requests access to the End-User's default profile Claims, which are: name, family_name, given_name, middle_name, nickname, preferred_username, profile, picture, website, gender, birthdate, zoneinfo, locale, and updated_at.   | \r\n| address         |  OPTIONAL. This scope value requests access to the address Claim.   | \r\n\r\n### \u2705not OIDC, but Its also OK( as OAuth2.1).\r\n\r\n| scope           | description             |\r\n|------------------------|-----------------------------------------------|\r\n| profile         |  OPTIONAL. This scope value requests access to the End-User's default profile Claims, which are: name, family_name, given_name, middle_name, nickname, preferred_username, profile, picture, website, gender, birthdate, zoneinfo, locale, and updated_at.   | \r\n| read_registry         |  OPTIONAL. This scope value requests access to the package registry. | \r\n\r\n### \u274c SHOULD NOT - Do not attempt to request access to an email claim by informing the client of the address scope\r\n\r\n| scope           | description             |\r\n|------------------------|-----------------------------------------------|\r\n| profile         |  OPTIONAL. This scope value requests access to the End-User's default profile Claims, which are: name, family_name, given_name, middle_name, nickname, preferred_username, profile, picture, website, gender, birthdate, zoneinfo, locale, and updated_at.   | \r\n| address |   OPTIONAL. This scope value requests access to the email-address Claim.   | \r\n\r\n### References: OpenID Connect Core 1.0 Spec \r\n\r\nhttps://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims\r\n",
      "createdAt": "2023-08-15T15:04:03Z",
      "updatedAt": "2024-05-14T20:57:23Z",
      "closedAt": "2024-05-14T20:57:23Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "As discussed in the May 14 interim:\r\n\r\nResolved to adding a mention of OpenID scopes, and language that (lowercase) recommends not defining conflicting scopes. However, OpenID is not the only OAuth extension that defines scopes. People were not comfortable with \"SHOULD NOT\" language restricting defining scopes with meanings in other specs that are not implemented by the AS, as that's impossible to comply with.",
          "createdAt": "2024-05-14T17:04:55Z",
          "updatedAt": "2024-05-14T17:04:55Z"
        }
      ]
    },
    {
      "number": 164,
      "id": "I_kwDODkfq5s5vJOhS",
      "title": "Use of 'permissions' term in refresh token section",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/164",
      "state": "CLOSED",
      "author": "jogu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-09.html#section-1.3.2 says:\r\n\r\n> access tokens may have a shorter lifetime and fewer permissions than authorized by the resource owner\r\n\r\nI've recently had some in depth conversations about what \"permissions\" here means. This is the only use of 'permissions' [in this way] in the whole document, and I don't think there's some special thing that's different in the refresh token grant that means we should be using a different word. I think it might be a small improvement to use the same terms as used elsewhere in the document - other words that are already used are \"access range\", \"scopes\", \"scope-token\" and \"privileges\".\r\n\r\nChanging \"permissions\" to \"privileges\" seems like it would probably be the most consistent with the rest of the spec.",
      "createdAt": "2023-08-24T08:43:05Z",
      "updatedAt": "2024-01-09T23:10:46Z",
      "closedAt": "2024-01-09T23:10:29Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Agreed, I think that's an easy fix. \"privileges\" is used in a lot of other places already.",
          "createdAt": "2024-01-09T23:10:44Z",
          "updatedAt": "2024-01-09T23:10:44Z"
        }
      ]
    },
    {
      "number": 165,
      "id": "I_kwDODkfq5s5w-RJE",
      "title": "native clients",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/165",
      "state": "CLOSED",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "[Section \"2.3.1.  Registration Requirements\"](https://drafts.oauth.net/oauth-v2-1/draft-ietf-oauth-v2-1.html#section-2.3.1) says that\r\n\r\n> Authorization servers MUST reject authorization requests that specify a redirect URI that doesn't exactly match one that was registered, with an exception for loopback redirects, where an exact match is required except for the port URI component, see Section 4.1.1 for details.\r\n\r\nHowever, https://drafts.oauth.net/oauth-v2-1/draft-ietf-oauth-v2-1.html#section-4.1.1 redirects me back\r\n> \"redirect_uri\": OPTIONAL. As described in [Section 2.3](https://drafts.oauth.net/oauth-v2-1/draft-ietf-oauth-v2-1.html#redirection-endpoint).\r\n\r\nand doesn't mention any nuances with redirect URIs for native clients.\r\n\r\n> When comparing the two URIs the authorization server MUST ensure that the two URIs are equal, see RFC3986, Section 6.2.1, Simple String Comparison, for details.\r\n\r\nIt might be worth clarifying these details. Hence, this issue.",
      "createdAt": "2023-09-13T22:58:20Z",
      "updatedAt": "2024-01-09T23:08:27Z",
      "closedAt": "2024-01-09T23:06:24Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I'm not sure what this has to do with native clients, but I agree it was not very clear. I made it much more explicit in both sections 4.1.1 and 2.3 about when this is required or optional, hope that helps!",
          "createdAt": "2024-01-09T23:07:00Z",
          "updatedAt": "2024-01-09T23:07:00Z"
        }
      ]
    },
    {
      "number": 166,
      "id": "I_kwDODkfq5s58wpwE",
      "title": "case sensitivity of Bearer http authentication scheme",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/166",
      "state": "CLOSED",
      "author": "jogu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It seems to be a common interoperability issue (and a source of some really great arguments as to who is wrong, e.g. https://github.com/fastify/fastify-bearer-auth/pull/172#issuecomment-1903321866 ) that some implementations treat the 'Bearer' http authentication scheme name as case sensitive.\r\n\r\nAs far as I can find, HTTP authentication schemes are case insensitive; in particular https://www.rfc-editor.org/rfc/rfc9110#name-authentication-scheme says:\r\n\r\n> It uses a case-insensitive token to identify the authentication scheme:\r\n\r\nRegardless of whether my conclusion is correct, I think we should add a sentence to OAuth 2.1 that makes it clear if it is case sensitive or not.\r\n",
      "createdAt": "2024-01-22T05:43:22Z",
      "updatedAt": "2024-05-14T20:57:22Z",
      "closedAt": "2024-05-14T20:57:22Z",
      "comments": [
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "I think people often get confused by https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-10#section-5.1.1 in particular:\r\n\r\n> credentials = \"Bearer\" 1*SP token68\r\n\r\nso this might be a good place to add an additional sentence. (As per https://www.rfc-editor.org/rfc/rfc5234#section-2.3 I believe this is defining 'Bearer' as a case insensitive match.)",
          "createdAt": "2024-01-22T06:39:55Z",
          "updatedAt": "2024-01-22T06:39:55Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Should we update the abnf description to use lowercase too then just for good measure?",
          "createdAt": "2024-05-11T01:22:17Z",
          "updatedAt": "2024-05-11T01:22:17Z"
        },
        {
          "author": "jogu",
          "authorAssociation": "NONE",
          "body": "Good question and I don't really know if there's any precedent here. \"Bearer\" is the official name as per https://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml#authschemes but I'm not sure that matters.",
          "createdAt": "2024-05-11T11:41:07Z",
          "updatedAt": "2024-05-11T11:41:07Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "As discussed in the May 14 interim:\r\n\r\nKeep the examples with the capital B, and add a sentence clarifying that the scheme is case insensitive.",
          "createdAt": "2024-05-14T17:03:16Z",
          "updatedAt": "2024-05-14T17:03:16Z"
        }
      ]
    },
    {
      "number": 167,
      "id": "I_kwDODkfq5s58166G",
      "title": "Character encoding for the application/x-www-form-urlencoded format",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/167",
      "state": "OPEN",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "Section 3.2.2 Tokens states that\r\n\r\n> The client makes a request to the token endpoint by sending the\r\n> following parameters using the application/x-www-form-urlencoded\r\n> format per Appendix B with a character encoding of UTF-8 in the HTTP\r\n> request content:\r\n\r\nHowever, the following example does not include UTF-8 as character encoding\r\n\r\n> POST /token HTTP/1.1\r\n> Host: server.example.com\r\n> Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\r\n> Content-Type: application/x-www-form-urlencoded\r\n\r\nit should look like as\r\n\r\n> POST /token HTTP/1.1\r\n> Host: server.example.com\r\n> Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\r\n> Content-Type: application/x-www-form-urlencoded; charset=UTF-8; \r\n\r\nthe same applies for all other similar examples in the spec.\r\n\r\nHow is this important? In some (rare) cases, it can lead to interoperability issues as app servers & frameworks that run an AS do not necessarily use \"UTF-8\" as a default encoding character, as an example, Java Servlets use \"ISO-8859-1\". So, it is better for a client to always specify the character explicitly. \r\n",
      "createdAt": "2024-01-22T18:32:47Z",
      "updatedAt": "2024-11-15T15:45:40Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "From what I can tell, the `application/x-www-form-urlencoded` content type implies UTF-8 encoding, so it is not needed to include the `charset`.\r\n\r\nhttps://url.spec.whatwg.org/#application/x-www-form-urlencoded\r\n\r\nhttps://url.spec.whatwg.org/#application/x-www-form-urlencoded",
          "createdAt": "2024-11-15T15:45:39Z",
          "updatedAt": "2024-11-15T15:45:39Z"
        }
      ]
    },
    {
      "number": 168,
      "id": "I_kwDODkfq5s6Aoxnc",
      "title": "\"Suprising\" printing service example in introduction",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/168",
      "state": "CLOSED",
      "author": "SECtim",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The printing service example in the introduction (just after the list of disadvantages of the client-server authentication model) comes somewhat as a surprise.\r\n\r\nhttps://github.com/oauth-wg/oauth-v2-1/blob/f79f58841f717b0e6050da663c4a858bc100fda1/draft-ietf-oauth-v2-1.md?plain=1#L236-L242\r\n\r\nI guess this could easily be fixed by adding a \"For example, \".",
      "createdAt": "2024-02-28T05:50:35Z",
      "updatedAt": "2025-01-09T17:21:09Z",
      "closedAt": "2025-01-09T17:21:09Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Resolved by #204 ",
          "createdAt": "2025-01-09T17:21:09Z",
          "updatedAt": "2025-01-09T17:21:09Z"
        }
      ]
    },
    {
      "number": 169,
      "id": "I_kwDODkfq5s6AqD-N",
      "title": "Terminology: \"relying party\" vs. \"client\"",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/169",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "editorial"
      ],
      "body": "In some places, the term \"relying party\" is used instead of \"client\":\r\n\r\nhttps://github.com/oauth-wg/oauth-v2-1/blob/f79f58841f717b0e6050da663c4a858bc100fda1/draft-ietf-oauth-v2-1.md?plain=1#L2820-L2822\r\n\r\nhttps://github.com/oauth-wg/oauth-v2-1/blob/f79f58841f717b0e6050da663c4a858bc100fda1/draft-ietf-oauth-v2-1.md?plain=1#L2578-L2582",
      "createdAt": "2024-02-28T09:33:25Z",
      "updatedAt": "2024-11-15T17:49:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "@dickhardt this sentence is from RFC6750, but the terminology seems to conflict with modern uses of \"audience restricted access tokens\". Do you remember what this was intended to mean?\r\n\r\n>    Issue scoped bearer tokens:  Token servers SHOULD issue bearer tokens\r\n>     that contain an audience restriction, scoping their use to the\r\n>     intended relying party or set of relying parties.\r\n",
          "createdAt": "2024-11-15T15:42:28Z",
          "updatedAt": "2024-11-15T15:42:28Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "In practice this is the 'aud' claim in a JWT -- but since 6750 does not specify a token format, this is guidance that the token should indicate who the audience is \r\n\r\nThe phrase \"issue scoped bearer tokens\" is confusing as it is conflating scopes with audience \r\n\r\nCan you point me to what you mean by 'modern uses of \"audience restricted access tokens\"'",
          "createdAt": "2024-11-15T17:47:33Z",
          "updatedAt": "2024-11-15T17:47:33Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Also, In the case of 6750 as this is an access token, `replying party` is referring to the resource server, not the `client`. ",
          "createdAt": "2024-11-15T17:49:50Z",
          "updatedAt": "2024-11-15T17:49:50Z"
        }
      ]
    },
    {
      "number": 170,
      "id": "I_kwDODkfq5s6AqIab",
      "title": "Ambigious text around whether `code_challenge` is required",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/170",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The following text snippets seem like a `code_challenge` is always required in the authorization request (for authZ code flows).\r\n\r\nDescription of the authZ code flow figure:\r\nhttps://github.com/oauth-wg/oauth-v2-1/blob/f79f58841f717b0e6050da663c4a858bc100fda1/draft-ietf-oauth-v2-1.md?plain=1#L1468-L1470\r\n\r\nhttps://github.com/oauth-wg/oauth-v2-1/blob/f79f58841f717b0e6050da663c4a858bc100fda1/draft-ietf-oauth-v2-1.md?plain=1#L1485-L1487\r\n\r\nhttps://github.com/oauth-wg/oauth-v2-1/blob/f79f58841f717b0e6050da663c4a858bc100fda1/draft-ietf-oauth-v2-1.md?plain=1#L1493-L1494\r\n\r\nSection 4.3.1:\r\nhttps://github.com/oauth-wg/oauth-v2-1/blob/f79f58841f717b0e6050da663c4a858bc100fda1/draft-ietf-oauth-v2-1.md?plain=1#L1863-L1865\r\n\r\nWhereas various other places, most prominently Section 7.5.2, state that `code_challenge` is (only) required _unless_ some conditions are met:\r\n\r\nhttps://github.com/oauth-wg/oauth-v2-1/blob/f79f58841f717b0e6050da663c4a858bc100fda1/draft-ietf-oauth-v2-1.md?plain=1#L2743-L2750",
      "createdAt": "2024-02-28T09:42:36Z",
      "updatedAt": "2024-05-21T07:23:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This specific carve-out for the nonce protection is really an edge case, which could probably be made even more explicit. It is not meant to be the common case, which is why the narrative text describes the use of `code_challenge`. I could borrow some more language from the security BCP that talks about the specific conditions in which it's okay to use the nonce from here if that would make it more clear: https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#section-4.5.3.2",
          "createdAt": "2024-05-11T01:19:27Z",
          "updatedAt": "2024-05-11T01:19:27Z"
        },
        {
          "author": "SECtim",
          "authorAssociation": "NONE",
          "body": "In that case, my take would be to be very explicit in Section 7.5.2 about this being an edge case. And maybe add some sentence saying ASs are still recommended to require `code_challenge` and `code_verifier` even if these conditions are met.",
          "createdAt": "2024-05-21T07:23:15Z",
          "updatedAt": "2024-05-21T07:23:15Z"
        }
      ]
    },
    {
      "number": 171,
      "id": "I_kwDODkfq5s6AqOxG",
      "title": "Handling of colliding URI query parameter names",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/171",
      "state": "OPEN",
      "author": "SECtim",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The URIs for the **redirect** and **authorization** endpoints may contain additional query parameters that must be retained when adding more parameters:\r\nhttps://github.com/oauth-wg/oauth-v2-1/blob/f79f58841f717b0e6050da663c4a858bc100fda1/draft-ietf-oauth-v2-1.md?plain=1#L860-L865\r\nhttps://github.com/oauth-wg/oauth-v2-1/blob/f79f58841f717b0e6050da663c4a858bc100fda1/draft-ietf-oauth-v2-1.md?plain=1#L1118-L1121\r\n\r\nFurthermore, query parameters must only appear once (this text appears in the description of the authorization and token endpoints, but is not explicitly mentioned for the redirection endpoint - nevertheless, the cited text already applies to all parameters defined by this spec):\r\nhttps://github.com/oauth-wg/oauth-v2-1/blob/f79f58841f717b0e6050da663c4a858bc100fda1/draft-ietf-oauth-v2-1.md?plain=1#L1129-L1130\r\n\r\nThis becomes a problem in (I admit, somewhat esoteric) cases where the endpoint URIs contain parameters such as `code` in a redirect URI, in that example, the AS would not be allowed to add its `code` parameter in the authorization response. But at the same time, the AS is required to do so:\r\nhttps://github.com/oauth-wg/oauth-v2-1/blob/f79f58841f717b0e6050da663c4a858bc100fda1/draft-ietf-oauth-v2-1.md?plain=1#L1657-L1664\r\n\r\nI guess this is just a case of adding something like \"redirect URI MUST NOT contain the parameters...\".",
      "createdAt": "2024-02-28T09:54:55Z",
      "updatedAt": "2024-11-20T15:15:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I believe this is the same as https://github.com/oauthstuff/draft-ietf-oauth-security-topics/issues/72, where did we land on language around this @danielfett?",
          "createdAt": "2024-05-11T00:43:48Z",
          "updatedAt": "2024-05-11T00:43:48Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Something like \"You MUST avoid using names in the parameters registry for the endpoint in question https://www.iana.org/assignments/oauth-parameters/oauth-parameters.xhtml#parameters\"",
          "createdAt": "2024-11-20T15:14:17Z",
          "updatedAt": "2024-11-20T15:14:17Z"
        }
      ]
    },
    {
      "number": 174,
      "id": "I_kwDODkfq5s6FovuN",
      "title": "Strict JavaScript Exclusiveness?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/174",
      "state": "OPEN",
      "author": "MozharAlhosni",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Under [Token Endpoint](https://github.com/oauth-wg/oauth-v2-1/blob/main/draft-ietf-oauth-v2-1.md#token-endpoint), it states:\r\n\r\n> Authorization servers that wish to support browser-based applications (applications running exclusively in client-side JavaScript without access to a supporting backend server)\r\n\r\nHowever, the sentence \"running exclusively in client-side JavaScript\" imposes strict exclusiveness, regardless that these client-side browser-based applications may be running [WebAssembly](https://webassembly.org/) (for example, like Blazor WebAssembly web applications).",
      "createdAt": "2024-04-14T08:52:37Z",
      "updatedAt": "2024-04-14T09:02:03Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 176,
      "id": "I_kwDODkfq5s6I7bVX",
      "title": "Allow public clients to use the `client_credentials` grant type",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/176",
      "state": "CLOSED",
      "author": "bellebaum",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi,\r\n\r\nI was looking through the current draft when I found this:\r\n\r\n```\r\nThe client credentials grant type MUST only be used by confidential clients.\r\n```\r\n\r\nI was wondering where it came from. I believe the reasoning might be that resources accessible by public clients are public resources in the first place? I believe that some APIs can be designed much simpler if they always require an access token. This then allows to manage access for public clients centrally at the authorization server (e.g. consider the case where you want to temporarily restrict access to a diverse set of APIs to some known clients).\r\n\r\nThere are other reasons for why omitting this restriction makes for a cleaner design. Consider this typical OAuth token endpoint flow with many omitted details:\r\n\r\n1. Authenticate the client and establish the `client_id`\r\n2. Look at the `grant_type` in the request and determine whether `client_id` is allowed to use it based on its `grant_types` metadata value.\r\n3. Redirect to `grant_type`-specific code to determine the scope of the access token (including where it may be used, a resource owner, etc.)\r\n4. Issue any tokens\r\n\r\nCurrently, point three has to look at authentication information of the client again despite this information being primarily conceived as facilitating the first point. This can make code more complicated. Also, policy decisions as to which client may use a grant are generally perceived as being handled by the second point.\r\n\r\nI would appreciate it if anyone could give me some insight into why this restriction was considered. Thanks in advance :)",
      "createdAt": "2024-05-15T09:00:23Z",
      "updatedAt": "2024-11-15T15:38:10Z",
      "closedAt": "2024-11-15T15:38:10Z",
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Perhaps you understand the grant type, or confidential clients. \r\n\r\nThis grant type is where the client authenticates directly to the AS and gets an access token. No user is involved. By definition, only confidential clients can keep a secret, and authenticate with a client credential.\r\n\r\nHence only a confidential client can use the `client_credential` grant type\r\n\r\n",
          "createdAt": "2024-05-15T17:23:07Z",
          "updatedAt": "2024-05-15T17:23:07Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "Hello @dickhardt :)\r\n\r\nCorrect, there is no user. According to the draft, `client_credentials` are a used\r\n\r\n```\r\nwhen the authorization scope is limited to the protected resources under the control of the client, or to protected\r\nresources previously arranged with the authorization server. Client credentials are used when the client is requesting\r\naccess to protected resources based on an authorization previously arranged with the authorization server.\r\n```\r\nOAuth clients may even be used in scenarios where they represent the _only_ resource owners in the system. I.e. there are no users. For example, OAuth may be (and is) used as a central management protocol for device authorization.\r\n\r\nMy question relates to the first part of the quote I omitted above:\r\n\r\n```\r\nThe client credentials or other forms of client authentication (e.g., a private key used to sign a JWT, as described in\r\n{{RFC7523}}) can be used as an authorization grant [...]\r\n```\r\n\r\nWhat about use cases where we want to manage permissions of unauthenticated (i.e. public) clients, which authenticate by the mere act of trying? Essentially, the client credentials of public clients are not nonexistent, they are the empty string. These clients also need a way to access resources under their control, so apart from the form of client authentication (which is otherwise not a grant type specific token endpoint extension), they need exactly what the client credentials grant offers.",
          "createdAt": "2024-05-16T07:11:27Z",
          "updatedAt": "2024-05-16T07:12:08Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "If there are no credentials, it is not a protected resource ",
          "createdAt": "2024-05-16T15:40:29Z",
          "updatedAt": "2024-05-16T15:40:29Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I'm very confused about the language you're using here. These clients with no credentials are needing a way to access resources \"under their control\"? How do you enforce any access control without any credentials?\r\n\r\nIf you were to make a \"client credentials\" request with no credentials, why bother even having an access token in the first place, why not just let the apps request the public API?",
          "createdAt": "2024-05-16T15:49:54Z",
          "updatedAt": "2024-05-16T15:49:54Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "Imagine wanting to _temporarily_ restrict access to a diverse range of resources to particular clients. So the resources are public by default, but may be temporarily restricted at will.\r\nIn such a case, access by public clients can be restricted at a single point (the authorization server), while access by unauthenticated clients has to be restricted at each resource server individually.\r\n\r\nFurthermore, the authorization server may additionally centrally enforce further access restrictions such as IP-based rate limiting.\r\n\r\nThese are just some use cases where omitting this restriction can simplify the design of an ecosystem (I have also outlined above how it may simplify the design of an authorization server).\r\n\r\nThe main question is what interoperability or security arguments were considered against this. According to [RFC 2119](https://www.rfc-editor.org/rfc/rfc2119.html#section-6):\r\n\r\n> Imperatives of the type defined in this memo must be used with care\r\n   and sparingly.  In particular, they MUST only be used where it is\r\n   actually required for interoperation or to limit behavior which has\r\n   potential for causing harm (e.g., limiting retransmisssions)  For\r\n   example, they must not be used to try to impose a particular method\r\n   on implementors where the method is not required for\r\n   interoperability.\r\n",
          "createdAt": "2024-05-17T07:18:26Z",
          "updatedAt": "2024-05-17T07:18:26Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "If you're wanting to temporarily restrict access to \"particular\" clients, you need to authenticate those clients somehow, which means they have credentials, which means they are not public clients. ",
          "createdAt": "2024-05-17T12:14:22Z",
          "updatedAt": "2024-05-17T12:14:22Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "Correct, the particular clients I want to _restrict_ access _to_ need to have credentials, but the ones having their access revoked might not.\r\n\r\nMaybe an example setup might help:\r\n\r\nSay I have clients A,B and C. A and B have credentials. They represent critical services which need to have access to my APIs at all time. C is for public access and has no credentials. Its client_id can be found on my website, but its access to my APIs might get revoked or limited during times of high load.\r\n\r\nI can configure all APIs to require access tokens, but then C needs a way to acquire any (and posting credentials online is bad practice, should probably not be encouraged). The most interoperable way is the `client_credentials` grant.\r\n\r\nAlternatively, I could make my APIs publicly accessible, but then restrictions require coordination with all API managers rather than just a simple switch at the authorization server. In complex environments, this might not always be an option.",
          "createdAt": "2024-05-17T14:37:36Z",
          "updatedAt": "2024-05-17T14:37:36Z"
        },
        {
          "author": "archer-321",
          "authorAssociation": "NONE",
          "body": "I don't think OAuth would be a good way to enforce rate limiting or a central way to turn off your public API temporarily. Unless you make the tokens extremely short-lived (e.g., a TTL of one minute) or even single-use, the extra step of having an authorization server will be ineffective. Moreover, if the authorization server needs to be contacted for each request anyway, moving this part of the access control to your resource servers (by having them contact the authorization server) would yield similar results. At that point, an internal protocol using optional access tokens might be easier to implement.\r\n\r\nIf you're concerned about your application's complexity, you could expose your API through some form of authenticating proxy. This way, your resource servers won't have to implement authentication, but you can still achieve global rate limiting and access control.\r\n\r\nOAuth is a framework for granting access to protected resources, so adding a grant type to the specification that doesn't require authentication seems dangerous. Outside your use case of using OAuth to enforce rate limiting, granting access to a protected resource without authentication is a security problem, and by having (public) client credentials involved in the access procedure, implementing services might get a false sense of security here.",
          "createdAt": "2024-05-17T16:52:22Z",
          "updatedAt": "2024-05-17T16:52:22Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "> OAuth is a framework for granting access to protected resources, so adding a grant type to the specification that doesn't require authentication seems dangerous.\r\n\r\nResource Servers should _never_ make any assumptions based merely on the fact that an authorization server is \"using OAuth\". Indeed, how the server authenticates e.g. users is not at all specified for a reason. The purpose of OAuth is to centralize authorization within an ecosystem.\r\n\r\n> OAuth is a framework for granting access to protected resources, so adding a grant type to the specification that doesn't require authentication seems dangerous.\r\n\r\nSure, if you assume that anyone can take all their APIs and expose them via a single proxy. This falls apart quickly if your ecosystem spans multiple organizations.\r\n\r\n> I don't think OAuth would be a good way to enforce rate limiting or a central way to turn off your public API temporarily. \r\n\r\nRate limiting is just one example :)\r\nAn authorization server is free to enforce an arbitrary policy based on peer address, time of day, phase of the moon or `/dev/random`, if need be. The centralized management options OAuth provides can be quite helpful in some cases.\r\n\r\nYet another use case:\r\n\r\nAccess Tokens are JWTs, every client is simultaneously a resource server and willing to talk to other clients based on attributes in the (non-bearer) access token (i.e. the access token grants access to other clients, hence OAuth). For some clients, the authorization server attests special properties, but arbitrary clients may participate without being attested any special properties. Essentially, the authorization server is used as a kind of CA issuing short-lived (ca. 1h) certificates in JWT-format. In a real-world use case, the clients are essentially devices unable to use a browser.\r\n\r\nAgain, the question is not whether or not this is a reasonable thing to allow: It is being used. The question is whether security or interoperability concerns justify the use of an RFC 2119 reserved word to restrict these use cases.",
          "createdAt": "2024-05-21T09:19:08Z",
          "updatedAt": "2024-05-21T09:19:52Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-10#section-2.4.2\r\n\r\n> The authorization server MAY support any suitable authentication scheme matching its security requirements.\r\n\r\nYou can authenticate clients however you want, it doesn't have to use a preregistered client secret as the authentication method.\r\n\r\nThe client credentials grant uses whatever client authentication you've defined.\r\n\r\nSaying that public clients can use the client credentials grant is a contradiction because public clients have no way to authenticate themselves.\r\n\r\nOr another way to look at it, let's say you're using the client IP address to authenticate the client, so that means the client credentials request would contain the client_id and nothing else, it still falls under the \"confidential client\" definition because you're saying that the client IP address is the client credential.",
          "createdAt": "2024-05-21T12:23:41Z",
          "updatedAt": "2024-05-21T12:23:41Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "What if I am using the empty string as a client credential and do not send it, as public clients do? This might match my authorization server's security requirements (e.g. for some clients, there are none, such as in my previous comment), hence, by this quote, it should suffice.\r\n\r\nBut then, if clients never sending any form of credential are suddenly counted as confidential clients, what is the purpose of the distinction anyway?",
          "createdAt": "2024-05-21T12:44:58Z",
          "updatedAt": "2024-05-21T12:44:58Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "My point is saying public clients can use the client credentials grant is a contradiction because by definition public clients don't authenticate to the AS. As soon as the client authenticates *somehow* it's no longer a public client so it can use its authentication in the client credentials request. You can be as creative as you want about the client authentication method.",
          "createdAt": "2024-05-21T12:54:58Z",
          "updatedAt": "2024-05-21T12:54:58Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "Yes, but taking this to the extreme, public clients _are_ confidential clients, just that their authentication check reduces to a mere `return true`. Therefore, they _are_ authenticating to the fullest extend required by the authorization server using their non-existent credentials.",
          "createdAt": "2024-05-21T13:34:07Z",
          "updatedAt": "2024-05-21T13:34:07Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I don't think changing the language in the spec is going to help clarify that",
          "createdAt": "2024-05-21T14:12:00Z",
          "updatedAt": "2024-05-21T14:12:00Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "Sure, but it does have real implications if there is an explicit statement (with an RFC 2119 keyword!) forbidding such clients from using this particular grant type. In particular, it has an effect on the following claim:\r\n\r\n> saying public clients can use the client credentials grant is a contradiction\r\n\r\nIt is not a contradiction, even if a bit unintuitive at first sight. And it can be helpful. Hence this issue. Currently there is no way (any auditor would accept) to both implement the spec-to-be and facilitate these valid use cases. This is potentially hindering interoperability, which need not be bad per se, but should be motivated by security or another form of interoperability rather than the use cases seeming nonsensical.\r\n\r\nMaybe let me ask from a different perspective:\r\nIf the client credentials grant could be used by any client authenticating to the token endpoint and requesting access to resources it is allowed to access, where would you see problems?",
          "createdAt": "2024-05-21T15:14:36Z",
          "updatedAt": "2024-05-21T15:14:36Z"
        },
        {
          "author": "archer-321",
          "authorAssociation": "NONE",
          "body": "> Resource Servers should never make any assumptions based merely on the fact that an authorization server is \"using OAuth\". Indeed, how the server authenticates e.g. users is not at all specified for a reason. The purpose of OAuth is to centralize authorization within an ecosystem.\r\n\r\nResource servers and authorization servers are regularly operated by the same entity (or at least operated in a way where the resource server is aware of the security an access token issued by the authorization server provides). As such, all resource servers that verify the token somehow (e.g., by checking a cryptographic property against a known key or secret) have at least some understanding of the level of security provided by this token. I.e. you cannot rely on OAuth providing some level of security on its own, but you cannot use OAuth without being aware of the level of security it provides in your use case.\r\n\r\n> Access Tokens are JWTs, every client is simultaneously a resource server and willing to talk to other clients based on attributes in the (non-bearer) access token (i.e. the access token grants access to other clients, hence OAuth). For some clients, the authorization server attests special properties, but arbitrary clients may participate without being attested any special properties. Essentially, the authorization server is used as a kind of CA issuing short-lived (ca. 1h) certificates in JWT-format. In a real-world use case, the clients are essentially devices unable to use a browser.\r\n\r\nAt this point, you're using OAuth as an alternative to existing structures with a CA issuing X.509 certificates. However, the common practice in this case is that clients without any attested properties don't use a certificate at all. I'm not saying that OAuth would be an inherently flawed way to distribute JWT-formatted certificates. However, not using a certificate if no property is attested is a perfectly valid implementation. Without unauthenticated tokens, you wouldn't need this grant type for public clients in the first place.\r\n\r\n> Currently there is no way (any auditor would accept) to both implement the spec-to-be and facilitate these valid use cases.\r\n\r\nThis will always be a limitation if you want to use a security-related specification for a project with parts implementing the standard that opt out of any security. The problem I see in changing the specification to allow (intentionally) insecure implementations to pass a security audit is that this weakening of the standard also applies to projects that don't try to opt out of security. The vast majority of applications using the client credential grant type *should not* pass a security audit when allowing unauthenticated authorization grants. In other words, the harm of enabling the security implications of your use case to pass an audit would outweigh the benefits, IMHO.",
          "createdAt": "2024-05-21T17:00:44Z",
          "updatedAt": "2024-05-21T17:00:44Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "> at least some understanding of the level of security provided by this token\r\n\r\nI agree, and OAuth is purposefully fuzzy there. Maybe that level of understanding is best categorized as \"the level of security that the RS operator trusts the configured AS to provide\". After all, it is the RS operator configuring the RS to trust tokens issued by the AS. So what matters is their understanding of the security guarantees after consultation with the AS operator (which might or might not be the same person). This is where the simplicity of OAuth comes from.\r\n\r\nThis implies that assumptions like \"only clients with suitable methods of authentication should use the RS to access resources for them\" belong to the security considerations for implementations and deployments, not the core protocol.\r\nIn fact, that would be a good place to bring this up.\r\n\r\n> However, the common practice in this case is that clients without any attested properties don't use a certificate at all.\r\n\r\nYes, although the AS agreeing to the communication by issuing the token is a kind of attestation in itself. This is where the centralization comes into play.\r\n\r\n> > Currently there is no way (any auditor would accept) to both implement the spec-to-be and facilitate these valid use cases.\r\n> \r\n> This will always be a limitation if you want to use a security-related specification for a project with parts implementing the standard that opt out of any security. The problem I see in changing the specification to allow (intentionally) insecure implementations to pass a security audit is that this weakening of the standard also applies to projects that don't try to opt out of security. The vast majority of applications using the client credential grant type should not pass a security audit when allowing unauthenticated authorization grants. In other words, the harm of enabling the security implications of your use case to pass an audit would outweigh the benefits, IMHO.\r\n\r\nCould you please specify the exact security implications?\r\nClient metadata already includes both a `token_endpoint_auth_method` and a `grant_types` attribute. So without any code to fulfill this `MUST`, it is already possible to achieve the same effect by configuration. Deviating from a sane default configuration should come with appropriate _context specific_ security considerations. Even if an AS has no concept of client metadata, it can still be written in a way to enforce arbitrary policies. Restricting it at a protocol level thus seems to _only_ restrict use cases, and not provide additional security over proper configuration or implementation. This is what security considerations are for.\r\n\r\nBy allowing public clients to use the client credentials grant, one is not opting out of any security. One is in fact using OAuth's security model to its fullest extend. If the AS deems \"unauthenticated\" as secure enough and the RS is configured to blindly trust the AS, then any client should get access to a resource. Anything beyond that may only make OAuth more complicated and even harder to understand than it already is.",
          "createdAt": "2024-05-22T08:52:24Z",
          "updatedAt": "2024-05-22T08:52:24Z"
        },
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "How about something like this in the security considerations:\r\n\r\n> Issuing access tokens as a response to public clients using the client credentials grant type implies that anyone may acquire such tokens without authentication. Authorization servers SHOULD limit the scope of such tokens to resources for which they expect this to be acceptable.\r\n\r\nDoes this address the security concerns?",
          "createdAt": "2024-05-22T09:07:51Z",
          "updatedAt": "2024-05-22T09:07:51Z"
        },
        {
          "author": "archer-321",
          "authorAssociation": "NONE",
          "body": "> This implies that assumptions like \"only clients with suitable methods of authentication should use the RS to access resources for them\" belong to the security considerations for implementations and deployments, not the core protocol.\r\n> In fact, that would be a good place to bring this up.\r\n\r\nThe resource server's awareness of the security an authentication server provides doesn't necessarily imply that (all) security implementation details don't belong in the specification. E.g., the specification contains a requirement that\r\n\r\n> OAuth URLs MUST use the https scheme except for loopback interface redirect URIs, which MAY use the http scheme.\r\n\r\nThere are legitimate use cases where HTTP would be \"enough security\" (e.g. if the authorization server is only available on the loopback interface). However, for the vast majority of implementations, using anything but `https` for the authorization endpoint would be unacceptable. Similarly, you can come up with a use case where issuing access tokens to an unauthenticated client is acceptable. However, for the vast majority of implementations providing the client credentials grant type, this behaviour would be insecure. By including a requirement for clients that authenticate with their credentials to actually have credentials, the specification helps to prevent faulty implementations where the developer implementing the authorization server might not notice that it's incorrect to assume every client that's been issued a client secret can use that secret to authenticate. This requirement would indeed prevent some uncommon use cases, but I believe it's better to switch to another standard for those use cases than try to generalize OAuth until it works for every possible use case.\r\n\r\n> Yes, although the AS agreeing to the communication by issuing the token is a kind of attestation in itself. This is where the centralization comes into play.\r\n\r\nIf the AS agrees based on some condition, which would be the only case where the agreement could be interpreted as an attestation, that condition becomes the client credential. E.g. if it is appropriate for your application's security, it could be a valid client credential that the user has a specific IP address or that the user is connecting at a specific phase of the moon. At this point, if I understand [`@aaronpk`'s point](https://github.com/oauth-wg/oauth-v2-1/issues/176#issuecomment-2122573629) correctly, you can declare your clients confidential and create a compliant implementation.\r\n\r\n> Could you please specify the exact security implications?\r\n> Client metadata already includes both a `token_endpoint_auth_method` and a `grant_types` attribute. So without any code to fulfill this `MUST`, it is already possible to achieve the same effect by configuration. Deviating from a sane default configuration should come with appropriate _context specific_ security considerations. Even if an AS has no concept of client metadata, it can still be written in a way to enforce arbitrary policies. Restricting it at a protocol level thus seems to _only_ restrict use cases, and not provide additional security over proper configuration or implementation. This is what security considerations are for.\r\n\r\nThe paragraph you quoted was about changing the specification with the goal of passing a security audit. My point is that dropping this grant type's requirement for clients to be confidential will allow implementations for regular use cases to incorrectly assume that client authentication of public clients provides any form of security. Again, if there's any verifiable way to authenticate a client (e.g. by using the IP address), that client can be considered confidential. Otherwise, there is no verifiable attribute, and issuing a token for a protected resource based on a grant type built around client authentication is counterintuitive.\r\n\r\nIf the client credentials grant type doesn't provide the flexibility you need, you can always define a new custom \"minimal access\" grant type that's available to any registered client. This does limit interoperability, but if the client doesn't know about your authorization endpoint's custom grant type, it might not know about the lack of authentication for the AS' client credentials grant type implementation either.\r\n\r\n---\r\n\r\nI feel that this discussion is slowly turning into bikeshedding over the definition of \"client credential\". It might be a good idea to wait for another opinion, as I'm unsure which definition is \"more intuitive\".",
          "createdAt": "2024-05-23T05:23:31Z",
          "updatedAt": "2024-05-23T05:23:31Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@bellebaum you are free to implement your AS however you want. There are no standards police that will take you away and lock you up for not following the standard to the letter. What is motivating you to want a change that has not been expressed by anyone else to the authors since OAuth 2.0 was started 15 years ago? ",
          "createdAt": "2024-05-23T17:39:37Z",
          "updatedAt": "2024-05-23T17:39:37Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I don't think this discussion is making any progress, and I don't think it will help anyone to say \"public clients can use the client credentials grant\" because that meanse the client credentials grant is being used without credentials.",
          "createdAt": "2024-11-15T15:38:10Z",
          "updatedAt": "2024-11-15T15:38:10Z"
        }
      ]
    },
    {
      "number": 177,
      "id": "I_kwDODkfq5s6JVou_",
      "title": "Typo: resource server instead of resource",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/177",
      "state": "CLOSED",
      "author": "mrcaidev",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "See [Section 5.3.2. \"Error Codes\"](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11#name-error-codes).\r\n\r\nIn the description of \"invalid_token\":\r\n\r\n> The resource SHOULD ...\r\n\r\nshould be:\r\n\r\n\"The resource server SHOULD ...\"",
      "createdAt": "2024-05-18T16:09:06Z",
      "updatedAt": "2024-06-13T21:56:10Z",
      "closedAt": "2024-06-13T21:56:10Z",
      "comments": []
    },
    {
      "number": 179,
      "id": "I_kwDODkfq5s6JXvNB",
      "title": "Reasons for recommending loopback redirects over private-use URI scheme",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/179",
      "state": "OPEN",
      "author": "archer-321",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current OAuth 2.1 draft mentions that\r\n\r\n> Many environments that support private-use URI schemes do not provide a mechanism to claim a scheme and prevent other parties from using another application's scheme. As such, clients using private-use URI schemes are vulnerable to potential attacks on their redirect URIs, so this option should only be used if the previously mentioned more secure options are not available.\r\n\r\nAFAICT, this paragraph was introduced by [f428704c](https://github.com/oauth-wg/oauth-v2-1/commit/f428704cd469fb350d0f5318f4b4589e3e6d0e5c#diff-c690e6a757ffca99a8affaa2828883974014878ce549391b38be85d4c91862c9R3174-R3179) for the reasons outlined in the [ietf-113 minutes](https://datatracker.ietf.org/meeting/113/materials/minutes-113-oauth-00):\r\n\r\n> George: I am in favor of ordering of best security practive starting with the claimed https URL.\r\n> Aaron: It sounds like we are going to re-order the list, claimed https URL first, loopback second, and private URI schemes. Remove the sentence for the mandatory -implementing all three. Maybe adding text of why you want to have the private URI scheme at all.\r\n\r\nConsidering that any app can listen on the loopback interface and thus create a valid redirect URI that leads to itself, I wonder what makes loopback redirects more secure than private-use URI schemes.\r\n\r\nOne potential advantage of loopback redirects that I can see is that only one app can listen on the specific port. Thus, it's impossible for an attacker to receive a code that was the result of a valid authorization request if the client has already started its loopback HTTP server. However, integrating PKCE into OAuth 2.1 should already prevent this attack. Moreover, using the authorization code grant type already prevents MITM attacks, public clients can't use the client credentials grant type, and the implicit grant type was removed.\r\n\r\nOn the other hand, most operating systems require some sort of installation procedure (installing a `.desktop` file, creating a registry entry, installing an app with a manifest, etc.) before user agents consider an application for the private-use URI scheme. While this is not a \"true\" security feature that protects against redirect code interception, as multiple applications can register themselves for the same scheme, it prevents users with access to the same loopback device but *without* access to the same user account or the system-wide scheme handler registry from intercepting a code. In comparison, any user on the same computer can bind a port on the loopback device and thus obtain a valid redirect URI that points to itself.\r\n\r\n---\r\n\r\nI agree that all native clients should prefer claimed \"https\" schemes where possible, but unless I'm missing something, I would suggest changing the paragraph above to something like\r\n\r\n> Many environments that support private-use URI schemes do not provide a mechanism to claim a scheme and prevent other parties from using another application's scheme. As such, clients using private-use URI schemes are vulnerable to potential attacks on their redirect URIs, so this option should only be used if claimed https schemes are not available.",
      "createdAt": "2024-05-19T17:10:44Z",
      "updatedAt": "2024-05-20T01:57:33Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@archer-321 are you suggesting dropping loopback? \r\n\r\nI think loopback is preferable to private schemes in that you can't MITM it. A malicious app does not know when a protocol is happening. In contrast, if an malicious app registers a private scheme, then it could be intercepting the protocol.\r\n\r\nMobile platforms generally support claimed https and pretty much any app can claim a private scheme. On desktop, the loopback is generally preferable. A common use case are CLI tools that launch the browser -- claiming an https endpoint, or registering a private scheme are not really practical. \r\n",
          "createdAt": "2024-05-20T00:51:20Z",
          "updatedAt": "2024-05-20T00:51:20Z"
        },
        {
          "author": "archer-321",
          "authorAssociation": "NONE",
          "body": "> @archer-321 are you suggesting dropping loopback?\r\n\r\nNo, I believe loopback is still essential for many native client implementations, and there would be no reason to drop this well-established redirect type. I was merely suggesting rephrasing the private-use redirect URI scheme section I quoted, as I didn't see the security advantages of loopback over private-use URI schemes mentioned.\r\n\r\n> I think loopback is preferable to private schemes in that you can't MITM it. A malicious app does not know when a protocol is happening. In contrast, if an malicious app registers a private scheme, then it could be intercepting the protocol.\r\n\r\nConsidering the only grant type available to public clients in OAuth 2.1 is the authorization code grant, how could an attacker MITM the authorization \"ceremony\"? If they manage to intercept the authorization code, it would either be useless when the legitimate client has obtained an access token, or the legitimate client would encounter an error while trying to retrieve an access token after the attacker has already used the code.\r\n\r\nOne aspect you mentioned that I didn't consider is that attackers are more likely to notice that an authorization ceremony is happening. However, this could also be established by watching all processes until an instance of the client application binds a port on the loopback interface, so I'm unsure how much security the protocol gets here.\r\n\r\nThe primary reason I prefer private-use redirect URIs over loopback is that some services incorrectly implement the user-interaction part of the authorization endpoint. E.g., GitHub doesn't seem to ask for interaction if the user has previously authorized the application. If the application uses a loopback redirect URI, even a process running as another user could create a loopback HTTP server. The only thing a malicious client would have to do in this case to get access to the protected resource is redirect the user to the authorization endpoint somehow (e.g. by sending the user a link or by putting the link on a website the attacker controls - even adding the link to the description of a pull request would work).\r\n\r\nWith private-use URI schemes, the attacker would have to get a system administrator to install it as a scheme handler. Alternatively, the attacker would need access to the user configuration to set up the scheme handler for a single user. Again, I wouldn't count this as a foolproof security feature, but in my head, it makes attacks more complex, at least.\r\n\r\n> Mobile platforms generally support claimed https and pretty much any app can claim a private scheme. On desktop, the loopback is generally preferable. A common use case are CLI tools that launch the browser -- claiming an https endpoint, or registering a private scheme are not really practical.\r\n\r\nI agree that mobile apps (and apps on other systems with the feature) should prefer claimed \"https\" schemes over both loopback redirect URIs and private-use URI schemes. I also agree that CLI tools that ship as a single binary without any installer or package should be able to use loopback. My main concern is that, in my opinion, the quoted paragraph of the specification \"unfairly\" treats private-use URI schemes as less secure than loopback redirects (\"[...] this option should only be used if the previously mentioned more secure options are not available\"). This wording might make future implementing services not consider support for private-use URI schemes while instead forcing apps to use loopback.",
          "createdAt": "2024-05-20T01:57:32Z",
          "updatedAt": "2024-05-20T01:57:32Z"
        }
      ]
    },
    {
      "number": 180,
      "id": "I_kwDODkfq5s6Jhvl9",
      "title": "Consider add field expires_at in token response",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/180",
      "state": "CLOSED",
      "author": "jht5945",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Consider add `expires_at` in token response:\r\n\r\n**RECOMMENDED**. Time at which the access token will expire. A JSON number that representing the number of seconds from 1970-01-01T00:00:00Z as measured in UTC until the date/time.\r\n\r\nThere is only a field named `expires_in`, it will take some time where client get the token response from the token was issued, so client cannot know exactly when the access token will expire. Filed `expires_at` will exactly know when the access token will expire.",
      "createdAt": "2024-05-21T05:26:24Z",
      "updatedAt": "2024-05-21T12:52:07Z",
      "closedAt": "2024-05-21T12:52:07Z",
      "comments": [
        {
          "author": "bellebaum",
          "authorAssociation": "NONE",
          "body": "In many cases, the `expires_in` number is generated shortly before the token is sent to the client, so we are talking about half a round trip offset from the number a client could calculate given its own clock and adding `expires_in`. Then typical code would check whether that time came before sending the token to a resource server, which gives another half round trip of offset. So assuming the resource server and authorization server have synced up clocks, we have about one round trip we are missing here.\r\n\r\nBringing in `expires_at` would additionally be prone to clock sync problems with the client. I would personally expect these to grow much larger than a single round trip if NTP or similar is not being used.\r\n\r\nMaybe a recommendation to account for a few seconds of clock skew and round times would be helpful here, just like for JWTs?",
          "createdAt": "2024-05-21T11:20:03Z",
          "updatedAt": "2024-05-21T11:20:03Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Even with 'expires_at', there is no way to know \"exactly\" when the token expires because clocks will never be perfectly in sync. Additionally, the token might expire ahead of its scheduled expiration for whatever reason. In other words, the client will always have to handle the case where the request fails because the token expired. If the token expires, the client either uses its refresh token or sends the user thru a flow again to get a new token. At best, the client can try to avoid an unnecessary HTTP request with a token it knows is expired and proactively get a new token. The difference between the client knowing an exact timestamp from the server vs calculating the timestamp from the expires_in isn't going to make a difference in practice.\r\n\r\nAdditionally, this was discussed at length on the mailing list years ago and this is not something we can change in 2.1.",
          "createdAt": "2024-05-21T12:52:07Z",
          "updatedAt": "2024-05-21T12:52:07Z"
        }
      ]
    },
    {
      "number": 181,
      "id": "I_kwDODkfq5s6KQDSQ",
      "title": "Authorization Endpoint HTTP `POST` binding",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/181",
      "state": "CLOSED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "2.1 added a lot of text around how clients form authorization requests, the language does not however account for the optional POST binding at the authorization endpoint.\r\n\r\n> The authorization server MUST support the use of the HTTP GET method Section 9.3.1 of [[RFC9110](https://www.rfc-editor.org/info/rfc9110)] for the authorization endpoint and MAY support the POST method (Section 9.3.3 of [[RFC9110](https://www.rfc-editor.org/info/rfc9110)]) as well.\r\n\r\nSections [3.1. ](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11#section-3.1)[Authorization Endpoint](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11#name-authorization-endpoint) and [4.1.1. ](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11#section-4.1.1)[Authorization Request](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11#name-authorization-request) do not account for the optional POST binding which uses the request body to carry the `application/x-www-form-urlencoded` encoded parameters.\r\n\r\nIn OIDC there's [explicit text around](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) the request parameters.\r\n\r\n> Authorization Servers MUST support the use of the HTTP GET and POST methods defined in [RFC 7231](https://openid.net/specs/openid-connect-core-1_0.html#RFC7231) [RFC7231] at the Authorization Endpoint. Clients MAY use the HTTP GET or POST methods to send the Authorization Request to the Authorization Server. If using the HTTP GET method, the request parameters are serialized using URI Query String Serialization, per [Section 13.1](https://openid.net/specs/openid-connect-core-1_0.html#QuerySerialization). If using the HTTP POST method, the request parameters are serialized using Form Serialization, per [Section 13.2](https://openid.net/specs/openid-connect-core-1_0.html#FormSerialization).",
      "createdAt": "2024-05-27T16:06:52Z",
      "updatedAt": "2024-11-15T16:53:13Z",
      "closedAt": "2024-11-15T16:53:13Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This has been resolved in #190, there is now a section that describes the serialization methods in an appendix, which is referenced elsewhere in the spec: https://drafts.oauth.net/oauth-v2-1/draft-ietf-oauth-v2-1.html#name-serializations",
          "createdAt": "2024-11-15T16:53:13Z",
          "updatedAt": "2024-11-15T16:53:13Z"
        }
      ]
    },
    {
      "number": 183,
      "id": "I_kwDODkfq5s6O0tQj",
      "title": "Clarify `aud` values that should be accepted in `private_key_jwt` at the token (and other) endpoints",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/183",
      "state": "OPEN",
      "author": "jogu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There's some unfortunate history around the `aud` value that you use in `private_key_jwt` client authentication assertions.\r\n\r\n[RFC7523](https://datatracker.ietf.org/doc/html/rfc7523#section-3) says:\r\n\r\n```\r\n        The JWT MUST contain an \"aud\" (audience) claim containing a\r\n        value that identifies the authorization server as an intended\r\n        audience.  The token endpoint URL of the authorization server\r\n        MAY be used as a value for an \"aud\" element to identify the\r\n        authorization server as an intended audience of the JWT.  The\r\n        authorization server MUST reject any JWT that does not contain\r\n        its own identity as the intended audience\r\n```\r\n\r\nThe WG already tried to be a bit more specific, e.g. in [PAR](https://www.rfc-editor.org/rfc/rfc9126.html#section-2) we say the issuer value 'SHOULD' be used and 'MUST' be accepted:\r\n\r\n> Due to historical reasons, there is potential ambiguity regarding the appropriate audience value to use when employing JWT client assertion-based authentication (defined in [Section 2.2](https://www.rfc-editor.org/rfc/rfc7523#section-2.2) of [[RFC7523](https://www.rfc-editor.org/rfc/rfc9126.html#RFC7523)] with private_key_jwt or client_secret_jwt authentication method names per Section 9 of [[OIDC](https://www.rfc-editor.org/rfc/rfc9126.html#OIDC)]). To address that ambiguity, the issuer identifier URL of the authorization server according to [[RFC8414](https://www.rfc-editor.org/rfc/rfc9126.html#RFC8414)] SHOULD be used as the value of the audience. In order to facilitate interoperability, the authorization server MUST accept its issuer identifier, token endpoint URL, or pushed authorization request endpoint URL as values that identify it as an intended audience.\r\n\r\n\r\nIt seems like we could add something in OAuth 2.1 to try and help people get this working in an interoperable fashion. Somewhere in https://drafts.oauth.net/oauth-v2-1/draft-ietf-oauth-v2-1.html#section-2.4 would seem like a possible place to offer a clarification. Perhaps something along the lines of:\r\n\r\n> When using `private_key_jwt`, In order to facilitate interoperability, the authorization server MUST accept its issuer identifier, token endpoint URL, or the endpoint URL that the assertion is being presented to as `aud` values that identify it as an intended audience.\r\n",
      "createdAt": "2024-07-08T17:30:06Z",
      "updatedAt": "2025-03-14T16:13:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "Apologies again for the way things are.",
          "createdAt": "2024-07-08T19:44:29Z",
          "updatedAt": "2024-07-08T19:44:29Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "Apologies again.",
          "createdAt": "2024-11-09T18:27:05Z",
          "updatedAt": "2024-11-09T18:27:05Z"
        },
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "This is still relevant but what is done about it here, if anything, may change due to https://talks.secworkshop.events/osw2025/talk/R8D9BS/",
          "createdAt": "2025-03-14T16:13:43Z",
          "updatedAt": "2025-03-14T16:13:43Z"
        }
      ]
    },
    {
      "number": 184,
      "id": "I_kwDODkfq5s6Q_rLK",
      "title": "Section 4.1.2.1 Error Response is unclear on how to handle an Invalid Authorization Endpoint request",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/184",
      "state": "OPEN",
      "author": "dfcoffin",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The first paragraph of **Section 4.1.2.1. Error Response** indicates that the authorization server **SHOULD** inform the resource owner if an invalid or malformed request is attempted but does not indicate how this should be done.  It also states the authorization server **MUST NOT** automatically redirect the user-agent to the invalid redirection URI but does not indicate what to respond to the requestor other than in an example at the bottom of the section, which displayed an example of an \"access_denied\" response with \"client.example.com\" as the host value.\r\n\r\nI have seen implementations that send the \"access_denied\" as a 302 response using the redirect_uri value as the host element of the \"Location\" header in place of client.example.com.  They also want to use status code 400 for all other errors based on **Section 5.2. Error Response** of RFC 6749.\r\n\r\nShould the titles of the Error Response sections include the referenced Endpoint?  For example, \"4.1.2.1. Authorization Error Response\" and \"5.2. Token Error Response\"?\r\n\r\nShould the Authorization Endpoint and the Token Endpoint use the same status code for errors (i.e., 400 with the error in the body), which would simplify Error Response and eliminate the possibility of transmitting information to the redirect_uri value?\r\n\r\n",
      "createdAt": "2024-07-26T16:55:54Z",
      "updatedAt": "2024-07-26T17:06:53Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 186,
      "id": "I_kwDODkfq5s6SaB4b",
      "title": "weird referece, but okay ",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/186",
      "state": "CLOSED",
      "author": "bc-pi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "see https://github.com/oauth-wg/oauth-v2-1/commit/673d7f0d501aef6cc1fd0bf38b2436d34d0af8cd#r145092580 and suggest https://www.rfc-editor.org/rfc/rfc9110.html#section-11.1 rather than ref to ABNF ",
      "createdAt": "2024-08-08T17:29:06Z",
      "updatedAt": "2024-11-15T15:38:43Z",
      "closedAt": "2024-11-15T15:38:42Z",
      "comments": []
    },
    {
      "number": 187,
      "id": "I_kwDODkfq5s6Wjpe6",
      "title": "Expand on reasons for not including expires_in in the token response",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/187",
      "state": "CLOSED",
      "author": "pilcrowonpaper",
      "authorAssociation": "NONE",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "Hi, \r\n\r\nIs there a reason why the `expires_in` field exists but an equivalent for refresh token doesn't? Something like `refresh_token_expires_in`.  I couldn't find any discussion on it in past mailing lists. Currently, most implementations use `refresh_token_expires_in` while some use `refresh_expires_in`.\r\n\r\nI'm not sure if this can be changed but I'd like to know if there's any background context to the decision.",
      "createdAt": "2024-09-14T01:54:06Z",
      "updatedAt": "2025-04-10T20:15:31Z",
      "closedAt": "2024-12-19T15:07:58Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Many servers have either unlimited length refresh tokens or refresh tokens with a dynamic expiration date.\r\n\r\nIn any case, the client can't do anything useful with the knowledge of the refresh token expiration time, so there's no point in telling it. If the refresh token expires, the only thing the client can do is start a new OAuth flow from scratch.\r\n\r\nThe refresh token also might expire before the scheduled expiration, even if there is a fixed expiration date. For example if the user revokes the application's access, or if they change their password, or any number of other events.\r\n\r\nSo even if the server did tell the client when the refresh token expires, it's actually when it \"might\" expire, and the client would have to handle an earlier expiration anyway.\r\n\r\nThis is all good context to add to the [refresh token section](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11#section-1.3.2) so I will rename this issue so I can track that.",
          "createdAt": "2024-09-14T02:01:25Z",
          "updatedAt": "2024-09-14T02:03:37Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "* The client has to handle the case of a refresh token expiring at any given time, the expiry is up to the AS, and can be scheduled or at an arbitrary time\r\n* The only thing the client can do when the refresh token expires is start a new OAuth flow",
          "createdAt": "2024-12-04T15:18:18Z",
          "updatedAt": "2024-12-04T15:18:18Z"
        },
        {
          "author": "njwatson32",
          "authorAssociation": "NONE",
          "body": "Regarding \"the client can't do anything useful with the knowledge of the refresh token expiration time\", we (Google) have received feedback from several clients that they want to remind the user to reauthorize the application prior to the expiration of the refresh token in order to avoid a disruption of service.  This is most common with applications that run in the background, e.g. analytics or monitoring tools, where the user is not typically around to be prompted to reauthorize when the RT does expire.\n\nThis isn't to say that clients are off the hook for handling RT expiration at \"unexpected\" times, but they should be allowed to optimize for the normal case when the RT expires when the AS says it will.\n\nGiven that OAuth 2.1 covers refresh token rotation (mandatory for public clients if tokens are unbound), and RT expiration can relate directly to that, it seems reasonable to include within the purview of this spec version.\n\n(Side note: I agree with OP that refresh_token_expires_in is a reasonable name. A quick search suggests that Microsoft and Github already use this name, and we at Google are eyeing it too.)",
          "createdAt": "2025-02-01T05:21:31Z",
          "updatedAt": "2025-02-01T05:21:31Z"
        },
        {
          "author": "IvanAnishchuk",
          "authorAssociation": "NONE",
          "body": ":+1: on the last point. Already used that exact name `refresh_token_expires_in` in a custom implementation few years back.",
          "createdAt": "2025-02-01T07:17:44Z",
          "updatedAt": "2025-02-01T07:17:44Z"
        },
        {
          "author": "tiwarivikash",
          "authorAssociation": "NONE",
          "body": "Many clients such as Zoom inform users proactively that their session is going to expire in near future and they can choose to extend it before that.",
          "createdAt": "2025-02-01T14:54:10Z",
          "updatedAt": "2025-02-01T14:54:10Z"
        },
        {
          "author": "ObjectIsAdvantag",
          "authorAssociation": "NONE",
          "body": "+1 to add `refresh_token_expires_in`\nCisco Webex already support it: https://developer.webex.com/docs/integrations#using-the-refresh-token\nand we need the OAuth specifications to include the field officially so that we can standardize internally on this exact name for other Cisco products.",
          "createdAt": "2025-02-03T11:21:09Z",
          "updatedAt": "2025-02-03T11:21:09Z"
        },
        {
          "author": "erincandescent",
          "authorAssociation": "NONE",
          "body": "> In any case, the client can't do anything useful with the knowledge of the refresh token expiration time, so there's no point in telling it. If the refresh token expires, the only thing the client can do is start a new OAuth flow from scratch.\n\nI don't think this is true, or what people mean by `refresh_token_expires_in` differs from my understanding. My understanding of `refresh_token_expires_in` is that _in the normal case_ (token not revoked early), the client has until that time to invoke the refresh token grant with this token to receive a new access token and refresh token.\n\nAs an AS implementer, its very useful to be able to expire \"stale\" sessions; this means that refresh tokens must expire at some point. Clients need to know how often they must refresh their tokens in order to maintain the session. At present, the only advice they have on this is the `expires_in` value; but access token lifetime is often short. I might want e.g. access tokens to expire in 10 minutes but refresh tokens to expire in 7 days, but both me and the client would like it if they could only hit the token endpoint once every 7 days during periods of time where they're not actively using the RS but just need to maintain the session.",
          "createdAt": "2025-02-05T23:54:09Z",
          "updatedAt": "2025-02-05T23:54:09Z"
        },
        {
          "author": "njwatson32",
          "authorAssociation": "NONE",
          "body": "I think there are two concepts at play here:\n\n1. How long is the user's authorization good for? Some AS may offer the user a choice (or mandate) to grant permissions only for a certain amount of time, especially for very sensitive data access (e.g. mail or biometrics).\n2. How long is the credential itself valid, i.e. how often does the client need to hit the token endpoint to get a new RT.\n\nCan a single `refresh_token_expires_in` field adequately address both use cases? The RT itself would always expire in `min(rotation_cadence, user_authz_duration)`, so a single field would still be accurate, but clients might want to handle each case differently.",
          "createdAt": "2025-02-06T00:36:10Z",
          "updatedAt": "2025-02-06T00:36:10Z"
        },
        {
          "author": "njwatson32",
          "authorAssociation": "NONE",
          "body": "To close the loop here: Based on discussions at IETF 122, we are not including this in OAuth 2.1 but I will send out a draft of a standalone spec for RT and/or consent expiration.",
          "createdAt": "2025-04-10T20:15:30Z",
          "updatedAt": "2025-04-10T20:15:30Z"
        }
      ]
    },
    {
      "number": 188,
      "id": "I_kwDODkfq5s6X_-VR",
      "title": "7.12 Phishing Attacks: Clarification and additional advice to the reader",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/188",
      "state": "CLOSED",
      "author": "sakimura",
      "authorAssociation": "NONE",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "Paragraph 1: it is not only the resource owners' password that can be phished. OTP etc. can be phished as well. \r\nProposes to change: \"steal resource owners' passwords\" to \"steal resource owners' passwords and other credentials that are not phishing-resistant\". \r\n\r\nAlso, as the paragraph 2 advises, user education is important, but its effectiveness is somewhat limited. \r\nIt is better to advise authorization servers to deploy Phishing-resistant authentication mechanisms. \r\nTherefore, I propose to add a new paragraph 2 such as: \r\n\r\nService providers SHOULD implement phishing-resistant authenticator support. \r\n\r\nA question. There are two instances of \"should\" in the current paragraph 2. Are they intended or they actually are \"SHOULD\"? \r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2024-09-26T10:06:33Z",
      "updatedAt": "2024-12-19T15:22:09Z",
      "closedAt": "2024-12-19T15:22:09Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This moved to 7.8 https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-7.8",
          "createdAt": "2024-12-04T15:39:31Z",
          "updatedAt": "2024-12-04T15:39:31Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "> Service providers should attempt to educate end users about the risks phishing attacks pose and should provide mechanisms that make it easy for end users to confirm the authenticity of their sites, such as using phishing-resistant authenticators.",
          "createdAt": "2024-12-04T15:42:02Z",
          "updatedAt": "2024-12-04T15:42:02Z"
        }
      ]
    },
    {
      "number": 189,
      "id": "I_kwDODkfq5s6X__8q",
      "title": "7.X Stateless tokens and key rotation",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/189",
      "state": "CLOSED",
      "author": "sakimura",
      "authorAssociation": "NONE",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "There has been a case where the signing key for the stateless JWT based access token was stolen and used by attacker to mint new access tokens. Since the token was stateless, meaning the resource servers verified the signature of the access token and if it was successful, the access token was accepted. This lead the attacker to be able to access resources at their will for an extended period as the signing key was not rotated. \r\n\r\nIf such tokens are to be used, then the signing key MUST be rotated periodically to limit the exposed period. \r\n\r\nAlso, the authorization server SHOULD keep track of the tokens issued and return error when a token that it did not issue with a valid signature was submitted to the token introspection endpoint. \r\n",
      "createdAt": "2024-09-26T10:08:55Z",
      "updatedAt": "2024-12-19T15:13:30Z",
      "closedAt": "2024-12-19T15:13:30Z",
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-7.1.2\r\n\r\nWe will update this:\r\n\r\n> A large range of threats can be mitigated by protecting the contents of the access token by using a digital signature, and by following best practices for signing key management such as periodic key rotation.\r\n\r\nI don't think it makes sense to add your second recommendation.",
          "createdAt": "2024-12-04T15:37:34Z",
          "updatedAt": "2024-12-04T15:37:34Z"
        }
      ]
    },
    {
      "number": 191,
      "id": "I_kwDODkfq5s6iAp-k",
      "title": "Expand on definition of expires_in",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/191",
      "state": "CLOSED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-3.2.3\r\n\r\n> If omitted, the authorization server SHOULD provide the expiration time via other means or document the default value.\r\n\r\nReplace the last sentence explaining that an access token might expire ahead of the scheduled expiration here",
      "createdAt": "2024-12-04T15:19:05Z",
      "updatedAt": "2025-03-16T08:28:59Z",
      "closedAt": "2025-03-16T08:28:54Z",
      "comments": []
    },
    {
      "number": 192,
      "id": "I_kwDODkfq5s6iAtMa",
      "title": "rework description of access token ",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/192",
      "state": "OPEN",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "see 1.4\r\n\r\n> Access tokens represent specific scopes and durations of access, granted by the resource owner, and enforced by the resource server and authorization server.\r\n\r\n- separate out what is done by AS vs RS\r\n- add in expiry language",
      "createdAt": "2024-12-04T15:23:26Z",
      "updatedAt": "2024-12-04T15:23:27Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 193,
      "id": "I_kwDODkfq5s6iteXd",
      "title": "RFC9449 duplicated in Appendix D",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/193",
      "state": "CLOSED",
      "author": "mrcaidev",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "RFC9449 appeared twice in [Appendix D. Extensions](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#name-extensions).\r\n\r\nTo prevent similar issues from happening, I think these extensions can be sorted by their RFC serial number.",
      "createdAt": "2024-12-10T11:19:27Z",
      "updatedAt": "2025-05-28T13:43:16Z",
      "closedAt": "2025-05-28T13:43:16Z",
      "comments": []
    },
    {
      "number": 194,
      "id": "I_kwDODkfq5s6jSg1R",
      "title": "Reference Errors in Section 4.1.1",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/194",
      "state": "OPEN",
      "author": "mrcaidev",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There are two reference errors in the following paragraph in [Section 4.1.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-4.1.1):\r\n\r\n> Clients MUST use code_challenge and code_verifier and authorization servers MUST enforce their use except under the conditions described in [Section 7.5.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#authorization_codes). In this case, using and enforcing code_challenge and code_verifier as described in the following is still RECOMMENDED.\r\n\r\n## 1. No Exception Condition Given in Section 7.5.1\r\n\r\n> Clients MUST use code_challenge and code_verifier and authorization servers MUST enforce their use except under the conditions described in [Section 7.5.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#authorization_codes).\r\n\r\n[Section 7.5.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12#section-7.5.1) no longer justifies the exception condition, which was only present in [Draft v1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-01#name-authorization-codes):\r\n\r\n> * The client is a confidential client.\r\n>\r\n> * In the specific deployment and the specific request, there is reasonable assurance for authorization server that the client implements the OpenID Connect nonce mechanism properly.\r\n\r\nIf this exception condition was removed on purpose, then code_challenge should be marked as REQUIRED only, not REQUIRED or RECOMMENDED as marked in Section 4.1.1. If this exception was meant to be moved to somewhere else, the reference link should be updated.\r\n\r\n## 2. There is No \"the following\"\r\n\r\n> In this case, using and enforcing code_challenge and code_verifier as described in the following is still RECOMMENDED.\r\n\r\nHowever, \"the following\" no longer describes the generation & transformation process of code_challenge and code_verfier, which was also only present in [v1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-01#name-authorization-request).\r\n\r\nGenerally speaking, there is currently some contradictions about the requirements of code_challenge.\r\n",
      "createdAt": "2024-12-14T03:59:11Z",
      "updatedAt": "2024-12-14T03:59:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 200,
      "id": "I_kwDODkfq5s6j9NPD",
      "title": "Reorganize section 7.1.1",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/200",
      "state": "OPEN",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tlodderstedt"
      ],
      "labels": [],
      "body": "reorganize access token threats section",
      "createdAt": "2024-12-19T15:41:33Z",
      "updatedAt": "2024-12-19T15:41:35Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 201,
      "id": "I_kwDODkfq5s6kLMEK",
      "title": "Relations with COAP / RFC9200",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/201",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## Question\r\n\r\nIt seems that there are non-TLS-based implementations of OAuth.\r\nShould we better decouple the flows from channel requirements?\r\n\r\nSee https://datatracker.ietf.org/doc/rfc9200/",
      "createdAt": "2024-12-21T23:05:04Z",
      "updatedAt": "2024-12-21T23:05:04Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 209,
      "id": "I_kwDODkfq5s6yzsSd",
      "title": "what does it mean to \"sanitise\" state/redirect urls?",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/209",
      "state": "OPEN",
      "author": "jogu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://drafts.oauth.net/oauth-v2-1/draft-ietf-oauth-v2-1.html#section-7.11 says:\n\n> A code injection attack occurs when an input or otherwise external variable is used by an application unsanitized and causes modification to the application logic. This may allow an attacker to gain access to the application device or its data, cause denial of service, or introduce a wide range of malicious side-effects.[\u00b6](https://drafts.oauth.net/oauth-v2-1/draft-ietf-oauth-v2-1.html#section-7.11-1)\n>\n> The authorization server and client MUST sanitize (and validate when possible) any value received -- in particular, the value of the state and redirect_uri parameters.[\u00b6](https://drafts.oauth.net/oauth-v2-1/draft-ietf-oauth-v2-1.html#section-7.11-2)\n\nI don't really know what \"sanitize\" means here. I don't think it would be correct for an AS to remove some characters from state because it decided it didn't like them - the only sane option seems to be to reject the request.\n\n(From a discussion on today's FAPI WG call)",
      "createdAt": "2025-04-16T14:47:20Z",
      "updatedAt": "2025-04-19T00:12:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "That's copy pasted from RFC6749, maybe @dickhardt remembers the context of adding that in the first place?\n\nhttps://www.rfc-editor.org/rfc/rfc6749.html#section-10.14",
          "createdAt": "2025-04-16T14:49:23Z",
          "updatedAt": "2025-04-16T14:49:23Z"
        },
        {
          "author": "gffletch",
          "authorAssociation": "NONE",
          "body": "Personally, I'd prefer 2.1 to say that state values MUST be URL safe... but that would be a pretty big breaking change :( Maybe we can make it a SHOULD to encourage people to move away from VSCHAR?\n\nOpenID4VP restricts nonces to...\n> Values MUST only contain ASCII URL safe characters (uppercase and lowercase letters, decimal digits, hyphen, period, underscore, and tilde).",
          "createdAt": "2025-04-16T14:49:44Z",
          "updatedAt": "2025-04-16T14:52:55Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "The intent of the sanitize guidance was to remind implementors to use their \"standard\" sanitization code to protect against SQL injections etc. I believe we left it vague on exactly what to do so that implementors would respond to new attacks, or attacks specific to their deployment. In other words, including this phrase \"seemed like a good idea at the time\".\n\nNow that a redirect_uri has to be a direct match, there is less concern about it.\n\nA restricted character set for a state parameter would have been a good idea so it could be validated. \n\n@jogu I agree that a parameter should not be modified. If it is non-conforming, then the request should be rejected.\n\nPerhaps sanitizing should be dropped from this section and we should warn implementors to treat the parameters as random strings that could be malicious -- or some similar language? \n",
          "createdAt": "2025-04-19T00:12:22Z",
          "updatedAt": "2025-04-19T00:12:22Z"
        }
      ]
    },
    {
      "number": 210,
      "id": "I_kwDODkfq5s6zi2UN",
      "title": "Add definitions for client_secret_basic, client_secret_post and none client authentication methods",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/210",
      "state": "OPEN",
      "author": "ThisIsMissEm",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Whilst the revised text in OAuth 2.1 does clear up a lot of my concerns from the OAuth mailing list, it still doesn't explicitly define the methods by name from what I can see.\n\nIt would be good to have these named methods very clearly defined in this revision.\n\nhttps://mailarchive.ietf.org/arch/msg/oauth/QGJfkCMqN2kVMRMDwvCiF3mZ6r4/",
      "createdAt": "2025-04-22T22:21:41Z",
      "updatedAt": "2025-04-28T00:26:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "PRs are welcome!\r\n\u1427\r\n\r\nOn Tue, Apr 22, 2025 at 3:22\u202fPM Emelia Smith ***@***.***>\r\nwrote:\r\n\r\n> Whilst the revised text in OAuth 2.1 does clear up a lot of my concerns\r\n> from the OAuth mailing list, it still doesn't explicitly define the methods\r\n> by name from what I can see.\r\n>\r\n> It would be good to have these named methods very clearly defined in this\r\n> revision.\r\n>\r\n> https://mailarchive.ietf.org/arch/msg/oauth/QGJfkCMqN2kVMRMDwvCiF3mZ6r4/\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/oauth-wg/oauth-v2-1/issues/210>, or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAFIGVVPUX5XKICDV5KSAUD2226IZAVCNFSM6AAAAAB3U2AHX2VHI2DSMVQWIX3LMV43ASLTON2WKOZTGAYTEMRVG4YDGNY>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n> *ThisIsMissEm* created an issue (oauth-wg/oauth-v2-1#210)\r\n> <https://github.com/oauth-wg/oauth-v2-1/issues/210>\r\n>\r\n> Whilst the revised text in OAuth 2.1 does clear up a lot of my concerns\r\n> from the OAuth mailing list, it still doesn't explicitly define the methods\r\n> by name from what I can see.\r\n>\r\n> It would be good to have these named methods very clearly defined in this\r\n> revision.\r\n>\r\n> https://mailarchive.ietf.org/arch/msg/oauth/QGJfkCMqN2kVMRMDwvCiF3mZ6r4/\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/oauth-wg/oauth-v2-1/issues/210>, or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AAFIGVVPUX5XKICDV5KSAUD2226IZAVCNFSM6AAAAAB3U2AHX2VHI2DSMVQWIX3LMV43ASLTON2WKOZTGAYTEMRVG4YDGNY>\r\n> .\r\n> You are receiving this because you are subscribed to this thread.Message\r\n> ID: ***@***.***>\r\n>\r\n",
          "createdAt": "2025-04-22T22:29:35Z",
          "updatedAt": "2025-04-22T22:29:35Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "NONE",
          "body": "To be honest, the reason I opened the issue is because I'm not sure exactly how we'd want to structure this information in this I-D that I don't work on currently.",
          "createdAt": "2025-04-27T14:52:42Z",
          "updatedAt": "2025-04-27T14:52:42Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "That's fine. Would you be up for summarizing your email in the issue?",
          "createdAt": "2025-04-27T15:39:52Z",
          "updatedAt": "2025-04-27T15:39:52Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "NONE",
          "body": "I believe I have already: the client authentication mechanism mentioned by name above aren't formally specified \u2014 they are given names in RFC7591 (DCR) but the definitions linked to in RFC6749 are not without a lot of room for interpretation.\n\nE.g., can you use `client_secret_basic` without a \"password\" value in the HTTP Basic Authentication header?\n\nAlso, the links in RFC7591 are broken & reference internal sections that do not exist",
          "createdAt": "2025-04-27T16:11:33Z",
          "updatedAt": "2025-04-27T16:11:33Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Any hints on what is not clear and needs clarity is useful. For example, why would you want to use `client_secret_basic` without a password value? I would think that you would need to include a password if using `client_secret_basic`. ",
          "createdAt": "2025-04-27T23:51:54Z",
          "updatedAt": "2025-04-27T23:51:54Z"
        },
        {
          "author": "ThisIsMissEm",
          "authorAssociation": "NONE",
          "body": "> I would think that you would need to include a password if using client_secret_basic.\n\nRight, but that behaviour isn't specified, I think I'd agree you'd need to pass the client_secret via the http basic authentication password to use client_secret_basic, just like client_secret_post requires client_secret",
          "createdAt": "2025-04-28T00:26:15Z",
          "updatedAt": "2025-04-28T00:26:15Z"
        }
      ]
    },
    {
      "number": 211,
      "id": "I_kwDODkfq5s608hIL",
      "title": "Refresh Tokens",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/211",
      "state": "OPEN",
      "author": "PieterKas",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The draft has extensive reference to access tokens in the security considerations section, but appears silent on refresh tokens. Consider adding a security considerations for Refresh tokens that references the Security BCP (RFC9700). ",
      "createdAt": "2025-05-02T11:08:45Z",
      "updatedAt": "2025-05-02T11:08:45Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 212,
      "id": "I_kwDODkfq5s62peIT",
      "title": "guidance on rotating refreshing tokens and dealing with",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/212",
      "state": "OPEN",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "we should provide guidance on the impact of a refresh that fails where the old refresh token is now invalid but the new refresh token did not get to the client because of an error along the way",
      "createdAt": "2025-05-14T21:32:58Z",
      "updatedAt": "2025-05-16T15:56:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "surbas",
          "authorAssociation": "NONE",
          "body": "Appreciated this one. Depending on the oauth2 provider we sometimes lose up to 1% of active connections in a day, which means for us somebodies automated workflow breaking down and requiring re-authentication.... which is annoying. With some, we have been able to convinced them, that if they value resiliency more then the incremental secure gain, that they should allow more then one (2 or 3) refresh token to be valid. This is not as secure (by some amount), but the trade off is the connection is more resilient. Having some guidance in the spec around this discussion would help tremendously to at least start to having these conversations. Let me know how I can help!",
          "createdAt": "2025-05-16T15:31:57Z",
          "updatedAt": "2025-05-16T15:31:57Z"
        },
        {
          "author": "brockallen",
          "authorAssociation": "NONE",
          "body": "I think there was already guidance that one-time use refresh tokens are not really ideal, and don't provide the security benefits originally thought. Perhaps it was in the browser-based apps BCP (BFF) doc?",
          "createdAt": "2025-05-16T15:55:44Z",
          "updatedAt": "2025-05-16T15:56:00Z"
        }
      ]
    },
    {
      "number": 213,
      "id": "I_kwDODkfq5s62phJT",
      "title": "guidance on issues of using personal oauth flows for a service to get long term access and then refresh fails and then service does not have access",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/213",
      "state": "OPEN",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dickhardt"
      ],
      "labels": [],
      "body": "feedback from AuthCon ",
      "createdAt": "2025-05-14T21:41:04Z",
      "updatedAt": "2025-05-22T22:13:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "voidmain",
          "authorAssociation": "NONE",
          "body": "A good example is something like this (application is synonymous with client):\n\n1. Application uses Personal (i.e. human clicking) OAuth flow to get an access token and refresh token\n2. Application stores these tokens in the database\n3. Application uses access token to make API calls\n4. At some point in the future, application either checks the token (JWT) to see if it is expired or makes an API call and gets a error response indicating it is expired\n5. Application then requests a new access token via the Refresh Token Grant\n6. Server generates new access token and new refresh token, since it rotates refresh tokens during the Refresh Token Grant\n7. Network/server crashes and application never sees the response\n8. Application can no longer call APIs and cannot refresh its tokens either\n\nIn this case, the refresh token the application has in the database is invalid as is the access token, but the application has no way to recover since the new refresh token is lost. This requires that the user logs back into the application and completes the Personal OAuth flow again in order to generate 2 new tokens (access and refresh). Until a user logs in and actively completes this process, the application is essentially inoperable with respect to the service it is using the tokens to interact with.\n\nThere is likely a discussion around storing N refresh tokens and deleting the oldest ones once newer ones have been used. However, this seems to be just as risky as never rotating refresh tokens, which basically solve this problem entirely.",
          "createdAt": "2025-05-15T15:40:17Z",
          "updatedAt": "2025-05-15T15:40:17Z"
        },
        {
          "author": "njwatson32",
          "authorAssociation": "NONE",
          "body": "An option that would likely address the majority of practical problems is to allow a small grace period before the AS invalidates the old RT, e.g. 60 seconds. This allows the client to retry transient errors with the old RT. I don't think this compromises the security of RT rotation _too_ much, as an attacker with a stolen RT would need to ensure nearly synchronized refreshes with the real client in order to keep the token active. Real clients can guard against this by introducing jitter in their RT refresh cadence.",
          "createdAt": "2025-05-20T17:33:46Z",
          "updatedAt": "2025-05-20T17:33:46Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Another option would be to use DPoP in the initial token request, and in refreshes, which would provide assurance it is the same client on refresh which could remove the desire of rotating refresh tokens. \n\n@voidmain would managing DPoP be preferable to the rotating refresh token issues?",
          "createdAt": "2025-05-21T01:25:58Z",
          "updatedAt": "2025-05-21T01:25:58Z"
        },
        {
          "author": "voidmain",
          "authorAssociation": "NONE",
          "body": "@njwatson32 - a grace period would certainly work. However, that type of solution should be configurable and will require some testing. It's similar in nature to a thread-safety issue where timing comes in to play and it's not always deterministic when the second request will happen or if it will fail.\n\nFor example, the IDP might be in an AWS Region that experiences an outage and the first request occurred right as the outage started. That means the second request might be 30 minutes later.\n\n@dickhardt - I don't think DPoP helps much because this is a race condition not a proof problem. Can you expand on your DPoP idea so we can discuss?",
          "createdAt": "2025-05-21T20:20:23Z",
          "updatedAt": "2025-05-21T20:20:23Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@voidmain DPoP could allow an AS to *not* rotate the refresh token, removing any race condition. ",
          "createdAt": "2025-05-21T22:26:50Z",
          "updatedAt": "2025-05-21T22:26:50Z"
        },
        {
          "author": "voidmain",
          "authorAssociation": "NONE",
          "body": "@dickhardt - Ah. That makes sense. Though leaking keys and refresh tokens is still an issue. But it would at least reduce some threat vectors.\n\nHowever, I would only make that one of the possible options. This allows clients that don't want to or aren't capable of using DPoP to still handle refresh token issues with a configurable grace period.",
          "createdAt": "2025-05-21T22:34:42Z",
          "updatedAt": "2025-05-21T22:34:42Z"
        },
        {
          "author": "njwatson32",
          "authorAssociation": "NONE",
          "body": "@voidmain yeah, the grace period likely won't address that AWS regional example you gave, but I'd expect that to be a small outlier compared to the much more common transient network errors. Configurable grace period also seems reasonable.",
          "createdAt": "2025-05-21T22:42:30Z",
          "updatedAt": "2025-05-21T22:42:30Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@voidmain why would DPoP not be possible for a client? \n\nA configurable grace period would be new functionality, which is out of scope for OAuth 2.1\n\nDPoP is an existing spec and using it is a best practice. ",
          "createdAt": "2025-05-22T00:03:03Z",
          "updatedAt": "2025-05-22T00:03:03Z"
        },
        {
          "author": "voidmain",
          "authorAssociation": "NONE",
          "body": "@dickhardt - ah the challenge of getting customers to use features. WebAuthn is still at less than 10% adoption still. And some customers still don't use PCKE.\n\nAs a vendor, we rarely force things. For FusionAuth, we would make this optional, even if the spec requires it. Otherwise, customers will go find a solution where it's optional.\n\nWe even break spec and allow wildcards on `redirect_uri`, because.... customers demand that feature.",
          "createdAt": "2025-05-22T17:35:21Z",
          "updatedAt": "2025-05-22T17:35:21Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "@voidmain you are free to implement whatever you want of course! ... and I'm a big fan of giving customers what they want. \n\nAs an industry we have a responsibility to improve the security of our customers, and to design things that work. The refresh is a problematic space. We can provide guidance wrt a grace period as a best practice. \n\nWe can also describe how DPoP can be a substitute for rotating refresh tokens.\n\n>  WebAuthn is still at less than 10% adoption still.\n\nI'm not surprised ... but that is a different spec! :) ",
          "createdAt": "2025-05-22T20:47:47Z",
          "updatedAt": "2025-05-22T20:47:47Z"
        },
        {
          "author": "voidmain",
          "authorAssociation": "NONE",
          "body": "@dickhardt - agreed on all of that. Just want to give choices and options and only use the word \"MUST\" when absolutely necessary. \ud83d\ude01",
          "createdAt": "2025-05-22T21:51:32Z",
          "updatedAt": "2025-05-22T21:51:32Z"
        },
        {
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "body": "Even with a MUST -- your implementation can do whatever it wants!",
          "createdAt": "2025-05-22T22:13:02Z",
          "updatedAt": "2025-05-22T22:13:02Z"
        }
      ]
    },
    {
      "number": 214,
      "id": "I_kwDODkfq5s65ioBa",
      "title": "Make PKCE optional when DPoP + PAR are used",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/214",
      "state": "OPEN",
      "author": "matthieusieben",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Section [4.1.2.1. Error Response](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11#name-error-response-2) contains:\n\n> An AS MUST reject requests without a code_challenge from public clients, and MUST reject such requests from other clients unless there is reasonable assurance that the client mitigates authorization code injection in other ways. See [Section 7.5.1](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11#authorization_codes) for details.\n\nIn instances where PAR + DPoP (during PAR) are used, it seems that PKCE can be made completely optional. Even for public clients.\n\n[7.5.2. Countermeasures](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-11#section-7.5.2) could also be adapted to make PKCE optional when DPoP is used during PAR.\n\n",
      "createdAt": "2025-06-03T07:50:51Z",
      "updatedAt": "2025-06-03T07:57:02Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 215,
      "id": "I_kwDODkfq5s665Bl7",
      "title": "Phishing/Audience Mix-Up Mitigation for Resources",
      "url": "https://github.com/oauth-wg/oauth-v2-1/issues/215",
      "state": "OPEN",
      "author": "mcguinness",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "A client currently has no way to detect whether an authorization server supports the [RFC 8707 Resource Indicators for OAuth 2.0](https://www.rfc-editor.org/rfc/rfc8707.html) extension.  An authorization server that implements support for RFC 8707 would process a requested `resource` and audience-restrict the issued access token if the resource was valid or return an `invalid_target` error code if the requested `resource` is not valid for the authorization server.  If the authorization server doesn't support RFC 8707 it would silently ignore the `resource` parameter and issue an access token to its default audience for the request (e.g  client+scopes requested).  \n\nSince the `access_token` in the token response is opaque to the client, the client has no way to know the value of the issued token's audience.  This is especially problematic when using metadata to dynamically discover an authorization server such as with [OAuth 2.0 Protected Resource Metadata  (RFC 9728)](https://www.rfc-editor.org/rfc/rfc9728.html). \n\nFor example `resource.example` could publish `https://resource.example` as the `resource` identifier but specify `https://accounts.google.com/o/oauth2/v2/auth` as the authorization server as a phishing attack.  A client would then attempt to obtain an access token from the specified authorization server with the dynamically discovered `resource`  \n\n`https://accounts.google.com/o/oauth2/v2/auth?client_id=...&scope=...&resource=https://resource.example`. \n\nIf the authorization doesn't support RFC 8707 then it would just process this as a normal authorization request, ignore the invalid resource, and issue a default access token (assuming user consented).   This is the [exact scenario that Model Context Protocol (MCP](https://github.com/modelcontextprotocol/modelcontextprotocol/pull/284#discussion_r2068009348)) project is vulnerable to which has taken a dependency on OAuth 2.1\n\nWhile this security risk is explicitly called out in the security considerations of RFC 9728, the interoperability gap still exists for an OAuth 2.1.\n\n> Secure determination of appropriate authorization servers to use with a protected resource for all use cases is out of scope for this specification. This specification assumes that the client has a means of determining appropriate authorization servers to use with a protected resource and that the client is using the correct metadata for each protected resource. Implementers need to be aware that if an inappropriate authorization server is used by the client, an attacker may be able to act as an adversary-in-the-middle proxy to a valid authorization server without it being detected by the authorization server or the client.\n\nIf OAuth 2.1 included the [RFC 8707 Resource Indicators for OAuth 2.0](https://www.rfc-editor.org/rfc/rfc8707.html) extension, clients could expect an authorization server to process the `resource` or return `invalid_target` error code.  This would help projects like MCP mitigate risks of using metadata based discovery.   **An authorization doesn't need to support `resource` indicators to be complaint.  It just needs to return `invalid_target` if a `resource` is specified.** .  This is small lift for an authorization (support an error code) has a ton a value for dynamic discovery scenarios.\n\nAlternatively, OAuth 2.1 could specify a new token response field for `audience`.  This would push validation to the client to ensure the that issued token was for an audience it wanted and prevent forwarding a token to a resource server with a mismatched audience.   Since audience doesn't need to be 1:1 to a resource's url this is problematic but could be profiled. ",
      "createdAt": "2025-06-11T05:18:11Z",
      "updatedAt": "2025-06-21T17:48:32Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jaredhanson",
          "authorAssociation": "NONE",
          "body": "We are currently implementing SDKs at @keycardlabs which ensure that MCP clients can securely access MCP servers protected by OAuth 2.0, where both the MCP server and OAuth authorization server are dynamically discovered by the MCP client.   This discovery is happening via [OAuth 2.0 Protected Resource Metadata (RFC 9728)](https://datatracker.ietf.org/doc/html/rfc9728) and [OAuth 2.0 Authorization Server Metadata (RFC 8414)](https://datatracker.ietf.org/doc/html/rfc8414), per the current [draft](https://modelcontextprotocol.io/specification/draft/basic/authorization) of MCP authorization.\n\nIt is clear that confused deputy/mix-up vulnerabilities are inherent today, wherein MCP clients will present access tokens obtained from any OAuth authorization server chosen by the MCP server - even in cases where MCP server is not the intended audience.  This, in turn, allows the MCP server to access resources using that access token, even though it has not been authorized to do so.\n\nIn order to fully secure these dynamic discover flows, I'm currently of the opinion that the client needs to take an active role in validating where it sends tokens to (as noted @mcguinness's last paragraph).   What I would expect is a flow such as:\n\n1.  MCP/OAuth client makes a protected resource request, receives a 401 challenge with `resource_metadata` parameter, per [section 5.1](https://datatracker.ietf.org/doc/html/rfc9728#section-5.1) of RFC 9728.\n2. MCP/OAuth client fetches protected resource metadata, and obtains resource identifier from `resource` parameter and authorization server issuer identifiers from `authorization_servers` parameter.\n3. MCP/OAuth client fetches authorization server metadata.\n4. MCP/OAuth client makes an authorization request, including a `resource` parameter set to the resource identifier obtained in step 2, per [section 2.1](https://datatracker.ietf.org/doc/html/rfc8707#name-authorization-request) of RFC 8707.\n5. Authorization server processes the authorization request and, if authorized, issues an authorization code.\n6. MCP/OAuth client exchanges the authorization code for access token\n7. Authorization server includes (new) `resource` parameter in token response.\n8. MCP/OAuth client verifies that `resource` parameter in token response matches the resource identifier obtained from metadata in step 2.\n9. Assuming verification passes in step 8, MCP/OAuth client uses access token to make protected resource request.\n\nNote that this flow works in any dynamic scenario involving API access.  For instance, its equally applicable to HTTP or REST APIs.  I'm just using MCP for illustrative purposes as it is currently in focus.\n",
          "createdAt": "2025-06-16T23:19:06Z",
          "updatedAt": "2025-06-16T23:19:06Z"
        },
        {
          "author": "mcguinness",
          "authorAssociation": "NONE",
          "body": "> * Authorization server includes (new) `resource` parameter in token response.\n\n@jaredhanson I was expecting this as well.  Unfortunately we may need to draft a net new extension for this based on my chat with @aaronpk.  Its a big miss that this wasn't included in RFC 8707.  I was also surprised this also wasn't included in [RFC 9700 Best Current Practice for OAuth 2.0 Security](https://datatracker.ietf.org/doc/html/rfc9700) and may need to go into the next revision",
          "createdAt": "2025-06-17T06:12:06Z",
          "updatedAt": "2025-06-17T06:12:54Z"
        },
        {
          "author": "randomstuff",
          "authorAssociation": "NONE",
          "body": "> It is clear that confused deputy/mix-up vulnerabilities are inherent today, wherein MCP clients will present access tokens obtained from any OAuth authorization server chosen by the MCP server - even in cases where MCP server is not the intended audience.\n\nCurrently, a fix is to make sure you are getting a proof-of-possesion token. This assumes that proof-of-possesion tokens are properly supported by the ASs and RSs (and the client), though.\n\nSee for example, [a related attack](https://www.gabriel.urdhr.fr/2025/03/18/uma-pass-the-permission-token/#description) in the UMA protocol.",
          "createdAt": "2025-06-17T07:46:11Z",
          "updatedAt": "2025-06-17T07:46:11Z"
        },
        {
          "author": "KevinLuo2000",
          "authorAssociation": "NONE",
          "body": "> > * Authorization server includes (new) `resource` parameter in token response.\n> \n> [@jaredhanson](https://github.com/jaredhanson) I was expecting this as well. Unfortunately we may need to draft a net new extension for this based on my chat with [@aaronpk](https://github.com/aaronpk). Its a big miss that this wasn't included in RFC 8707. I was also surprised this also wasn't included in [RFC 9700 Best Current Practice for OAuth 2.0 Security](https://datatracker.ietf.org/doc/html/rfc9700) and may need to go into the next revision\n\nIf I understand correctly, the recommendation **not** to rely on _client-side_ `resource` parameter matching in the access token response is discussed in [RFC9700 Section 4.10.3](https://www.rfc-editor.org/rfc/rfc9700#section-4.10.3). Instead, enforcement mechanisms on _resource server-side_, such as audience-restriction, are currently recommended.\n",
          "createdAt": "2025-06-19T09:44:54Z",
          "updatedAt": "2025-06-19T09:57:54Z"
        },
        {
          "author": "jesperkristensen",
          "authorAssociation": "NONE",
          "body": "I don't think returning invalid_target is enough, because RFC 8707 Resource Indicators for OAuth 2.0 says that the resource parameter represents an identity which MAY equal a locator. (implying that it may also be totally undelated)\n\nSure, in places I have seen where the AS treats the resource parameter as an abstract identifier, I have also seen recommendations to use an URI scheme that is not confusable, e.g. using api://my-resource-identity instead of https://my-resource-identity/, but I would not count on that always happening, especially since RFC 8707 itself does not have any recommendation on that.\n\nI never understood why RFC 9728 OAuth 2.0 Protected Resource Metadata lists both client and AS as potential users. I can see how an AS might use it, but for a client to use RFC 9728 it must know where the AS intended the access token to be used, and I am not aware of any machine readable way for the client to discover where it is safe to use an access token.",
          "createdAt": "2025-06-21T17:08:04Z",
          "updatedAt": "2025-06-21T17:08:04Z"
        },
        {
          "author": "mcguinness",
          "authorAssociation": "NONE",
          "body": "1. Client should know whether a given Authorization Server supports resource-based authorization or token requests\n2. Client should know what the outcome of a resource indicator token request and not guess based on absence of error code .  This is useful not only for client-side security but also caching purposes.  Clients may want to store tokens in a cooke-jar like fashion for multiple resources\n3. RS should require proof-of-possession tokens such as DPOP to ensure intermediates can't replay tokens\n\nThe scenario that is of concern for projects like MCP is that a RS may publish an Authorization Server that it wants to phish a token from and that Authorization Server (e.g. accounts.google.com) or its protected resources may not require proof-of-possession (e.g Google APIs).   If the API that the attackers wants to use doesn't require possession then there are not mechanisms for a client-side enforcement/defense when using resource based requests.\n\nI am going to write up a draft for a token response param and will see what folks think.\n\n",
          "createdAt": "2025-06-21T17:48:32Z",
          "updatedAt": "2025-06-21T17:48:32Z"
        }
      ]
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgzMDkwNTY2",
      "title": "Master",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/1",
      "state": "MERGED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Incorporated recommendations from Security BCP",
      "createdAt": "2020-03-03T17:50:14Z",
      "updatedAt": "2020-03-03T22:54:45Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "master",
      "baseRefOid": "3dfa2f69085b4166759e60f1575edb4b8403ed38",
      "headRepository": "oauthstuff/OAuth-2.1",
      "headRefName": "master",
      "headRefOid": "bdba8e0be221e1c51d6870b061655ba0f6936802",
      "closedAt": "2020-03-03T22:54:45Z",
      "mergedAt": "2020-03-03T22:54:45Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "879ed69c76846993dde62b1629537b8acc66d331"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Mzg1NTc4",
          "commit": {
            "abbreviatedOid": "bdba8e0"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-03T22:52:13Z",
          "updatedAt": "2020-03-03T22:52:13Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0MDMwNzQ4",
      "title": "updated intro",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/2",
      "state": "MERGED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Edited intro to reflect what this document is about\r\n\r\nchanged some OAuth 2.0 references to OAuth 2.1 when referring to this document\r\n\r\nchanged document name to follow ID standard name (repo and filename should be updated as well?)\r\n\r\npulled out acknowledgments as this doc will be different",
      "createdAt": "2020-03-05T02:18:51Z",
      "updatedAt": "2020-03-05T02:28:25Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "master",
      "baseRefOid": "86fe73c7319cb34d31093f3ded52406d668ab210",
      "headRepository": null,
      "headRefName": "new_intro",
      "headRefOid": "b1329eb00f396915237fe3cb6acd288317dcbb7e",
      "closedAt": "2020-03-05T02:28:25Z",
      "mergedAt": "2020-03-05T02:28:25Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "e2f2a833a7d2f3f9b183079023469dfd237cf24a"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 3,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1MDY3NzM1",
      "title": "V2v3",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/3",
      "state": "MERGED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "changed version separator to '_' from '-' to minimize processing issues\r\nadded md2xml2html build script\r\nfixed xml2rfc v3 issues",
      "createdAt": "2020-03-06T23:44:55Z",
      "updatedAt": "2020-03-07T16:25:07Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "master",
      "baseRefOid": "5dd7e97570d153663961ed41ec7b38234138972e",
      "headRepository": null,
      "headRefName": "v2v3",
      "headRefOid": "e3159afe0d27e9eedaaad1ea82e40c40d9a5fd31",
      "closedAt": "2020-03-07T16:25:07Z",
      "mergedAt": "2020-03-07T16:25:07Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "e1cde70f2b4eaddf54f9b33baed1374f272b6134"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzUyMzA0",
          "commit": {
            "abbreviatedOid": "e3159af"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-07T16:24:50Z",
          "updatedAt": "2020-03-07T16:24:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1MTg0NDMw",
      "title": "corrected affiliation",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/4",
      "state": "MERGED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Writing yes.com, removed country",
      "createdAt": "2020-03-07T19:29:24Z",
      "updatedAt": "2020-03-07T19:31:31Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "master",
      "baseRefOid": "3fa5697b840260388c27f6ac9c19b0ce49ff6d13",
      "headRepository": "oauthstuff/OAuth-2.1",
      "headRefName": "master",
      "headRefOid": "929aecaea4a8a58f1e1fdbb7a33677286b202dc4",
      "closedAt": "2020-03-07T19:31:31Z",
      "mergedAt": "2020-03-07T19:31:31Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "0b3d7c37291f8ac5093220c3b8f9ca0856fdaf5c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzg0NTY4",
          "commit": {
            "abbreviatedOid": "929aeca"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-07T19:31:26Z",
          "updatedAt": "2020-03-07T19:31:26Z",
          "comments": []
        }
      ]
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1MjQ4NjQ2",
      "title": "Merge branch 'aaronpk/master'",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/5",
      "state": "MERGED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reworked response type extension point description",
      "createdAt": "2020-03-08T10:05:42Z",
      "updatedAt": "2020-03-08T15:20:43Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "master",
      "baseRefOid": "b17ffd189029b0300d6c74883116a2c807706fa1",
      "headRepository": "oauthstuff/OAuth-2.1",
      "headRefName": "master",
      "headRefOid": "1a6a4a8fcaa2de5e496c9bc76934e9156d2624d3",
      "closedAt": "2020-03-08T15:20:43Z",
      "mergedAt": "2020-03-08T15:20:43Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "df9a9d1dc3011564296057fbd5874471aa842323"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Looks like this is missing a commit?",
          "createdAt": "2020-03-08T14:06:58Z",
          "updatedAt": "2020-03-08T14:06:58Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODM3ODUx",
          "commit": {
            "abbreviatedOid": "1a6a4a8"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-08T15:20:37Z",
          "updatedAt": "2020-03-08T15:20:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1Mjc5OTE5",
      "title": "Changes to build --v3 html",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/6",
      "state": "MERGED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changed md and sh",
      "createdAt": "2020-03-08T15:32:59Z",
      "updatedAt": "2020-03-08T15:38:39Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "master",
      "baseRefOid": "df9a9d1dc3011564296057fbd5874471aa842323",
      "headRepository": "oauthstuff/OAuth-2.1",
      "headRefName": "master",
      "headRefOid": "9125f80557fc03fe845df569ad5dd8532adf3e0b",
      "closedAt": "2020-03-08T15:38:39Z",
      "mergedAt": "2020-03-08T15:38:39Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "b616395cb96deb316554b0c8675cb8c4fd5eb2ad"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1Mjk1MTQx",
      "title": "modfied text about client types and PKCEjustificatzionremoved xml2rfc file",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/7",
      "state": "MERGED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "modified text about client types and PKCE justification\nremoved xml2rfc file",
      "createdAt": "2020-03-08T18:04:36Z",
      "updatedAt": "2020-03-08T18:54:34Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "master",
      "baseRefOid": "77dd28592b53ccbdae675b7214928ae7bbd1832c",
      "headRepository": "oauthstuff/OAuth-2.1",
      "headRefName": "master",
      "headRefOid": "278a9bca0376e320c843d55c50c6aab4f535af8a",
      "closedAt": "2020-03-08T18:54:34Z",
      "mergedAt": "2020-03-08T18:54:34Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "1b3d8e87178fd818c4836c18a05e287a84aa29d7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 8,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg1MzA1NDU1",
      "title": "Master",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/8",
      "state": "MERGED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Added missing WG assignment",
      "createdAt": "2020-03-08T19:46:57Z",
      "updatedAt": "2020-03-10T15:58:20Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "master",
      "baseRefOid": "9f74268c4493b74973641046c1f4cd5795a2173e",
      "headRepository": "oauthstuff/OAuth-2.1",
      "headRefName": "master",
      "headRefOid": "512b18cf3aacb8caf7685842223a0ae71ce97f83",
      "closedAt": "2020-03-10T15:58:20Z",
      "mergedAt": "2020-03-10T15:58:20Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "45e9a6a989d3890758d912085b41a9fd02c59a03"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 16,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM0Mzg3ODI3",
      "title": "Improve PKCE usage description. ",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/16",
      "state": "MERGED",
      "author": "danielfett",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-06-15T08:53:24Z",
      "updatedAt": "2020-06-17T21:58:21Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "26194c4a4ef43fde3540403d637461eb1f4d7a9d",
      "headRepository": "danielfett/oauth-v2-1",
      "headRefName": "main",
      "headRefOid": "936a23f47bc26e1defed9945fe1adf22826f495a",
      "closedAt": "2020-06-17T21:58:21Z",
      "mergedAt": "2020-06-17T21:58:21Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "024ab42bfc608b52483f14eebb2efe93802d6594"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODA2MjI1",
          "commit": {
            "abbreviatedOid": "936a23f"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-17T21:58:17Z",
          "updatedAt": "2020-06-17T21:58:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 17,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4ODY1ODQz",
      "title": "Editorial",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/17",
      "state": "MERGED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I named the 3rd type of client type with a placeholder name. What about \"credentialed\"?\r\n\r\nI have some questions inserted with [Dick: ...]",
      "createdAt": "2020-06-23T22:56:20Z",
      "updatedAt": "2020-06-30T03:24:39Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "9ae615b41da9f565b853057d53dae219d80ce681",
      "headRepository": null,
      "headRefName": "editorial",
      "headRefOid": "687943e89cbf47924838d9c571f06e8e46423bcb",
      "closedAt": "2020-06-30T03:24:39Z",
      "mergedAt": "2020-06-30T03:24:39Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "fef2385c19fe31595936612a47064fca06ae8227"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0NTEyMzQ3NzI3",
      "title": "Fix payload terminology",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/22",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\n- align terminology with RFC7231 term. \r\n\r\n## Note\r\n\r\nI'd consider switching to httpbis-semantics https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#payload",
      "createdAt": "2020-10-29T15:11:57Z",
      "updatedAt": "2021-02-01T15:33:41Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "3672054030cb479f3359e4586cb6b1ed114b27e6",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "patch-1",
      "headRefOid": "f469ef81270c7a6f5b3c23a05aea6d1c5a8a0b10",
      "closedAt": "2021-02-01T15:33:41Z",
      "mergedAt": "2021-02-01T15:33:41Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "1286539f594b4dba8bd7e0d43935fcab203ee999"
      },
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @dickhardt @aaronpk it would be great to have some feedback on this PR. In case I could brush even more the spec to ensure compatibility with the ongoing HTTP work :) ",
          "createdAt": "2021-01-28T12:08:09Z",
          "updatedAt": "2021-01-28T12:08:09Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thanks! I'm working on this this week so I will take a look soon!",
          "createdAt": "2021-01-28T14:23:09Z",
          "updatedAt": "2021-01-28T14:23:09Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk let me know if you need more feedback ;)",
          "createdAt": "2021-01-29T13:17:29Z",
          "updatedAt": "2021-01-29T13:17:29Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This looks great. I'm not sure of the other implications of switching the references to draft-ietf-httpbis-semantics so we can discuss that in a new issue if you'd like.",
          "createdAt": "2021-02-01T15:33:37Z",
          "updatedAt": "2021-02-01T15:33:37Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 30,
      "id": "MDExOlB1bGxSZXF1ZXN0NTczOTgxODQ4",
      "title": "Fix: #21. Reorganize TLS parts.",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/30",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nReorganize TLS parts:\r\n\r\n- move all references to TLS usage to a separate section\r\n- mention \"https\" scheme",
      "createdAt": "2021-02-16T07:11:11Z",
      "updatedAt": "2021-10-19T20:09:56Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "c9b0e5f2c1746cb042a82ed1a8efccbdbb1fbc23",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "ioggstream-21",
      "headRefOid": "45b2a00a05c3375b37bb42e6be0078879729a1ad",
      "closedAt": "2021-10-19T20:09:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk I tried to reorganize the TLS parts in a single section. As a first-time reader, I found the continuous reminders to TLS confusing and inherently suggesting that TLS was only required for some flows.",
          "createdAt": "2021-02-16T07:23:50Z",
          "updatedAt": "2021-02-16T07:23:50Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thanks, this is great, I'll discuss this with the other editors next time we talk!",
          "createdAt": "2021-02-17T00:15:16Z",
          "updatedAt": "2021-02-17T00:15:16Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @aaronpk As this is a draft PR I'm really open to improvements.",
          "createdAt": "2021-02-17T08:27:40Z",
          "updatedAt": "2021-02-17T08:27:40Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc: @peppelinux\r\n",
          "createdAt": "2021-02-17T08:28:14Z",
          "updatedAt": "2021-02-17T08:28:14Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk the IETF Using TLS in Applications wg is working on that  https://tools.ietf.org/html/draft-ietf-uta-rfc7525bis-00 \r\nwe could ping them too.  In the meanwhile I think this PR improves the readability of the current document.",
          "createdAt": "2021-03-09T11:06:04Z",
          "updatedAt": "2021-03-09T11:06:04Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I like the editorial improvements. Since this contains normative changes in #40 it is pending that discussion.",
          "createdAt": "2021-09-21T19:15:57Z",
          "updatedAt": "2021-09-21T19:15:57Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk let me know if/when you need a rebase.\r\n",
          "createdAt": "2021-09-21T19:58:07Z",
          "updatedAt": "2021-09-21T19:58:07Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "@ioggstream the group agreed to the normative change of requiring HTTPS for redirect URIs so I would like to merge this PR. Could you rebase it to fix the merge conflicts? Thanks!",
          "createdAt": "2021-10-18T21:10:17Z",
          "updatedAt": "2021-10-18T21:10:17Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk sure, but it will take some days :P hope it's not an issue...",
          "createdAt": "2021-10-18T22:08:37Z",
          "updatedAt": "2021-10-18T22:08:37Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "No problem, thanks!",
          "createdAt": "2021-10-18T22:09:41Z",
          "updatedAt": "2021-10-18T22:09:41Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Closing in favor of #98 ",
          "createdAt": "2021-10-19T20:09:56Z",
          "updatedAt": "2021-10-19T20:09:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA3MjczNjM5",
          "commit": {
            "abbreviatedOid": "89ea8ab"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-09T10:58:07Z",
          "updatedAt": "2021-03-09T10:58:07Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "```suggestion\r\nIf the client should be prevented from observing the contents of the token,\r\n```",
              "createdAt": "2021-03-09T10:58:07Z",
              "updatedAt": "2021-03-09T10:58:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA3Mjc1MzY5",
          "commit": {
            "abbreviatedOid": "89ea8ab"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-09T10:59:57Z",
          "updatedAt": "2021-03-09T10:59:58Z",
          "comments": [
            {
              "originalPosition": 178,
              "body": "@aaronpk not sure that an use-case requirement should use normative language (MUST)...",
              "createdAt": "2021-03-09T10:59:57Z",
              "updatedAt": "2021-03-09T10:59:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc3MDA0MTg4",
      "title": "Remove the Pragma header.",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/32",
      "state": "MERGED",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "These are suggested changes for a quite trivial issue. Please, take a look at my explanation in https://github.com/ietf-wg-gnap/gnap-core-protocol/pull/199#issuecomment-782567583 for more details.",
      "createdAt": "2021-02-20T20:47:29Z",
      "updatedAt": "2022-04-19T03:28:13Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "98489a0c5c03cb686b03030b20a07dae8eb47c31",
      "headRepository": null,
      "headRefName": "pragma",
      "headRefOid": "569a21608cadadebf0361d962c78a908ef925c08",
      "closedAt": "2021-04-23T22:58:44Z",
      "mergedAt": "2021-04-23T22:58:44Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "c04358ca4352d5c4b15bbe39a541d678898810b7"
      },
      "comments": [
        {
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "body": "https://mailarchive.ietf.org/arch/msg/oauth/5hCWu0tIRk11jnW6_M87Rx7S560/ \r\n\r\nhttps://tools.ietf.org/html/draft-parecki-oauth-v2-1-01#section-4.1.4\r\n\"   An example successful response:\r\n   HTTP/1.1 200 OK\r\n   Content-Type: application/json;charset=UTF-8\r\n   Cache-Control: no-store\r\n   Pragma: no-cache\"\r\nPretty sure application/json shouldn't have a charset (see note at end of\r\nsection https://tools.ietf.org/html/rfc8259#section-11)\r\nand **I've long thought that \"Pragma: no-cache\" shouldn't be there (see\r\nhttps://mailarchive.ietf.org/arch/msg/oauth/9DdkE2P0RrUZMeZAbdf3NrMfy0w/** )\r\nNote that these apply to most of the example responses in the draft.\r\n",
          "createdAt": "2021-03-16T12:51:28Z",
          "updatedAt": "2021-03-16T12:51:28Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 47,
      "id": "MDExOlB1bGxSZXF1ZXN0NTgzNDU2MjA5",
      "title": "Fix mnr typos",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/47",
      "state": "CLOSED",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-03T01:08:33Z",
      "updatedAt": "2021-03-23T23:33:13Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "e87857efde941ce8e06274615ec669aec995d892",
      "headRepository": null,
      "headRefName": "mnr_typo",
      "headRefOid": "73ae773819209d19eb99ec463827ef6b15ece9c2",
      "closedAt": "2021-03-19T22:11:57Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Recreated the typo fixes in 98489a0c5c03cb686b03030b20a07dae8eb47c31",
          "createdAt": "2021-03-19T22:11:57Z",
          "updatedAt": "2021-03-19T22:11:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2ODIzODQ0",
          "commit": {
            "abbreviatedOid": "73ae773"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T22:11:35Z",
          "updatedAt": "2021-03-19T22:11:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I would prefer to stick with the singular \"they\" so I'm re-creating the rest of these typos in a new commit instead",
              "createdAt": "2021-03-19T22:11:35Z",
              "updatedAt": "2021-03-19T22:11:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg4MzE5MDAx",
      "title": "Reference obsoleted/impacted specs. See #28",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/49",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nobsoletes OAuth 2.0\r\n\r\nNB: consider adding other specs obsoleted or updated by this one. \r\n\r\nRelated to #28\r\n\r\n\r\ncc: @aaronpk ",
      "createdAt": "2021-03-09T17:17:52Z",
      "updatedAt": "2021-09-21T19:09:55Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "e87857efde941ce8e06274615ec669aec995d892",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "patch-2",
      "headRefOid": "0c125e1ce776a744a845320c8903d7ceb63e1015",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Pending the outcome of the discussions in #28 ",
          "createdAt": "2021-09-21T19:09:55Z",
          "updatedAt": "2021-09-21T19:09:55Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkwOTAwNTM5",
      "title": "Reference HTTP Semantics instead of messaging",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/50",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\n- RFC7230 references HTTP Messaging aka HTTP/1.1. OAuth2.1 is agnostic of the HTTP version instead.\r\n\r\n## Note\r\n\r\nConsider that httpbis moves further definitions to [SEMANTICS](https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#user.agent) including \"user agent\" and the [\"https\" scheme](https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#https.uri) and provides some details on validation",
      "createdAt": "2021-03-11T14:19:57Z",
      "updatedAt": "2021-06-08T14:17:50Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "e87857efde941ce8e06274615ec669aec995d892",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "patch-3",
      "headRefOid": "0fc96b9538cc0f5aebb2ff1ec87d1195a694e42d",
      "closedAt": "2021-04-23T22:43:30Z",
      "mergedAt": "2021-04-23T22:43:30Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "43d9ae7f231d64cd41504c04c8115d7ac95ef7d7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkwOTAyODky",
      "title": "editorial: use the ::boilerplate macro for bcp14",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/51",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nuses the ::boilerplate macro of https://github.com/cabo/kramdown-rfc2629",
      "createdAt": "2021-03-11T14:23:09Z",
      "updatedAt": "2021-09-08T20:52:47Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "e87857efde941ce8e06274615ec669aec995d892",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "patch-4",
      "headRefOid": "335f4becaac8927a60e280955905794b4ccc2fb5",
      "closedAt": "2021-09-08T20:52:47Z",
      "mergedAt": "2021-09-08T20:52:47Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "a38e959fc21f5404e378c35597a9dca5041b7782"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "I'm not sure what I'm doing wrong but when I try this I get an error:\r\n\r\n```\r\n U+00A0 from UTF-8 to US-ASCII (Encoding::UndefinedConversionError)\r\n```\r\n\r\nI'm using kramdown-rfc2629 version 1.4.3",
          "createdAt": "2021-04-23T22:57:13Z",
          "updatedAt": "2021-04-23T22:57:13Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "fixed in https://github.com/aaronpk/oauth-v2-1/pull/51/commits/335f4becaac8927a60e280955905794b4ccc2fb5 @aaronpk ",
          "createdAt": "2021-04-25T21:44:34Z",
          "updatedAt": "2021-04-25T21:44:34Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Friendly reminder ;)",
          "createdAt": "2021-06-05T10:10:48Z",
          "updatedAt": "2021-06-05T10:10:48Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "PTAL",
          "createdAt": "2021-06-29T11:03:22Z",
          "updatedAt": "2021-06-29T11:03:22Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 52,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkwOTM1NDE4",
      "title": "RFC2617 is obsoleted by RFC7235",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/52",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nUses RFC7235 instead of obsoleted RFC2617",
      "createdAt": "2021-03-11T15:05:42Z",
      "updatedAt": "2021-06-08T14:17:30Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "e87857efde941ce8e06274615ec669aec995d892",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "patch-5",
      "headRefOid": "2c9246ba9c067564da837cc285dbfe13bfd5bef1",
      "closedAt": "2021-03-19T21:52:34Z",
      "mergedAt": "2021-03-19T21:52:34Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "4be7848bcc727fa6f1e6ebad0485464815b2219c"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 66,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk0MzgyMzQz",
      "title": "Changes for https://www.rfc-editor.org/errata/eid3446",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/66",
      "state": "MERGED",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-17T03:55:20Z",
      "updatedAt": "2021-06-08T14:13:06Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "67cb9989140460fed39a40f75a4aa4929f88fbd6",
      "headRepository": null,
      "headRefName": "eid3446",
      "headRefOid": "178b4e3454f84f70603db87d7761afdf220bc999",
      "closedAt": "2021-03-17T18:43:01Z",
      "mergedAt": "2021-03-17T18:43:01Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "0e7534246f03232468001aa4b4220870ba53d163"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk0MzgyNDY1",
      "title": "Changes for https://www.rfc-editor.org/errata/eid5793",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/67",
      "state": "MERGED",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-17T03:55:44Z",
      "updatedAt": "2021-06-08T14:12:00Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "67cb9989140460fed39a40f75a4aa4929f88fbd6",
      "headRepository": null,
      "headRefName": "eid5793",
      "headRefOid": "036968d6e15efafd7fc5438543fc233e0fa5c641",
      "closedAt": "2021-03-17T18:43:38Z",
      "mergedAt": "2021-03-17T18:43:38Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "7116ae31b2ba56b450973b7825336827dd44ea59"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 72,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk3Nzc5Njcz",
      "title": "Add user agent to Notational conventions. See #71.",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/72",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\n- \"user agent\" is the user agent, \"user-agent\" is an abnf syntax.\r\n- add reference to notational conventions.",
      "createdAt": "2021-03-22T08:09:59Z",
      "updatedAt": "2021-06-08T14:17:03Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "98489a0c5c03cb686b03030b20a07dae8eb47c31",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "ioggstream-71",
      "headRefOid": "d4a77387a83aefdbf1a25d4076e270ea5ace758c",
      "closedAt": "2021-04-23T22:12:33Z",
      "mergedAt": "2021-04-23T22:12:33Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "44a21f7aa0e896647183b56b04ae1969efd79048"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 73,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk3ODEwNDE5",
      "title": "Reword circular definition in Client Authentication. See #71",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/73",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nrewords a circular definition in \u00a72.3",
      "createdAt": "2021-03-22T08:53:49Z",
      "updatedAt": "2021-09-22T20:06:08Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "98489a0c5c03cb686b03030b20a07dae8eb47c31",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "ioggstream-71-ter",
      "headRefOid": "75a83c573e48351371b029af857b924be8bc3d78",
      "closedAt": "2021-09-21T19:07:32Z",
      "mergedAt": "2021-09-21T19:07:32Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "18948f541159b77edce2f179c75b4c41f5ff23f0"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 74,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk3ODEwNjcw",
      "title": "Consistency with other statement. See #71",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/74",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\nconsistently use \"confidential or credentialed\"",
      "createdAt": "2021-03-22T08:54:11Z",
      "updatedAt": "2021-06-08T14:15:39Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "98489a0c5c03cb686b03030b20a07dae8eb47c31",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "ioggstream-71-bis",
      "headRefOid": "27660f25299f64f9d1141eb50c3155973fae32c9",
      "closedAt": "2021-04-23T22:07:59Z",
      "mergedAt": "2021-04-23T22:07:59Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "32e1a4f58884c4c9cfa8119351b973fc8a7b1c6d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 75,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA4NDAzNDQ5",
      "title": "Fix typo in section 9.7",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/75",
      "state": "MERGED",
      "author": "mpeck12",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\"authorization request\" should be \"authorization response\"",
      "createdAt": "2021-04-03T15:39:41Z",
      "updatedAt": "2021-06-08T14:15:28Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "98489a0c5c03cb686b03030b20a07dae8eb47c31",
      "headRepository": "mpeck12/oauth-v2-1",
      "headRefName": "main",
      "headRefOid": "39e1c6d158889e6518c6dcc0f7218b730fefcd63",
      "closedAt": "2021-04-03T16:10:06Z",
      "mergedAt": "2021-04-03T16:10:06Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "f45f570a03f59467525be6dcac43a55acf2c9df5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0NjM4MDMyNzQ2",
      "title": "Refactoring (move refresh token into grant section)",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/78",
      "state": "MERGED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi,\r\n\r\nI made a first attempt to refactor the draft.\r\n\r\nPlease give me feedback on the direction.\r\n\r\nthanks,\r\nTorsten.",
      "createdAt": "2021-05-10T17:10:34Z",
      "updatedAt": "2021-06-08T14:14:47Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "fea22d1fd5acbeae8bf66dba5cdb7f3b6be9062c",
      "headRepository": "oauthstuff/OAuth-2.1",
      "headRefName": "refactoring",
      "headRefOid": "ba41b8a0549542a468b7539c7c1ed88e17fe9e9b",
      "closedAt": "2021-06-08T14:06:49Z",
      "mergedAt": "2021-06-08T14:06:49Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "38878a9573952c6868165533514dd251af374c0e"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thank you! Overall this is excellent. Just a few minor suggestions as noted inline!",
          "createdAt": "2021-05-17T23:25:41Z",
          "updatedAt": "2021-05-17T23:25:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYxNDg3NTk2",
          "commit": {
            "abbreviatedOid": "5e063ba"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2021-05-17T22:58:41Z",
          "updatedAt": "2021-05-17T23:25:10Z",
          "comments": [
            {
              "originalPosition": 295,
              "body": "I would just say \"are defined below\"",
              "createdAt": "2021-05-17T22:58:41Z",
              "updatedAt": "2021-05-17T23:25:10Z"
            },
            {
              "originalPosition": 291,
              "body": "I think this would look better being the first in the list. ",
              "createdAt": "2021-05-17T22:59:10Z",
              "updatedAt": "2021-05-17T23:25:10Z"
            },
            {
              "originalPosition": 320,
              "body": "\"are specified\" here too",
              "createdAt": "2021-05-17T23:01:46Z",
              "updatedAt": "2021-05-17T23:25:10Z"
            },
            {
              "originalPosition": 380,
              "body": "This sounds weird here now, how about \"...using the refresh token grant as described...\"",
              "createdAt": "2021-05-17T23:02:44Z",
              "updatedAt": "2021-05-17T23:25:10Z"
            },
            {
              "originalPosition": 383,
              "body": "These two paragraphs interrupt the list of parameters now. I suggest moving the \"scope\" section above these two paragraphs to keep the list of parameters together.",
              "createdAt": "2021-05-17T23:03:53Z",
              "updatedAt": "2021-05-17T23:25:10Z"
            },
            {
              "originalPosition": 520,
              "body": "This needs to be updated to include the refresh token grant type",
              "createdAt": "2021-05-17T23:05:30Z",
              "updatedAt": "2021-05-17T23:25:10Z"
            },
            {
              "originalPosition": 649,
              "body": "I'm not opposed to repeating all the parameters in this section, but currently it says only the additional parameters are defined but `client_id` is still in there.",
              "createdAt": "2021-05-17T23:13:16Z",
              "updatedAt": "2021-05-17T23:25:10Z"
            },
            {
              "originalPosition": 750,
              "body": "This feels abrupt jumping right into the extension section. This could use a sentence or two here re-introducing what the refresh token grant is.",
              "createdAt": "2021-05-17T23:22:01Z",
              "updatedAt": "2021-05-17T23:25:10Z"
            },
            {
              "originalPosition": 1025,
              "body": "I think we need that first sentence back, it should reference the token response section 4.3 as well.",
              "createdAt": "2021-05-17T23:23:25Z",
              "updatedAt": "2021-05-17T23:25:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3MzMwNTc4",
          "commit": {
            "abbreviatedOid": "5468d8f"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T12:09:33Z",
          "updatedAt": "2021-06-07T12:09:36Z",
          "comments": [
            {
              "originalPosition": 291,
              "body": "\"client_id\" and \"scope\" are the common denominator among all grant types whereas \"grant_type\" is the switch between the different grant types. That's why I put it here. ",
              "createdAt": "2021-06-07T12:09:34Z",
              "updatedAt": "2021-06-07T12:09:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3MzMwNjY0",
          "commit": {
            "abbreviatedOid": "5468d8f"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T12:09:39Z",
          "updatedAt": "2021-06-07T12:09:42Z",
          "comments": [
            {
              "originalPosition": 295,
              "body": "done",
              "createdAt": "2021-06-07T12:09:40Z",
              "updatedAt": "2021-06-07T12:09:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3MzMxMjI1",
          "commit": {
            "abbreviatedOid": "5468d8f"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T12:10:17Z",
          "updatedAt": "2021-06-07T12:10:20Z",
          "comments": [
            {
              "originalPosition": 320,
              "body": "done",
              "createdAt": "2021-06-07T12:10:18Z",
              "updatedAt": "2021-06-07T12:10:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3MzM3NzEy",
          "commit": {
            "abbreviatedOid": "5468d8f"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T12:17:28Z",
          "updatedAt": "2021-06-07T12:17:31Z",
          "comments": [
            {
              "originalPosition": 380,
              "body": "good catch! I changed the text to refer to the grant specified in the token request",
              "createdAt": "2021-06-07T12:17:29Z",
              "updatedAt": "2021-06-07T12:17:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3MzM4OTE1",
          "commit": {
            "abbreviatedOid": "5468d8f"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T12:18:50Z",
          "updatedAt": "2021-06-07T12:18:56Z",
          "comments": [
            {
              "originalPosition": 383,
              "body": "shuffled the paragraphs a bit. ok?",
              "createdAt": "2021-06-07T12:18:52Z",
              "updatedAt": "2021-06-07T12:18:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3MzQwMjc0",
          "commit": {
            "abbreviatedOid": "5468d8f"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T12:20:21Z",
          "updatedAt": "2021-06-07T12:20:26Z",
          "comments": [
            {
              "originalPosition": 520,
              "body": "fixed",
              "createdAt": "2021-06-07T12:20:22Z",
              "updatedAt": "2021-06-07T12:20:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3MzQxMzgz",
          "commit": {
            "abbreviatedOid": "5468d8f"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T12:21:34Z",
          "updatedAt": "2021-06-07T12:21:38Z",
          "comments": [
            {
              "originalPosition": 649,
              "body": "wasn't intentional - removed client_id",
              "createdAt": "2021-06-07T12:21:35Z",
              "updatedAt": "2021-06-07T12:21:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3MzQ1MjM4",
          "commit": {
            "abbreviatedOid": "5468d8f"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T12:25:44Z",
          "updatedAt": "2021-06-07T12:25:47Z",
          "comments": [
            {
              "originalPosition": 750,
              "body": "better?",
              "createdAt": "2021-06-07T12:25:45Z",
              "updatedAt": "2021-06-07T12:25:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc3MzU1MzU0",
          "commit": {
            "abbreviatedOid": "5468d8f"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-07T12:36:34Z",
          "updatedAt": "2021-06-07T12:36:36Z",
          "comments": [
            {
              "originalPosition": 1025,
              "body": "brought the sentence back and changed the reference. ok?",
              "createdAt": "2021-06-07T12:36:34Z",
              "updatedAt": "2021-06-07T12:36:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4NTY2NjYy",
          "commit": {
            "abbreviatedOid": "ba41b8a"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-06-08T14:06:06Z",
          "updatedAt": "2021-06-08T14:06:06Z",
          "comments": [
            {
              "originalPosition": 291,
              "body": "That's actually exactly why I would expect to see it first in the list, since it's the thing that changes the expected outcome of the request. In any case we can change that back later, I don't want this to hold up the PR.",
              "createdAt": "2021-06-08T14:06:06Z",
              "updatedAt": "2021-06-08T14:06:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Njc4NTY3NDE2",
          "commit": {
            "abbreviatedOid": "ba41b8a"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-06-08T14:06:38Z",
          "updatedAt": "2021-06-08T14:06:38Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDODkfq5s4sN4b5",
      "title": "Update organization",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/94",
      "state": "MERGED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-09-24T01:08:43Z",
      "updatedAt": "2021-09-28T18:22:14Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "73913c2e568b0687371c78eb6c5c6ac6ebd1c2e6",
      "headRepository": "dickhardt/oauth-v2-1",
      "headRefName": "main",
      "headRefOid": "ccae805dbef300442070fb60e8f01ba60914c951",
      "closedAt": "2021-09-28T18:22:14Z",
      "mergedAt": "2021-09-28T18:22:14Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "f661b2a598209da4faab32aff337939d7e23dda3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 96,
      "id": "PR_kwDODkfq5s4tCuaz",
      "title": "add section mentioning removal of implicit flow",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/96",
      "state": "MERGED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "closes #45",
      "createdAt": "2021-10-11T23:01:36Z",
      "updatedAt": "2021-10-18T20:54:03Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "015b70c7e8b54de67c2e990e27421f4249e78ad3",
      "headRepository": "oauth-wg/oauth-v2-1",
      "headRefName": "implicit-note",
      "headRefOid": "6fb10231c43ca2b923dcfbecd3696dc492a22232",
      "closedAt": "2021-10-13T17:08:03Z",
      "mergedAt": "2021-10-13T17:08:03Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "d272a8cdf1d0f060dbb8ea0f69e95badac18920b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 98,
      "id": "PR_kwDODkfq5s4tYGqo",
      "title": "Fix: #21. Reorganize TLS parts.",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/98",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\n- TLS is now always mandatory but for loopbacks\r\n- removed redundant parts\r\n\r\nRebases and reeplaces #30 @aaronpk ",
      "createdAt": "2021-10-19T10:35:14Z",
      "updatedAt": "2022-02-10T00:05:00Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "c9b0e5f2c1746cb042a82ed1a8efccbdbb1fbc23",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "ioggstream-21-ter",
      "headRefOid": "dd05151517c75a30ae2299c06826a1683d149710",
      "closedAt": "2022-02-10T00:05:00Z",
      "mergedAt": "2022-02-10T00:05:00Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "6bc8f40f56891c1a1c77ec3a73ef0118171e423c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s4uttck",
          "commit": {
            "abbreviatedOid": "8aea725"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-19T20:08:39Z",
          "updatedAt": "2021-10-19T20:09:32Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "This sentence seems unnecessary, isn't security the communication channel critical in all cases?",
              "createdAt": "2021-10-19T20:08:39Z",
              "updatedAt": "2021-10-19T20:09:32Z"
            },
            {
              "originalPosition": 30,
              "body": "Are there other mechanisms possible to use? If not I would suggest we rephrase this to only suggest TLS, otherwise it sounds like there are other options to consider.",
              "createdAt": "2021-10-19T20:09:12Z",
              "updatedAt": "2021-10-19T20:09:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4uvM_p",
          "commit": {
            "abbreviatedOid": "8aea725"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-20T08:00:15Z",
          "updatedAt": "2021-10-20T08:00:15Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I don't know. Probably it should be asked to the HTTP/3 | QUIC workgroup :) cc: @LPardue",
              "createdAt": "2021-10-20T08:00:15Z",
              "updatedAt": "2021-10-20T08:00:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4uvNUx",
          "commit": {
            "abbreviatedOid": "8aea725"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-20T08:01:32Z",
          "updatedAt": "2021-10-20T08:01:33Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\n```\r\n\r\n@aaronpk feel free to merge this patch.",
              "createdAt": "2021-10-20T08:01:32Z",
              "updatedAt": "2021-10-20T08:01:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDODkfq5s4tYN4s",
      "title": "Reorganize Security considerations. See #64",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/99",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "aaronpk"
      ],
      "labels": [],
      "body": "## This PR\r\n\r\n- reorganize Security considerations\r\n- remove redundancies\r\n- reference security considerations from other rfcs\r\n\r\nNeeds #98 ",
      "createdAt": "2021-10-19T11:14:31Z",
      "updatedAt": "2024-12-21T21:46:21Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "c9b0e5f2c1746cb042a82ed1a8efccbdbb1fbc23",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "ioggstream-64",
      "headRefOid": "b2c104c589e74254fc9f56e28a2bbd1a69e33687",
      "closedAt": "2024-12-19T16:21:15Z",
      "mergedAt": "2024-12-19T16:21:14Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "b2c104c589e74254fc9f56e28a2bbd1a69e33687"
      },
      "comments": [
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@aaronpk I'm trying to tackle #64  Let me know if you like the approach, pls.",
          "createdAt": "2021-10-19T11:15:45Z",
          "updatedAt": "2021-10-19T11:15:45Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "This is a great start. We'll come back to it after #98 is merged.",
          "createdAt": "2021-10-19T20:14:29Z",
          "updatedAt": "2021-10-19T20:14:29Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s4uraLL",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-19T11:17:06Z",
          "updatedAt": "2021-10-19T11:17:07Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "@aaronpk TLS / channel-encryption is already a MUST. This is probably redundant.",
              "createdAt": "2021-10-19T11:17:07Z",
              "updatedAt": "2021-10-19T11:17:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4uraUP",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-19T11:17:45Z",
          "updatedAt": "2021-10-19T11:17:45Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "I think the problem is quite clear. I won't restate it from scratch. Instead I created a separate section wrt Intermediaries above.",
              "createdAt": "2021-10-19T11:17:45Z",
              "updatedAt": "2021-10-19T11:17:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4uracE",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-19T11:18:15Z",
          "updatedAt": "2021-10-19T11:18:15Z",
          "comments": [
            {
              "originalPosition": 71,
              "body": "All considerations on cookies could be collected and placed in a subsection.",
              "createdAt": "2021-10-19T11:18:15Z",
              "updatedAt": "2021-10-19T11:18:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4urbQw",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-19T11:21:52Z",
          "updatedAt": "2021-10-19T11:21:52Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Reworked as a list. Still I won't re-state all possible problems that TLS solves (eavesdropping, impersonation, integrity, ..) :)",
              "createdAt": "2021-10-19T11:21:52Z",
              "updatedAt": "2021-10-19T11:21:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4utub-",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-19T20:13:15Z",
          "updatedAt": "2021-10-19T20:13:15Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "I feel like it's not the worst idea to leave this in, since I've seen plenty of \"answers\" on stackoverflow that tell people to disable the certificate check in curl to make something work.",
              "createdAt": "2021-10-19T20:13:15Z",
              "updatedAt": "2021-10-19T20:13:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4uvMmX",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-20T07:58:45Z",
          "updatedAt": "2021-10-20T07:58:45Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Let's emphasize it in the appropriate sections, so that we can better evolve them in isolation.\r\n\r\nIt would be interesting instead to identify a section for things like \"MUST content encryption\".\r\n\r\nI'll wait for #99  and come back later on that  though :) Thanks for your support! R.",
              "createdAt": "2021-10-20T07:58:45Z",
              "updatedAt": "2021-10-20T07:58:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-XLBg",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T09:56:02Z",
          "updatedAt": "2022-07-21T09:56:02Z",
          "comments": [
            {
              "originalPosition": 337,
              "body": "done",
              "createdAt": "2022-07-21T09:56:02Z",
              "updatedAt": "2022-07-21T09:56:02Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-XLJM",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T09:56:24Z",
          "updatedAt": "2022-07-21T09:56:24Z",
          "comments": [
            {
              "originalPosition": 322,
              "body": "done",
              "createdAt": "2022-07-21T09:56:24Z",
              "updatedAt": "2022-07-21T09:56:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6BXb59",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "randomstuff",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-07-10T21:36:24Z",
          "updatedAt": "2024-07-10T21:36:25Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "To this end, one thing which is currently lacking is a standard/recommended way for the AS to communicate _to the client_ the intended audience(s) (URLs) of the issued access token.",
              "createdAt": "2024-07-10T21:36:24Z",
              "updatedAt": "2024-07-10T21:36:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6V5HF3",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-12-19T13:50:39Z",
          "updatedAt": "2024-12-19T13:57:59Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "TLS is used as means to prevent leakage (and replay) but not against tampering or forgery. ",
              "createdAt": "2024-12-19T13:50:39Z",
              "updatedAt": "2024-12-19T13:57:59Z"
            },
            {
              "originalPosition": 43,
              "body": "Should the text mention that this holds true for all parties involved, including the client?",
              "createdAt": "2024-12-19T13:51:22Z",
              "updatedAt": "2024-12-19T13:57:59Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\nHTTPS request (with extra line breaks for display purposes\r\n```",
              "createdAt": "2024-12-19T13:51:42Z",
              "updatedAt": "2024-12-19T13:57:59Z"
            },
            {
              "originalPosition": 140,
              "body": "```suggestion\r\nFor example, the client makes the following HTTPS request\r\n```",
              "createdAt": "2024-12-19T13:51:53Z",
              "updatedAt": "2024-12-19T13:57:59Z"
            },
            {
              "originalPosition": 150,
              "body": "```suggestion\r\nthe client makes the following HTTPS request\r\n```",
              "createdAt": "2024-12-19T13:52:01Z",
              "updatedAt": "2024-12-19T13:57:59Z"
            },
            {
              "originalPosition": 187,
              "body": "is it visibility only? I would assume forgery is a risk, too, that's why implementers must sign tokens or use high entropy handles",
              "createdAt": "2024-12-19T13:53:38Z",
              "updatedAt": "2024-12-19T13:57:59Z"
            },
            {
              "originalPosition": 117,
              "body": "@randomstuff that is what resource indicators and RAR do. \r\nAudience restriction is always a good idea but it will only limit the impact of replay, it does not prevent it. Most application with on substantial security requirements will use sender constrained access tokens. ",
              "createdAt": "2024-12-19T13:55:11Z",
              "updatedAt": "2024-12-19T13:57:59Z"
            },
            {
              "originalPosition": 272,
              "body": "This contains a pretty complete list of countermeasures: https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#name-token-replay-prevention",
              "createdAt": "2024-12-19T13:57:49Z",
              "updatedAt": "2024-12-19T13:57:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6V62Mn",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-19T15:27:55Z",
          "updatedAt": "2024-12-19T15:27:55Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "```suggestion\r\nfrom eavesdropping which enables replay\r\n```",
              "createdAt": "2024-12-19T15:27:55Z",
              "updatedAt": "2024-12-19T15:27:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6V64CV",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-19T15:29:44Z",
          "updatedAt": "2024-12-19T15:29:44Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "```suggestion\r\nAll the OAuth protocol URLs (URLs exposed by the AS, RS and Client) MUST use the `https` scheme\r\n```",
              "createdAt": "2024-12-19T15:29:44Z",
              "updatedAt": "2024-12-19T15:29:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6V65TN",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-19T15:30:55Z",
          "updatedAt": "2024-12-19T15:30:56Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "```suggestion\r\nFor example, the client makes the following HTTPS request\r\n```",
              "createdAt": "2024-12-19T15:30:56Z",
              "updatedAt": "2024-12-19T15:30:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6V7KSW",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-19T15:46:39Z",
          "updatedAt": "2024-12-19T15:46:40Z",
          "comments": [
            {
              "originalPosition": 187,
              "body": "```suggestion\r\nthose actors have visibility of access tokens and could modify the tokens or requests.\r\n```",
              "createdAt": "2024-12-19T15:46:39Z",
              "updatedAt": "2024-12-19T15:46:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6WHMRN",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-20T22:43:28Z",
          "updatedAt": "2024-12-20T22:43:29Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "@tlodderstedt sorry for the late reply. I just inherited from RFC8446. Is there a reason for removing tampering/forgery?\r\n\r\n   This document specifies version 1.3 of the Transport Layer Security\r\n   (TLS) protocol.  TLS allows client/server applications to communicate\r\n   over the Internet in a way that is designed to prevent eavesdropping,\r\n   tampering, and message forgery.\r\n",
              "createdAt": "2024-12-20T22:43:28Z",
              "updatedAt": "2024-12-20T22:43:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6WJ2yW",
          "commit": {
            "abbreviatedOid": "9e6bd98"
          },
          "author": "randomstuff",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-21T21:46:21Z",
          "updatedAt": "2024-12-21T21:46:21Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "@tlodderstedt, in the current resource indicators RFC, the client can tell the AS the intended audience (RS) but there is currently no standard way for the *AS* to communicate the audience of the token to the *client* (for example as a confirmation that the audience restriction has been applied by the AS).",
              "createdAt": "2024-12-21T21:46:21Z",
              "updatedAt": "2024-12-21T21:46:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 104,
      "id": "PR_kwDODkfq5s4zXZVs",
      "title": "Mnr changes for the abstract",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/104",
      "state": "MERGED",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Suggested changes for https://github.com/aaronpk/oauth-v2-1/issues/103.",
      "createdAt": "2022-02-23T19:52:33Z",
      "updatedAt": "2022-02-23T19:58:51Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "a4084a83c77b215cabe6b601f5d1db786fbeb787",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "c9be7eb913aa418325f2735d0d74f75553a3dba8",
      "closedAt": "2022-02-23T19:55:04Z",
      "mergedAt": "2022-02-23T19:55:04Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "3f775c2a6f5ecdfaebeea69cf0d6385415d174d5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 110,
      "id": "PR_kwDODkfq5s43cBMm",
      "title": "Fix minor incorrect references",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/110",
      "state": "MERGED",
      "author": "falko17",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "An invalid link to the OpenID core spec has been fixed, as well as a section number referencing the `ietf-oauth-security-topics` draft.",
      "createdAt": "2022-05-06T21:18:45Z",
      "updatedAt": "2022-06-10T17:59:33Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "f4ab62a7e16adf6402f37f0152103f19f9f239be",
      "headRepository": "falko17/oauth-v2-1",
      "headRefName": "main",
      "headRefOid": "4ac0a089dadcd5e07cb7fe3e7e9cf186a4027e1f",
      "closedAt": "2022-06-10T17:59:32Z",
      "mergedAt": "2022-06-10T17:59:32Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "0b8cdf9c9d02259bd06f79ef4366ec5d7d8bed9f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 111,
      "id": "PR_kwDODkfq5s43v2V6",
      "title": "Fix some typos",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/111",
      "state": "MERGED",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2022-05-12T21:35:48Z",
      "updatedAt": "2022-05-13T13:20:09Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "f4ab62a7e16adf6402f37f0152103f19f9f239be",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "435457e5181cc90d0d910c6e6f617df5330238e0",
      "closedAt": "2022-05-13T08:07:25Z",
      "mergedAt": "2022-05-13T08:07:25Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "0b86a72cae12d4ee242aac074e7c9427320132cd"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 113,
      "id": "PR_kwDODkfq5s45cVH_",
      "title": "Fix: #112. Reference latest HTTP spec RFC9110.",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/113",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\n- Fixes #112 \r\n- References the latest HTTP specifications RFC9110 which integrates parts from different RFCs in a coherent document, including RFC7230, RFC7231 and RFC2818. \r\n- Removes unused specifications\r\n- Run `make fix-lint` to clean up EOLs\r\n\r\n## Note\r\n\r\nConsider using the standard RFC building docker image used by the httpwg and the httpapiwg since it's continuously maintained and updated ;)",
      "createdAt": "2022-06-10T06:15:30Z",
      "updatedAt": "2022-07-02T21:09:28Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "0b86a72cae12d4ee242aac074e7c9427320132cd",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "ioggstream-112",
      "headRefOid": "10eb2cf8024c0cb4a898bfd9a44c409adc625ac2",
      "closedAt": "2022-06-10T17:59:09Z",
      "mergedAt": "2022-06-10T17:59:09Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "506cb471f884d5d56c66ce0a6d1fe4b29ec21d25"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "> Consider using the standard RFC building docker image used by the httpwg and the httpapiwg since it's continuously maintained and updated ;)\r\n\r\nI'm not finding any mention of docker in the httpwg repos or documentation. Do you know where that is documented?",
          "createdAt": "2022-07-01T23:50:54Z",
          "updatedAt": "2022-07-01T23:50:54Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @aaronpk ! You can see the .github actions in the [httpwg](https://github.com/httpwg/http-extensions/blob/main/.github/workflows/ghpages.yml#L41) and [httpapi](https://github.com/ietf-wg-httpapi/mediatypes/tree/main/.github/workflows) repos.\r\n\r\nThe documentation for the image is here https://github.com/martinthomson/i-d-template\r\n\r\nLet me know if you need further support :)\r\n\r\nHTH,\r\nR",
          "createdAt": "2022-07-02T21:09:28Z",
          "updatedAt": "2022-07-02T21:09:28Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 118,
      "id": "PR_kwDODkfq5s45c_et",
      "title": "Clarify redirection proposal. See #117.",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/118",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This draft PR\r\n\r\n- clarifies redirection and request/response terminology",
      "createdAt": "2022-06-10T09:18:57Z",
      "updatedAt": "2024-12-19T13:47:33Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "aeb4be4b8eac83cf873d06a53e081bdd292ff7d7",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "ioggstream-117",
      "headRefOid": "03d5c0934d87fd29c3b37d15f8294c45781de306",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s47wN6l",
          "commit": {
            "abbreviatedOid": "5ec78e5"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-10T09:21:08Z",
          "updatedAt": "2022-06-10T09:21:08Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "location is an URL, right?",
              "createdAt": "2022-06-10T09:21:08Z",
              "updatedAt": "2022-06-10T09:21:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s47wOAR",
          "commit": {
            "abbreviatedOid": "5ec78e5"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-10T09:21:25Z",
          "updatedAt": "2022-06-10T09:21:26Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "if it's a location, it's an URL, right?",
              "createdAt": "2022-06-10T09:21:26Z",
              "updatedAt": "2022-06-10T09:21:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s47wOJ4",
          "commit": {
            "abbreviatedOid": "5ec78e5"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-10T09:21:57Z",
          "updatedAt": "2022-06-10T09:21:57Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "this section applies to the authorization endpoints, not to all the authorization server, right?",
              "createdAt": "2022-06-10T09:21:57Z",
              "updatedAt": "2022-06-10T09:21:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s47yrRX",
          "commit": {
            "abbreviatedOid": "5ec78e5"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-10T17:49:33Z",
          "updatedAt": "2022-06-10T17:49:33Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "I think this is in there to make sure clients don't make assumptions that the authorization server URL might not contain a query string. Also note that just below this there's a limit that the URL can't contain a fragment, so I think it's worth pointing out still.",
              "createdAt": "2022-06-10T17:49:33Z",
              "updatedAt": "2022-06-10T17:49:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s47yrWf",
          "commit": {
            "abbreviatedOid": "5ec78e5"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-10T17:49:53Z",
          "updatedAt": "2022-06-10T17:49:54Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Yes I believe this would always be a URL",
              "createdAt": "2022-06-10T17:49:54Z",
              "updatedAt": "2022-06-10T17:49:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s47ysrL",
          "commit": {
            "abbreviatedOid": "5ec78e5"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-10T17:55:31Z",
          "updatedAt": "2022-06-10T17:55:31Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I suppose it wouldn't refer to the token endpoint, only to endpoints that a user might interact with.",
              "createdAt": "2022-06-10T17:55:31Z",
              "updatedAt": "2022-06-10T17:55:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s47ys4Y",
          "commit": {
            "abbreviatedOid": "5ec78e5"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-10T17:56:26Z",
          "updatedAt": "2022-06-10T17:56:27Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "I don't think adding \"untrusted parties\" here is beneficial",
              "createdAt": "2022-06-10T17:56:26Z",
              "updatedAt": "2022-06-10T17:56:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s471_HJ",
          "commit": {
            "abbreviatedOid": "5ec78e5"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-13T09:00:57Z",
          "updatedAt": "2022-06-13T09:00:58Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "> this is in there to make sure clients don't make assumptions that the authorization server URL might not contain a query string\r\n\r\nI don't understand how this is related to the query string. IIUC, both URI and URL can have a query component:\r\n\r\n- URI [query](https://datatracker.ietf.org/doc/html/rfc3986#section-3.4) \r\n- URL [query](https://url.spec.whatwg.org/#concept-url-query)\r\n",
              "createdAt": "2022-06-13T09:00:57Z",
              "updatedAt": "2022-06-13T09:00:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s471_bB",
          "commit": {
            "abbreviatedOid": "5ec78e5"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-13T09:01:53Z",
          "updatedAt": "2022-06-13T09:01:54Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "```suggestion\r\nAn authorization endpoint that redirects a request potentially containing\r\n```",
              "createdAt": "2022-06-13T09:01:53Z",
              "updatedAt": "2022-06-13T09:01:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s471_uD",
          "commit": {
            "abbreviatedOid": "9364769"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-06-13T09:02:50Z",
          "updatedAt": "2022-06-13T09:02:50Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Can we say that \"it MUST NOT forward these credentials\" never, in any case?",
              "createdAt": "2022-06-13T09:02:50Z",
              "updatedAt": "2022-06-13T09:02:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-VZc3",
          "commit": {
            "abbreviatedOid": "5ec78e5"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T00:07:34Z",
          "updatedAt": "2022-07-21T00:07:35Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Yes, but without an explicit mention, I suspect a lot of people would assume the URL would not contain a query string, especially because it's pretty uncommon for it to do so in practice.",
              "createdAt": "2022-07-21T00:07:35Z",
              "updatedAt": "2022-07-21T00:07:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-VZoa",
          "commit": {
            "abbreviatedOid": "5ec78e5"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T00:09:10Z",
          "updatedAt": "2022-07-21T00:09:10Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "That gets a bit tricky, because it might need to \"forward\" the credentials to itself, and then what are the boundaries of its \"self\" becomes challenging to describe concisely. I think that's the reason the original text said \"accidentally\".",
              "createdAt": "2022-07-21T00:09:10Z",
              "updatedAt": "2022-07-21T00:09:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-W9j1",
          "commit": {
            "abbreviatedOid": "9364769"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T09:14:58Z",
          "updatedAt": "2022-07-21T09:14:58Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "> without an explicit mention\r\n\r\nwe explicitly mention the query component in the lines below - that are not removed - so people are told that URLs have query component.\r\n\r\n@aaronpk ",
              "createdAt": "2022-07-21T09:14:58Z",
              "updatedAt": "2022-07-21T09:14:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-W-DI",
          "commit": {
            "abbreviatedOid": "9364769"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T09:16:29Z",
          "updatedAt": "2022-07-21T09:16:30Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "So is it correct in line 992 to use \"authorization endpoint\" ?",
              "createdAt": "2022-07-21T09:16:29Z",
              "updatedAt": "2022-07-21T09:16:30Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-XCbk",
          "commit": {
            "abbreviatedOid": "9364769"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T09:29:22Z",
          "updatedAt": "2022-07-21T09:29:22Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "@aaronpk \"MUST avoid to accidentally\" sounds like [SHOULD CONSIDER](https://datatracker.ietf.org/doc/html/rfc6919#section-2). IMHO does not  provide any interoperability guidance because it is related to an unintended behavior. \r\n\r\nIn general, I'd track down RFC6919-sounding statements in this document and address them before AD / IESG review will ask us to do it.\r\n\r\n> I don't think adding \"untrusted parties\" here is beneficial\r\n\r\nimho  helps avoiding the fallacies of \"accidentally\", since it suggests the AS to internally define a trusted boundary for credentials.\r\n",
              "createdAt": "2022-07-21T09:29:22Z",
              "updatedAt": "2022-07-21T09:29:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-XJHt",
          "commit": {
            "abbreviatedOid": "03d5c09"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-21T09:50:07Z",
          "updatedAt": "2022-07-21T09:50:07Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "@aaronpk I reworded it removing normative language. This is because we cannot forbid to accidentally do something ;) instead it is better to suggest how to mitigate the risk.",
              "createdAt": "2022-07-21T09:50:07Z",
              "updatedAt": "2022-07-21T09:50:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6V5Bjq",
          "commit": {
            "abbreviatedOid": "03d5c09"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-19T13:45:10Z",
          "updatedAt": "2024-12-19T13:47:33Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "What is the rationale for this suggested change?",
              "createdAt": "2024-12-19T13:45:10Z",
              "updatedAt": "2024-12-19T13:47:33Z"
            },
            {
              "originalPosition": 26,
              "body": "how is this proposed change related to redirects?",
              "createdAt": "2024-12-19T13:46:13Z",
              "updatedAt": "2024-12-19T13:47:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 123,
      "id": "PR_kwDODkfq5s46zk6P",
      "title": "Remove credentialed client",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/123",
      "state": "MERGED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "ietf-114"
      ],
      "body": "",
      "createdAt": "2022-07-04T15:28:14Z",
      "updatedAt": "2022-07-15T23:26:54Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "e93e02d2355df634908c88b00a8ba9b6f8df968d",
      "headRepository": "oauth-wg/oauth-v2-1",
      "headRefName": "Remove-credentialed-client",
      "headRefOid": "1561980a39edc60c913a2b088011d8faad037d16",
      "closedAt": "2022-07-15T23:25:58Z",
      "mergedAt": "2022-07-15T23:25:58Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "9da6214fc3ad20909182549ab6a25fb296554ca9"
      },
      "comments": [
        {
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "body": "OAuth 2 gives a clear definition of public clients, which is\r\n\r\n> Clients incapable of maintaining the confidentiality of their\r\n>       credentials (e.g., clients executing on the device used by the\r\n>       resource owner, such as an installed native application or a web\r\n>       browser-based application), and incapable of secure client\r\n>       authentication via any other means.\r\n\r\nwhere OAuth 2.1 says\r\n\r\n> Clients without credentials are called \"public clients\"\r\n\r\nisn't `client_id` one of the forms / attributes that could be referred to as credentials? Public clients do have them, they didn't go away, right? ... while they don't have client_secret of course.",
          "createdAt": "2022-07-11T23:39:59Z",
          "updatedAt": "2022-07-11T23:39:59Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "A `client_id` is not a credential, it is an identifier, and it is always public.",
          "createdAt": "2022-07-15T22:23:48Z",
          "updatedAt": "2022-07-15T22:23:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s49QXIZ",
          "commit": {
            "abbreviatedOid": "5794579"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-04T15:30:11Z",
          "updatedAt": "2022-07-04T15:30:12Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "@aaronpk @dick\r\n\r\nDo we really think those profiles map to client types? One can certainly build a SPA as confidential client with the BFF pattern. ",
              "createdAt": "2022-07-04T15:30:11Z",
              "updatedAt": "2022-07-04T15:30:12Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49hqI8",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-07T22:46:38Z",
          "updatedAt": "2022-07-07T22:46:38Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Is the backend for frontend pattern applicable for native apps?",
              "createdAt": "2022-07-07T22:46:38Z",
              "updatedAt": "2022-07-07T22:46:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49hrAm",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-07T22:53:17Z",
          "updatedAt": "2022-07-07T22:53:18Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "@tlodderstedt, I'm wondering if there are any concerns with `client_secret_jwt` as a client auth type.",
              "createdAt": "2022-07-07T22:53:17Z",
              "updatedAt": "2022-07-07T22:53:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49hrpT",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-07T22:58:16Z",
          "updatedAt": "2022-07-07T22:58:16Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I'm wondering if it's OK to have/allow public clients with credentials (client_secret) but use them in only certain scenarios, say to revoke and introspect ATs.",
              "createdAt": "2022-07-07T22:58:16Z",
              "updatedAt": "2022-07-07T22:58:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49lE6q",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-08T16:17:33Z",
          "updatedAt": "2022-07-08T16:17:35Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "excellent question! I had hoped the text includes that option. It says \"it is recommended to utilize the backend for frontend pattern\"",
              "createdAt": "2022-07-08T16:17:34Z",
              "updatedAt": "2022-07-08T16:17:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49lGf8",
          "commit": {
            "abbreviatedOid": "c56d23b"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-08T16:23:39Z",
          "updatedAt": "2022-07-08T16:23:42Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "It requires both client and AS to know the secret. ",
              "createdAt": "2022-07-08T16:23:40Z",
              "updatedAt": "2022-07-08T16:23:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49lGqt",
          "commit": {
            "abbreviatedOid": "c56d23b"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-08T16:24:20Z",
          "updatedAt": "2022-07-08T16:24:23Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "you mean use the secret only in certain scenarios? what would be the reason to do so?",
              "createdAt": "2022-07-08T16:24:21Z",
              "updatedAt": "2022-07-08T16:24:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49ljBS",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-08T18:24:14Z",
          "updatedAt": "2022-07-08T18:24:14Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Sure, I have a native OAuth client with a security requirement to invalidate ATs when users want to sign out and/or they just close the application. What do I do? I present ATs to the token revocation endpoint which is protected... it isn't desirable just to let anyone else revoke ATs.\r\n\r\nLet's take a look at the introspection endpoint too, my native OAuth client needs to get an information associated with an AT such as userId... so, the client needs to be somehow authenticated because again, it's undesirable to let anyone else obtain this kind of information. An alternative approach would be to issue idToken or self-contained ATs and extract everything I need from them. https://datatracker.ietf.org/doc/html/rfc8252 doesn't require to use of the \"openid\" scope and we don't always deal with self-contained ATs so these approaches won't work all the time.\r\n\r\nIn a more general sense, a public client may want to use the \"client_credentials\" grant type which is allowed on OAuth 2.1. So, the client needs to be authenticated for the token endpoint, right? The client might want to get ATs that then could be used for interactions with the abovementioned introspect and revocation endpoints, or with any other resources which could be useful for it.\r\n\r\nRight now, the specification defines public clients as \"clients without credentials\" although, as I tried to show, sometimes it's useful or even required to have and support one or another form of client authentification.",
              "createdAt": "2022-07-08T18:24:14Z",
              "updatedAt": "2022-07-08T18:24:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49l2GS",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-08T19:56:38Z",
          "updatedAt": "2022-07-08T19:56:38Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "At some degree `client_secret_basic` are `client_secret_post` are better then `client_secret_jwt` in this regard as the AS may store only client_secrets' hashes. This is the idea, right?\r\n\r\nMaybe it makes sense to mention/specify `private_key_jwt` as the client authentification form behind\r\n\r\n> a private key used to sign a JWT.",
              "createdAt": "2022-07-08T19:56:38Z",
              "updatedAt": "2022-07-08T19:56:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49nLhn",
          "commit": {
            "abbreviatedOid": "5794579"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-10T21:47:22Z",
          "updatedAt": "2022-07-10T21:47:22Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "My intent with that example was to talk about the case where the SPA has no backend.\r\n\r\nHow about: \"An application deployed as a single-page app on a static web host without a backend would be considered a public client.\"\r\n\r\nedit: on second thought, I think you're right removing this whole chunk entirely. The three profiles below are sufficient.",
              "createdAt": "2022-07-10T21:47:22Z",
              "updatedAt": "2022-07-10T22:02:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49nLmy",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-10T21:51:38Z",
          "updatedAt": "2022-07-10T21:51:38Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Clients shouldn't be using the token introspection endpoint, that endpoint is for RSs to introspect tokens, so it makes sense for that endpoint to require authentication.\r\n\r\nAs for the revocation endpoint, I feel like this question comes up quite often, the argument being requiring separate authentication reduces the chance of token scanning attacks, but the counterargument being if token scanning attacks are a concern then you have some other design issue with your system and also every RS would be a target for the same scanning attacks, so there really isn't anything new gained by adding separate authentication.\r\n\r\n> it isn't desirable just to let anyone else revoke ATs.\r\n\r\nOnly the bearer of an AT can revoke an AT. That's what makes it a bearer token.\r\n\r\n> my native OAuth client needs to get an information associated with an AT such as userId\r\n\r\nNo, only the RS should be introspecting the access token. The client should get this information from the OpenID Connect ID token.\r\n\r\n> In a more general sense, a public client may want to use the \"client_credentials\" grant type\r\n\r\nNo, public clients can't use the client credentials grant type because they aren't issued client credentials.",
              "createdAt": "2022-07-10T21:51:38Z",
              "updatedAt": "2022-07-10T21:51:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49nLrM",
          "commit": {
            "abbreviatedOid": "c56d23b"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-10T21:55:31Z",
          "updatedAt": "2022-07-10T21:55:32Z",
          "comments": [
            {
              "originalPosition": 114,
              "body": "```suggestion\r\nissue the client identifier, it may also serve clients whose client identifier\r\n```",
              "createdAt": "2022-07-10T21:55:31Z",
              "updatedAt": "2022-07-10T21:55:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49nLxw",
          "commit": {
            "abbreviatedOid": "c56d23b"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-10T22:00:57Z",
          "updatedAt": "2022-07-10T22:00:58Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Probably is worth mentioning RFC7523 for this example. I added a suggestion below.",
              "createdAt": "2022-07-10T22:00:57Z",
              "updatedAt": "2022-07-10T22:05:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49nL2Y",
          "commit": {
            "abbreviatedOid": "4b84c02"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-10T22:04:40Z",
          "updatedAt": "2022-07-10T22:04:40Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n(e.g. a private key used to sign a JWT, as described in {{RFC7523}})\r\n```",
              "createdAt": "2022-07-10T22:04:40Z",
              "updatedAt": "2022-07-10T22:04:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49nL2z",
          "commit": {
            "abbreviatedOid": "4b84c02"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "This is much cleaner now!",
          "createdAt": "2022-07-10T22:05:00Z",
          "updatedAt": "2022-07-10T22:05:00Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODkfq5s49sZ8r",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T23:26:50Z",
          "updatedAt": "2022-07-11T23:26:51Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Thank you for the response.\r\n\r\n[RFC 7662](https://datatracker.ietf.org/doc/html/rfc7662) provides a generic mechanism to validate tokens, including RTs as well. There is a dedicated value for them in the token_type_hint parameter for them. I know that it's a quite popular opinion that the introspection endpoint is for RSs only.\r\n\r\nIt feels like there is no other way than to issue the Open ID Connect ID token as of now... and what's strange is that I have never seen any discussion around that before... taking into account the popularity of [OAuth 2.0 for Native Apps (RFC 8252)](https://datatracker.ietf.org/doc/html/rfc8252).",
              "createdAt": "2022-07-11T23:26:50Z",
              "updatedAt": "2022-07-11T23:26:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s49sbrd",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-11T23:41:50Z",
          "updatedAt": "2022-07-11T23:41:50Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "The same applies to the token revocation process in native apps as well.",
              "createdAt": "2022-07-11T23:41:50Z",
              "updatedAt": "2022-07-11T23:41:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-CjQw",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-15T22:22:50Z",
          "updatedAt": "2022-07-15T22:22:50Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "The first sentence of RFC 7662 is:\r\n\r\n> This specification defines a method for a **protected resource** to query\r\n> an OAuth 2.0 authorization server to determine the active state of an\r\n> OAuth 2.0 token and to determine meta-information about this token.\r\n\r\n(emphasis mine)\r\n\r\nThis means it is for resource servers to introspect tokens, not for clients or other parties.\r\n\r\nThere isn't much discussion of clients obtaining user info in OAuth because the scope of OAuth is authorizing access to APIs. OpenID Connect fills in the parts needed for clients getting user information, so that's where you'll find those things discussed.",
              "createdAt": "2022-07-15T22:22:50Z",
              "updatedAt": "2022-07-15T22:22:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-CkVb",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-15T22:32:45Z",
          "updatedAt": "2022-07-15T22:32:45Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "RFC 7662 gives the following description of the token parameter in the introspection request\r\n\r\n```\r\nThe string value of the token.  For access tokens, this\r\n      is the \"access_token\" value returned from the token endpoint\r\n      defined in OAuth 2.0 [RFC6749], Section 5.1.  For refresh tokens,\r\n      this is the \"refresh_token\" value returned from the token endpoint\r\n      as defined in OAuth 2.0 [RFC6749], Section 5.1.\r\n```\r\n\r\nwhat is the point to deny it? Do you often see RTs at the RS?",
              "createdAt": "2022-07-15T22:32:45Z",
              "updatedAt": "2022-07-15T22:32:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-Cndc",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-15T22:56:53Z",
          "updatedAt": "2022-07-15T22:56:53Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "@tlodderstedt, I'm confused a bit... How do you suggest using the BFF approach for native apps?",
              "createdAt": "2022-07-15T22:56:53Z",
              "updatedAt": "2022-07-15T22:56:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-Cn7U",
          "commit": {
            "abbreviatedOid": "4b84c02"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-15T22:59:52Z",
          "updatedAt": "2022-07-15T22:59:52Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I suggest also changing a reference from OpenID to RFC7523 in the following sentences\r\n\r\n> Some additional authentication methods such as mTLS {{RFC8705}} and \"private_key_jwt\" {{OpenID}}\r\n\r\n\r\nand\r\n\r\n`It is RECOMMENDED to use asymmetric (public-key based) methods for client authentication such as mTLS {{RFC8705}} or \"private_key_jwt\" {{OpenID}}.`\r\n",
              "createdAt": "2022-07-15T22:59:52Z",
              "updatedAt": "2022-07-15T22:59:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-CqNr",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-15T23:24:11Z",
          "updatedAt": "2022-07-15T23:24:11Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Agreed, I'll add these changes in a separate commit.",
              "createdAt": "2022-07-15T23:24:11Z",
              "updatedAt": "2022-07-15T23:24:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-CqVS",
          "commit": {
            "abbreviatedOid": "b276d9c"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-07-15T23:25:29Z",
          "updatedAt": "2022-07-15T23:25:29Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "That's a good point, the RS shouldn't be seeing refresh tokens, so I'm not sure why that's there. But in any case that is an issue with 7662 not related to 2.1 since we're not bringing that in. Can you bring this up on the mailing list?",
              "createdAt": "2022-07-15T23:25:29Z",
              "updatedAt": "2022-07-15T23:25:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s4-CqXM",
          "commit": {
            "abbreviatedOid": "1561980"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-07-15T23:25:52Z",
          "updatedAt": "2022-07-15T23:25:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 127,
      "id": "PR_kwDODkfq5s472Fu6",
      "title": "Token encryption cannot replace TLS. See #64",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/127",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## This PR\r\n\r\n- token encryption can't replace TLS unless similar requirements are implemented (integrity, privacy, authenticity) ;\r\n- suggest using TLS along the way, even when using TLS terminators;\r\n- MUST does not define here a specific requirement \r\n\r\n## Note\r\n\r\nSome mitigation measure express strict requirements (e.g. MUST NIT store in insecure cookies). IMHO that's ok, but in this case it's more than mitigation, since an implementation that does not respect these is non conformant.",
      "createdAt": "2022-07-21T11:02:41Z",
      "updatedAt": "2024-12-19T13:41:29Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "aeb4be4b8eac83cf873d06a53e081bdd292ff7d7",
      "headRepository": "ioggstream/oauth-v2-1",
      "headRefName": "ioggstream-64-quater",
      "headRefOid": "9e62313f0cc55ad23e1812c3aa299109cc30f636",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s6V49y7",
          "commit": {
            "abbreviatedOid": "9e62313"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-12-19T13:41:25Z",
          "updatedAt": "2024-12-19T13:41:29Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I agree that token encryption is not a replacement for TLS. Encryption should be used to prevent any party along the way from AS to RS to inspect the data in the token, including the client. \r\nSimilar, signatures protect the integrity and authenticity of self-contained tokens along the way, especially at the client. \r\nLack of TLS protection from datacenter edge to RS could cause only problems with sender constrained access tokens bound to a TLS certificate. I think the suitable solution would be to use DPoP instead of Client TLS authentication in such cases. ",
              "createdAt": "2024-12-19T13:41:25Z",
              "updatedAt": "2024-12-19T13:41:29Z"
            }
          ]
        }
      ]
    },
    {
      "number": 130,
      "id": "PR_kwDODkfq5s4_KGh0",
      "title": "Use numbers in the figure instead of characters",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/130",
      "state": "MERGED",
      "author": "BobHamburg",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Use numbers in the figure as they were also used in the following steps.",
      "createdAt": "2022-09-18T19:21:37Z",
      "updatedAt": "2022-09-18T19:51:53Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "4bea3440b9d98b42b23bff573049a1367445c56a",
      "headRepository": "BobHamburg/oauth-v2-1",
      "headRefName": "patch-1",
      "headRefOid": "5c5b8f64196be0d0816ff5ed82cbb432e24697f4",
      "closedAt": "2022-09-18T19:51:52Z",
      "mergedAt": "2022-09-18T19:51:52Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "ad0f3e0c531b0498b66101ab0ce028da4933b651"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thank you, I missed this one in the last update",
          "createdAt": "2022-09-18T19:34:48Z",
          "updatedAt": "2022-09-18T19:34:48Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s5CQWPs",
          "commit": {
            "abbreviatedOid": "5c5b8f6"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-18T19:51:46Z",
          "updatedAt": "2022-09-18T19:51:46Z",
          "comments": []
        }
      ]
    },
    {
      "number": 131,
      "id": "PR_kwDODkfq5s5BcmjZ",
      "title": "mention PAR as one option for redirect URI registration at runtime",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/131",
      "state": "MERGED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "for issue #129",
      "createdAt": "2022-10-24T21:01:38Z",
      "updatedAt": "2022-10-24T21:05:59Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "ad0f3e0c531b0498b66101ab0ce028da4933b651",
      "headRepository": "oauth-wg/oauth-v2-1",
      "headRefName": "issue-129",
      "headRefOid": "bce88db73e14f71447fcd5202d63ab8a30f06b20",
      "closedAt": "2022-10-24T21:05:55Z",
      "mergedAt": "2022-10-24T21:05:55Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "8f584e5b6a9dde751b5874f131ba3190c0e47033"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 138,
      "id": "PR_kwDODkfq5s5J39Gc",
      "title": "All query parameters should be URL encoded in these two examples",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/138",
      "state": "MERGED",
      "author": "adeinega",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I have also included a minor change with the domain, so authorization-server.example becomes to be authorization-server.example.com. \r\n\r\nI believe it's more common to use example.com for documentation purposes, see https://en.wikipedia.org/wiki/Example.com.",
      "createdAt": "2023-02-13T18:02:48Z",
      "updatedAt": "2023-02-13T18:04:55Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "f274a833bffd063d927def6832983848e633bd60",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "02fcf611314f2857720495c49db4bf48cb2e01bb",
      "closedAt": "2023-02-13T18:04:05Z",
      "mergedAt": "2023-02-13T18:04:05Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "99d79694d7f7c486a485ddaceabd9c019ad83eb6"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s5NQkaC",
          "commit": {
            "abbreviatedOid": "02fcf61"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-02-13T18:03:59Z",
          "updatedAt": "2023-02-13T18:03:59Z",
          "comments": []
        }
      ]
    },
    {
      "number": 145,
      "id": "PR_kwDODkfq5s5M8LN8",
      "title": "Fix broken link on Section 4.3.Refresh Token Grant",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/145",
      "state": "MERGED",
      "author": "kg0r0",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixed https://github.com/oauth-wg/oauth-v2-1/issues/144",
      "createdAt": "2023-03-27T06:54:24Z",
      "updatedAt": "2023-03-27T09:41:46Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "d384ca05d63bbce47b8f53699d6755dba5d3374b",
      "headRepository": "kg0r0/oauth-v2-1",
      "headRefName": "fix/link",
      "headRefOid": "903e0e8962b3ce49932153ef8d97758d52607433",
      "closedAt": "2023-03-27T07:18:22Z",
      "mergedAt": "2023-03-27T07:18:22Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "76a4b3fe8171c0277a425d59c46307eed61d922f"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thank you!",
          "createdAt": "2023-03-27T07:18:17Z",
          "updatedAt": "2023-03-27T07:18:17Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 150,
      "id": "PR_kwDODkfq5s5VMd0z",
      "title": "Incorporated mix-up attack mitigations from security BCP",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/150",
      "state": "MERGED",
      "author": "kmzs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Most of the text is copied from the security BCP and only slightly adjusted.\r\n\r\nI am not sure if 2.1 needs to contain the detailed description of mix-up attacks and variants (56b6b6cdcfccf30baa124d37597d18a7cecf032e) or if it would be sufficient to add mix-up mitigations (2d07d10b9787d3798fab0913ff67ea1cd2e29d89).",
      "createdAt": "2023-07-11T12:06:54Z",
      "updatedAt": "2024-01-09T22:57:04Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "11935e9041737963a58e6ecb5eb03cde1c9bd85c",
      "headRepository": "Hackmanit/oauth-v2-1",
      "headRefName": "main",
      "headRefOid": "4dab73024e594a13d6fc9fff50ccf0fef58a04c8",
      "closedAt": "2024-01-09T22:52:12Z",
      "mergedAt": "2024-01-09T22:52:12Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "fd1d58e96b797c17254d915fa92729ae13868daa"
      },
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thank you, in general we have been erring on the side of leaving the detailed discussion of the security considerations in the Security BCP, and only moving the mitigation recommendations in 2.1. Would you be able to remove the detailed description from this PR?",
          "createdAt": "2023-08-20T13:20:02Z",
          "updatedAt": "2023-08-20T13:20:02Z"
        },
        {
          "author": "kmzs",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Finally had the time for this quick revert of my latest commit.\r\n\r\nDo you think the description of mix-up is fine now? Should we add a reference to the detailed description of mix-up attacks in the security BCP?",
          "createdAt": "2023-09-19T11:48:56Z",
          "updatedAt": "2023-09-19T11:48:56Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "Thanks, I added a reference to the security BCP in that section",
          "createdAt": "2024-01-09T22:57:03Z",
          "updatedAt": "2024-01-09T22:57:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s5sAzZb",
          "commit": {
            "abbreviatedOid": "4dab730"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-01-09T22:52:08Z",
          "updatedAt": "2024-01-09T22:52:08Z",
          "comments": []
        }
      ]
    },
    {
      "number": 154,
      "id": "PR_kwDODkfq5s5WD47M",
      "title": "Fix clickjacking http message example format",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/154",
      "state": "MERGED",
      "author": "DevDengChao",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fix https://github.com/oauth-wg/oauth-v2-1/issues/153",
      "createdAt": "2023-07-21T03:18:41Z",
      "updatedAt": "2023-07-21T17:01:04Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "11935e9041737963a58e6ecb5eb03cde1c9bd85c",
      "headRepository": "DevDengChao/oauth-v2-1",
      "headRefName": "fix/clickjacking-http-message-example-format",
      "headRefOid": "5f45a07b91c0a7f919eda0bab154cb60980c3132",
      "closedAt": "2023-07-21T17:01:04Z",
      "mergedAt": "2023-07-21T17:01:04Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "6d914d9fa1cb7ea6d590c1347c82a5be82ad98f8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 155,
      "id": "PR_kwDODkfq5s5WD50Q",
      "title": "Move attack introduction to end of the Open Redirector section",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/155",
      "state": "MERGED",
      "author": "DevDengChao",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Introduce Open Redirector's definition first, then introduce its weakness.",
      "createdAt": "2023-07-21T03:25:22Z",
      "updatedAt": "2023-07-21T17:01:28Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "11935e9041737963a58e6ecb5eb03cde1c9bd85c",
      "headRepository": "DevDengChao/oauth-v2-1",
      "headRefName": "chore/open-redirector-definition",
      "headRefOid": "25741b12f39c3258fdd2ae65f2d7b311d53b6748",
      "closedAt": "2023-07-21T17:01:28Z",
      "mergedAt": "2023-07-21T17:01:28Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "6e3ca345d5c3c04fe2904b3e158c603647a977f3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 172,
      "id": "PR_kwDODkfq5s5sAH1p",
      "title": "clarify expires_in is a JSON number",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/172",
      "state": "MERGED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This small PR attempts to clarify an unfortunately not that rare mistake of server implementations where they respond with a JSON string and not the expected JSON number.\r\n\r\nIn between the client implementations I maintain I get a PRs/issues at least twice a year which ask that the clients attempt to normalize the Token Endpoint response expires_in value instead of expecting it to be a number.",
      "createdAt": "2024-04-08T12:17:27Z",
      "updatedAt": "2024-04-26T16:29:59Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "f79f58841f717b0e6050da663c4a858bc100fda1",
      "headRepository": "panva/oauth-v2-1",
      "headRefName": "expires_in_json",
      "headRefOid": "167b7bf27a193c635855845d58a26ac590a3d331",
      "closedAt": "2024-04-26T16:25:26Z",
      "mergedAt": "2024-04-26T16:25:26Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "33141ce4e1154e1433f507b5451757b43f45ff56"
      },
      "comments": [
        {
          "author": "MozharAlhosni",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Just curious, won't this necessities adding the type for all other parameters? Because a few sentences after the proposed edit, the specification states:\r\n\r\n> Parameter names and string values are included as JSON strings. Numerical values are included as JSON numbers.",
          "createdAt": "2024-04-14T10:02:05Z",
          "updatedAt": "2024-04-14T10:02:30Z"
        },
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "> Just curious, won't this necessities adding the type for all other parameters?\r\n\r\nIt might. In the past this awkward definition in a follow up paragraph might've been seen as necessary because the same response parameters and their descriptions were used for the implicit grant response which does not have any data types associated given it's part of the url fragment. With that portion of the spec gone we might as well put the JSON data type in the descriptions for all token response parameters. ",
          "createdAt": "2024-04-14T13:40:12Z",
          "updatedAt": "2024-04-14T13:40:57Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 173,
      "id": "PR_kwDODkfq5s5skOk0",
      "title": "Minor fix",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/173",
      "state": "MERGED",
      "author": "MozharAlhosni",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "657c1b620170b7034d0787ef711218c69572dc51 - Changes \"eg.\" to \"e.g.,\".\r\n5289949541404795e56cea41f688d43c272b2ab4 - Changes \"e.g.\" to \"e.g.,\"",
      "createdAt": "2024-04-13T12:17:23Z",
      "updatedAt": "2024-04-26T16:25:45Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "f79f58841f717b0e6050da663c4a858bc100fda1",
      "headRepository": "MozharAlhosni/oauth-v2-1",
      "headRefName": "patch-1",
      "headRefOid": "5289949541404795e56cea41f688d43c272b2ab4",
      "closedAt": "2024-04-26T16:25:45Z",
      "mergedAt": "2024-04-26T16:25:45Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "7d1b6178427f991e6ce1e82b1ac5c8741b5d018d"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 175,
      "id": "PR_kwDODkfq5s5tIfR2",
      "title": "Remove duplicate \"are\"",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/175",
      "state": "MERGED",
      "author": "MozharAlhosni",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "cb2616f30c91b68b99f8eb492cce400bf394bc08 - Removes a duplicate \"are\".",
      "createdAt": "2024-04-19T07:04:44Z",
      "updatedAt": "2024-04-26T16:24:32Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "f79f58841f717b0e6050da663c4a858bc100fda1",
      "headRepository": "MozharAlhosni/oauth-v2-1",
      "headRefName": "patch-2",
      "headRefOid": "cb2616f30c91b68b99f8eb492cce400bf394bc08",
      "closedAt": "2024-04-26T16:24:32Z",
      "mergedAt": "2024-04-26T16:24:31Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "503fda10bf173ba7d53e1b746ff96ca227ac16d3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 178,
      "id": "PR_kwDODkfq5s5v3ZY0",
      "title": "Replace \"resource\" with \"resource server\". See #177",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/178",
      "state": "CLOSED",
      "author": "mrcaidev",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Solves #177.",
      "createdAt": "2024-05-18T16:12:11Z",
      "updatedAt": "2024-05-29T09:22:30Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "dcd8716ae89a56214f57a627df2a77be701ea08e",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "d45388fcda551c17817dbe96806551668d53ae38",
      "closedAt": "2024-05-29T09:22:30Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 182,
      "id": "PR_kwDODkfq5s5wr7FH",
      "title": "add self to acknowledgements",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/182",
      "state": "MERGED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "happy to add anyone else in a single PR to reduce noise",
      "createdAt": "2024-05-27T17:41:11Z",
      "updatedAt": "2024-06-13T07:36:02Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "dcd8716ae89a56214f57a627df2a77be701ea08e",
      "headRepository": "panva/oauth-v2-1",
      "headRefName": "ack-filip-skokan",
      "headRefOid": "fefca07a5f42f6c8ecf852c10a57cc70c7cdb12a",
      "closedAt": "2024-06-12T23:45:07Z",
      "mergedAt": "2024-06-12T23:45:07Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "7e0a25eaf6ae8598438dcd0d6b8c1b4d2a4cf50f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s58tVFL",
          "commit": {
            "abbreviatedOid": "fefca07"
          },
          "author": "bc-pi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Story checks out",
          "createdAt": "2024-06-02T09:51:44Z",
          "updatedAt": "2024-06-02T09:51:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 185,
      "id": "PR_kwDODkfq5s522G6v",
      "title": "fix: typos",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/185",
      "state": "MERGED",
      "author": "grjan7",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes typos.",
      "createdAt": "2024-07-30T08:38:58Z",
      "updatedAt": "2024-11-14T23:25:52Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "fcd80efb48f4600236e49cc8b0e5d95ec16c1542",
      "headRepository": "grjan7/oauth-v2-1",
      "headRefName": "typos",
      "headRefOid": "3671b56cc024f08003fae55e127923bb0ec31235",
      "closedAt": "2024-11-14T23:25:52Z",
      "mergedAt": "2024-11-14T23:25:52Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "f0352ade5ac0fbb8d2c3a0bc2904fe9a016a84b5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 190,
      "id": "PR_kwDODkfq5s6CD2iI",
      "title": "conslidate description of serialization",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/190",
      "state": "MERGED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This moves the description of serializations to the appendix\r\n\r\npart of #181",
      "createdAt": "2024-11-15T15:22:22Z",
      "updatedAt": "2024-11-15T16:46:55Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "0a7303fa482e715ae6a4875c9ee21beb64a140f0",
      "headRepository": "oauth-wg/oauth-v2-1",
      "headRefName": "serialization",
      "headRefOid": "ed6f4e499276ed9d2e027572aec9daaef5f10866",
      "closedAt": "2024-11-15T16:46:52Z",
      "mergedAt": "2024-11-15T16:46:52Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "e9da6e6fe74600cea9fa905ed0c1d2fd3b6a7d80"
      },
      "comments": [
        {
          "author": "panva",
          "authorAssociation": "MEMBER",
          "body": "Though i wonder whether the Authorization Response (`{#authorization-response}`) section should account for the `response_mode` extension - https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html with text like \"unless specified otherwise by an extension\".",
          "createdAt": "2024-11-15T15:44:30Z",
          "updatedAt": "2024-11-15T15:44:49Z"
        },
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "yeah I can add that, sounds reasonable",
          "createdAt": "2024-11-15T16:42:59Z",
          "updatedAt": "2024-11-15T16:42:59Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s6RX9ot",
          "commit": {
            "abbreviatedOid": "5fd1a46"
          },
          "author": "panva",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2024-11-15T15:39:57Z",
          "updatedAt": "2024-11-15T15:39:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 195,
      "id": "PR_kwDODkfq5s6FtrXn",
      "title": "add key rotation recommendation for access tokens",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/195",
      "state": "MERGED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "closes #189",
      "createdAt": "2024-12-19T01:04:01Z",
      "updatedAt": "2024-12-19T15:13:32Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "e9406f38ac7fdb2d40ca1203a97c361132a2cb2e",
      "headRepository": "oauth-wg/oauth-v2-1",
      "headRefName": "issue-189",
      "headRefOid": "861c273833680a1d1669eacb341dc27acd26b754",
      "closedAt": "2024-12-19T15:13:29Z",
      "mergedAt": "2024-12-19T15:13:29Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "947dec46061c8ea3f86d49638d5adf3940f1b011"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s6V43O4",
          "commit": {
            "abbreviatedOid": "861c273"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-19T13:35:42Z",
          "updatedAt": "2024-12-19T13:35:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 196,
      "id": "PR_kwDODkfq5s6Ftr6B",
      "title": "add a mention of phishing-resistant authenticators",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/196",
      "state": "MERGED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "...in the \"phishing attacks\" security consideration section\r\n\r\ncloses #188",
      "createdAt": "2024-12-19T01:06:46Z",
      "updatedAt": "2024-12-19T15:22:11Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "e9406f38ac7fdb2d40ca1203a97c361132a2cb2e",
      "headRepository": "oauth-wg/oauth-v2-1",
      "headRefName": "issue-188",
      "headRefOid": "5dca2566bd04e5e52d48bfe6f88346b745302d1c",
      "closedAt": "2024-12-19T15:22:08Z",
      "mergedAt": "2024-12-19T15:22:08Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "ea167a0099e69987b65fd88db82aebd941fce24c"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s6V411n",
          "commit": {
            "abbreviatedOid": "d328270"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2024-12-19T13:34:27Z",
          "updatedAt": "2024-12-19T13:34:31Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "It might not be obvious to anyone why a phishing resistent authenticator makes it easier for a user to confirm a site's authenticity. Something along the lines of \"as phishing resistant authentications will only offer a credential to login to a certain site to the user if the platform has successfully authenticated this site.\"\r\n \r\nAlso Nat's original comment was related to \"steal resource owners' password\" and suggested to make it more general by referring to pwasswords and other non-phishing resistent credentials (like OTPs). ",
              "createdAt": "2024-12-19T13:34:27Z",
              "updatedAt": "2024-12-19T13:34:31Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6V6juy",
          "commit": {
            "abbreviatedOid": "d328270"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-19T15:10:50Z",
          "updatedAt": "2024-12-19T15:10:50Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nphishing-resistant authenticators, as phishing resistant authenticators will offer a credential to log in to a certain site to the user only if the platform has successfully verified the site's origin. Client\r\n```",
              "createdAt": "2024-12-19T15:10:50Z",
              "updatedAt": "2024-12-19T15:10:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6V6mNF",
          "commit": {
            "abbreviatedOid": "5dca256"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-19T15:13:05Z",
          "updatedAt": "2024-12-19T15:13:05Z",
          "comments": []
        }
      ]
    },
    {
      "number": 197,
      "id": "PR_kwDODkfq5s6FttKB",
      "title": "expand on reasons why no refresh token expiration is provided",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/197",
      "state": "MERGED",
      "author": "aaronpk",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "closes #187",
      "createdAt": "2024-12-19T01:14:00Z",
      "updatedAt": "2024-12-19T15:08:00Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "e9406f38ac7fdb2d40ca1203a97c361132a2cb2e",
      "headRepository": "oauth-wg/oauth-v2-1",
      "headRefName": "issue-187",
      "headRefOid": "b36fd90d8bf023cbe469bb4af11364361741a07d",
      "closedAt": "2024-12-19T15:07:57Z",
      "mergedAt": "2024-12-19T15:07:57Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "5ecaa182ee2643196bdedd325900579e42ab6159"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s6V4vrJ",
          "commit": {
            "abbreviatedOid": "b36fd90"
          },
          "author": "tlodderstedt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-19T13:29:15Z",
          "updatedAt": "2024-12-19T13:29:15Z",
          "comments": []
        }
      ]
    },
    {
      "number": 198,
      "id": "PR_kwDODkfq5s6FyHax",
      "title": "Change Torsten's affiliation to SPRIND",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/198",
      "state": "MERGED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-12-19T13:22:01Z",
      "updatedAt": "2024-12-19T15:05:38Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "e9406f38ac7fdb2d40ca1203a97c361132a2cb2e",
      "headRepository": "oauth-wg/oauth-v2-1",
      "headRefName": "affiliation_torsten",
      "headRefOid": "d94cd5f061a7c129f24f5a4e139fd4dd82141498",
      "closedAt": "2024-12-19T15:05:35Z",
      "mergedAt": "2024-12-19T15:05:35Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "7c9b78c868e1cb9e6057f0eec7a7e37871ec9079"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s6V6eCd",
          "commit": {
            "abbreviatedOid": "d94cd5f"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-19T15:05:31Z",
          "updatedAt": "2024-12-19T15:05:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 199,
      "id": "PR_kwDODkfq5s6FyLLp",
      "title": "added port number exception to uri matching rules",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/199",
      "state": "MERGED",
      "author": "tlodderstedt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2024-12-19T13:27:59Z",
      "updatedAt": "2024-12-19T15:13:03Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "e9406f38ac7fdb2d40ca1203a97c361132a2cb2e",
      "headRepository": "oauth-wg/oauth-v2-1",
      "headRefName": "uri_matching",
      "headRefOid": "c133b62a63e3ca903e909c05b503755e3219dad4",
      "closedAt": "2024-12-19T15:12:59Z",
      "mergedAt": "2024-12-19T15:12:59Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "3830b8e58b1da16c8914076eabfed4c5b3d88abd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s6V6fMI",
          "commit": {
            "abbreviatedOid": "bd2aeea"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-12-19T15:06:38Z",
          "updatedAt": "2024-12-19T15:06:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODkfq5s6V6f9B",
          "commit": {
            "abbreviatedOid": "bd2aeea"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-12-19T15:07:20Z",
          "updatedAt": "2024-12-19T15:07:21Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "```suggestion\r\nThe only exception is native apps using a localhost URI: In this case, the authorization server\r\n```",
              "createdAt": "2024-12-19T15:07:20Z",
              "updatedAt": "2024-12-19T15:07:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 202,
      "id": "PR_kwDODkfq5s6GwWaf",
      "title": "#192 ",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/202",
      "state": "MERGED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-05T17:11:41Z",
      "updatedAt": "2025-01-05T17:19:31Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "147a42bea1911a77c4998ac1459e4b304178f851",
      "headRepository": "dickhardt/oauth-v2-1",
      "headRefName": "main",
      "headRefOid": "41d0e25e504e473d5cef41ad41ed1fcefb9a152d",
      "closedAt": "2025-01-05T17:19:30Z",
      "mergedAt": "2025-01-05T17:19:30Z",
      "mergedBy": "dickhardt",
      "mergeCommit": {
        "oid": "20ee21646ba7ebb39439a2bfefb253a99f3e5276"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 203,
      "id": "PR_kwDODkfq5s6GwXtx",
      "title": "point implementers to OIDC in intro #151",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/203",
      "state": "MERGED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-05T17:29:17Z",
      "updatedAt": "2025-01-09T17:15:57Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "20ee21646ba7ebb39439a2bfefb253a99f3e5276",
      "headRepository": "dickhardt/oauth-v2-1",
      "headRefName": "OIDC-reference",
      "headRefOid": "2a3c2374acc9238dc774e66be25f853f78fbd5a8",
      "closedAt": "2025-01-09T17:15:57Z",
      "mergedAt": "2025-01-09T17:15:57Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "426ce072a02a0a79b76e1a2cce636bf03b66242b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s6XbOdX",
          "commit": {
            "abbreviatedOid": "c3f1741"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-09T17:13:02Z",
          "updatedAt": "2025-01-09T17:13:02Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nOAuth is an authorization protocol, not an authentication protocol, as OAuth does not define the necessary components to achieve user authentication.\r\n```",
              "createdAt": "2025-01-09T17:13:02Z",
              "updatedAt": "2025-01-09T17:13:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6XbOff",
          "commit": {
            "abbreviatedOid": "c3f1741"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-09T17:13:06Z",
          "updatedAt": "2025-01-09T17:13:06Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nAn authentication protocol is necessary if the goal is to authenticate users. An example is OpenID Connect {{OpenID}}, which builds on OAuth to provide the security\r\n```",
              "createdAt": "2025-01-09T17:13:06Z",
              "updatedAt": "2025-01-09T17:13:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6XbOhE",
          "commit": {
            "abbreviatedOid": "c3f1741"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-09T17:13:09Z",
          "updatedAt": "2025-01-09T17:13:10Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\ncharacteristics and necessary components required of an authentication protocol. The\r\n```",
              "createdAt": "2025-01-09T17:13:09Z",
              "updatedAt": "2025-01-09T17:13:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6XbPM0",
          "commit": {
            "abbreviatedOid": "d85c188"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-09T17:14:34Z",
          "updatedAt": "2025-01-09T17:14:35Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\ncharacteristics and necessary components required of an authentication protocol.\r\n\r\nThe\r\n```",
              "createdAt": "2025-01-09T17:14:35Z",
              "updatedAt": "2025-01-09T17:14:35Z"
            }
          ]
        }
      ]
    },
    {
      "number": 204,
      "id": "PR_kwDODkfq5s6GwXxI",
      "title": "More secure use case",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/204",
      "state": "MERGED",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-05T17:30:05Z",
      "updatedAt": "2025-01-09T17:20:56Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "20ee21646ba7ebb39439a2bfefb253a99f3e5276",
      "headRepository": "dickhardt/oauth-v2-1",
      "headRefName": "more-secure-use-case",
      "headRefOid": "04c44b4e2d198420a79c936778baa58afdf6183d",
      "closedAt": "2025-01-09T17:20:55Z",
      "mergedAt": "2025-01-09T17:20:55Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "defa6b7d2cada9a72a85e9b02564a07047b9f134"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s6W_J1j",
          "commit": {
            "abbreviatedOid": "88adc12"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-06T23:29:14Z",
          "updatedAt": "2025-01-06T23:29:15Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'd suggest using _credentials_ instead of `username and password` in this sentence.\r\n\r\nThe reason is credentials also cover things such as API keys.",
              "createdAt": "2025-01-06T23:29:14Z",
              "updatedAt": "2025-01-06T23:29:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6XGKbC",
          "commit": {
            "abbreviatedOid": "88adc12"
          },
          "author": "dickhardt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-07T17:19:33Z",
          "updatedAt": "2025-01-07T17:19:33Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This is an example, and so we are specific with username and password. \r\n\r\nThere are many, many kinds of credentials. Access tokens and refresh tokens are credentials. A broader term muddies understanding the eample.",
              "createdAt": "2025-01-07T17:19:33Z",
              "updatedAt": "2025-01-07T17:19:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6XG__z",
          "commit": {
            "abbreviatedOid": "88adc12"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-07T19:22:54Z",
          "updatedAt": "2025-01-07T19:22:54Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Got it.",
              "createdAt": "2025-01-07T19:22:54Z",
              "updatedAt": "2025-01-07T19:22:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6XbRcc",
          "commit": {
            "abbreviatedOid": "88adc12"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-09T17:19:04Z",
          "updatedAt": "2025-01-09T17:19:05Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nAn example where OAuth is used is where an end user (resource owner) grants a financial management \r\n```",
              "createdAt": "2025-01-09T17:19:04Z",
              "updatedAt": "2025-01-09T17:19:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODkfq5s6XbSFm",
          "commit": {
            "abbreviatedOid": "0fd5c2f"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-09T17:20:25Z",
          "updatedAt": "2025-01-09T17:20:25Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\ndirectly with their financial institution's server (authorization server), \r\n```",
              "createdAt": "2025-01-09T17:20:25Z",
              "updatedAt": "2025-01-09T17:20:26Z"
            }
          ]
        }
      ]
    },
    {
      "number": 205,
      "id": "PR_kwDODkfq5s6Gwawe",
      "title": "Oauth versions",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/205",
      "state": "OPEN",
      "author": "dickhardt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-01-05T18:11:46Z",
      "updatedAt": "2025-01-09T17:53:11Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "20ee21646ba7ebb39439a2bfefb253a99f3e5276",
      "headRepository": "dickhardt/oauth-v2-1",
      "headRefName": "oauth-versions",
      "headRefOid": "90cd4e8b4e02fa975ce805b8d5079ebb9fa0641f",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "body": "We're going to rethink this and bring it up on the mailing list and/or IETF 122",
          "createdAt": "2025-01-09T17:53:10Z",
          "updatedAt": "2025-01-09T17:53:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s6W_KZc",
          "commit": {
            "abbreviatedOid": "90cd4e8"
          },
          "author": "adeinega",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2025-01-06T23:32:11Z",
          "updatedAt": "2025-01-06T23:32:11Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Seems like a separate https://github.com/oauth-wg/oauth-v2-1/pull/204 covers this.",
              "createdAt": "2025-01-06T23:32:11Z",
              "updatedAt": "2025-01-06T23:32:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 206,
      "id": "PR_kwDODkfq5s6NR-4f",
      "title": "Fixes 3 spellings and removes extra whitespaces",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/206",
      "state": "MERGED",
      "author": "kushaldas",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adds no extra text other than fixes for spellings and removals of extra whitespaces in a few sentences. ",
      "createdAt": "2025-03-04T10:06:14Z",
      "updatedAt": "2025-03-04T14:22:12Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "6b39e89ad37e659dd610b8663e2352def8a5cfe3",
      "headRepository": "kushaldas/oauth-v2-1",
      "headRefName": "spellcheck",
      "headRefOid": "4cff84b4feb7bc171d1f34e97a6d7a5b068ef278",
      "closedAt": "2025-03-04T14:22:12Z",
      "mergedAt": "2025-03-04T14:22:12Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "be8df5055e6ef4baa1672b6ead0c9a166e334de5"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODkfq5s6eaaMz",
          "commit": {
            "abbreviatedOid": "4cff84b"
          },
          "author": "aaronpk",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-03-04T14:09:37Z",
          "updatedAt": "2025-03-04T14:09:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 207,
      "id": "PR_kwDODkfq5s6P1nyK",
      "title": "add client credentials in body change to oauth-2-0-differences",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/207",
      "state": "MERGED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Adds the change from dcd8716 to https://www.ietf.org/archive/id/draft-ietf-oauth-v2-1-12.html#name-differences-from-oauth-20",
      "createdAt": "2025-03-24T09:44:05Z",
      "updatedAt": "2025-05-28T13:51:39Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "be8df5055e6ef4baa1672b6ead0c9a166e334de5",
      "headRepository": "panva/oauth-v2-1",
      "headRefName": "update-diff",
      "headRefOid": "e398b8ccbb92eadc583adbbcf8a85e871c2b115e",
      "closedAt": "2025-05-28T13:51:39Z",
      "mergedAt": "2025-05-28T13:51:39Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "17cb1a67d75d75dea00dcdf8f31f1d92596db2f3"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 208,
      "id": "PR_kwDODkfq5s6P1rmi",
      "title": "remove dupe in and sort #extensions",
      "url": "https://github.com/oauth-wg/oauth-v2-1/pull/208",
      "state": "MERGED",
      "author": "panva",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Removes the dupe (9447) and sorts the #extensions by their RFC number\r\n\r\ncloses #193",
      "createdAt": "2025-03-24T09:50:38Z",
      "updatedAt": "2025-05-28T13:43:15Z",
      "baseRepository": "oauth-wg/oauth-v2-1",
      "baseRefName": "main",
      "baseRefOid": "be8df5055e6ef4baa1672b6ead0c9a166e334de5",
      "headRepository": "panva/oauth-v2-1",
      "headRefName": "sort-extensions",
      "headRefOid": "9c2f928057ab0f976feeda80b116e34ab0499ff0",
      "closedAt": "2025-05-28T13:43:15Z",
      "mergedAt": "2025-05-28T13:43:15Z",
      "mergedBy": "aaronpk",
      "mergeCommit": {
        "oid": "65fe3c57e0bf91e8f9f12e16326377c43b6f8e38"
      },
      "comments": [],
      "reviews": []
    }
  ]
}